#!/bin/sh
#
# Copyright (c) 1998, 2002, Oracle Corporation.  All rights reserved.
#

version()
{
  if [ -f $ORA_TMP/ora_version_${ORACLE_SID} ]; then
    VER=`cat $ORA_TMP/ora_version_${ORACLE_SID}`
    set $VER
    VERSION=$1
    VERSION_SHORT=$2
    VERSION_MAIN=$3
    SWA_HISTOGRAM=$4
    PGA_ADVICE=$5
    SWA_ACTIVE_TABLESPACE=$6

    if [ "$VERSION" = "" -o "$VERSION_SHORT" = "" -o "$VERSION_MAIN" = "" ]; then
      rm -f $ORA_TMP/ora_version_${ORACLE_SID}
      version
    fi

  else
    #
    # Check version
    #
    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected" > $ORA_TMP/ver$$

      connect $DBUSER

      select 'SQL_WORKAREA_HISTOGRAM'||'_EXISTS' view_exists
      from all_views where view_name
           like '%SQL_WORKAREA_HISTOGRAM%' and rownum = 1;

      select 'PGA_TARGET_ADVICE'||'_EXISTS' view_exists
      from all_views where view_name
           like '%PGA_TARGET_ADVICE%' and rownum = 1;

     select 'SQL_WORKAREA_ACTIVE_TABLESPACE'||'_EXISTS' col_exists
     from ALL_TAB_COLUMNS
     where COLUMN_NAME = 'TABLESPACE'
           AND TABLE_NAME = 'V_\$SQL_WORKAREA_ACTIVE';

     select '###' || version || '###' version
     from PRODUCT_COMPONENT_VERSION
     where PRODUCT like 'Oracle%';
!

    grep SQL_WORKAREA_HISTOGRAM_EXISTS $ORA_TMP/ver$$ > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      SWA_HISTOGRAM=1
    else
      SWA_HISTOGRAM=0
    fi

    grep PGA_TARGET_ADVICE_EXISTS $ORA_TMP/ver$$ > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      PGA_ADVICE=1
    else
      PGA_ADVICE=0
    fi

    grep SQL_WORKAREA_ACTIVE_TABLESPACE_EXISTS $ORA_TMP/ver$$ > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      SWA_ACTIVE_TABLESPACE=1
    else
      SWA_ACTIVE_TABLESPACE=0
    fi

    VERSION=`cat $ORA_TMP/ver$$ | grep '###' | sed -e 's/^###\(.*\)###$/\1/g'`
    VERSION_SHORT=`echo $VERSION | sed -e 's/^\([0-9]*\)\.\([0-9]*\)\..*$/\1\.\2/g'`
    VERSION_MAIN=`echo $VERSION | sed -e 's/^\([0-9]*\).*$/\1/g'`

    #
    # Only save when OK.
    #
    if [ "$VERSION" != "" -a "$VERSION_SHORT" != "" -a "$VERSION_MAIN" != "" ]; then
      echo "$VERSION $VERSION_SHORT $VERSION_MAIN $SWA_HISTOGRAM $PGA_ADVICE $SWA_ACTIVE_TABLESPACE" > $ORA_TMP/ora_version_${ORACLE_SID}
    fi
#    rm -f $ORA_TMP/ver$$
  fi
}

usage()
{
  if [ "$ORA_USE_HASH" = "1" ]; then
    SQLID='<hash_val>';
  else
    SQLID=' <sql_id> ';
  fi

  echo "$1

  Usage: $EXEC_NAME [-u user] [-i instance#] <command> [<arguments>]
    General
      -u user/pass                  use USER/PASS to log in
      -i instance#                  append # to ORACLE_SID
      -sid <sid>                    set ORACLE_SID to sid
      -top #                        limit some large queries to on # rows

      - repeat <interval> <count|forever> <ora command>
                                    Repeat an coomand <count> time. Sleep <interval> between two calls
    Command are:


      - execute:                    cursors currently being executed
      - longops:                    run progression monitor
      - sessions:                   currently open sessions
      - stack <os_pid>              get process stack using oradebug
      - cursors [all] <match_str>:  [all] parsed cursors
      - sharing <sql_id>:           print why cursors are not shared
      - events [px]:                events that someone is waiting for
      - events [read_by_other_session]
                                    events that someone is read by other session
      - ash <minutes_from_now>
            [duration]
            [-f <file_name>]        active session history for specified period
                                    e.g. 'ash 30' to display from [now - 30min] to [now]
                                    e.g. 'ash 30 10 -f foo.txt' to display a 10 minutes period from [now - 30min] and store the result in file foo.txt
      - ash_wait_graph <minutes_from_now>
            [duration]
            [-f <file_name>]        PQ event wait graph using ASH data
                                    Arguments are the same as for ash except that the output must be shown with the mxgraph tool
      - ash_sql <sql_id>            Show all ash rows group by sampli_time and event for the specified sql_id
      - [-u <user/passwd>] degree   degree of objects for a given user
      - [-u <user/passwd>] colstats stats for each table, column
      - [-u <user/passwd>] tabstats stats for each table
      - params [<pattern>]:         view all parameters, even hidden ones
      - snap:                       view all snapshots status
      - bc:                         view contents of buffer cache
      - temp:                       view used space in temp tbs
      - asm:                        Show asm space/free space
      - space [<tbs>]:              view used/free space in a given tbs
      - binds   $SQLID:         display bind capture information for specified cursor
      - fulltext $SQLID:        display the entire SQL text of the specified statement
      - last_sql_hash [<sid>]:      hash value of the last styatement executed by the specified sid. If no sid speficied,
                                    return the last hash_value of user sessions
      - openv   $SQLID
                [<pattern>]:        display optimizer env parameters for specified cursor
      - plan    $SQLID [<fmt>]: get explain plan of a particular cursor
      - pxplan  $SQLID:         get explain plan of a particular cursor and all connected cursor slave SQL
      - wplan $SQLID [<fmt>]:   get explain plan with work area information
      - pxwplan  $SQLID:        get explain plan with work area information of a particular cursor and all connected cursor slave SQL
      - eplan  $SQLID [<fmt>]:  get explain plan with execution statistics
      - pxeplan  $SQLID:        get explain plan with execution statistics of a particular cursor and all connected cursor slave SQL
      - gplan   $SQLID:         get graphical explain plan of a particular cursor using dot specification
      - webplan $SQLID          get graphical explain plan of a particular
                 [/<child_number>]  cursor using gdl specification
                 [<decorate>]:      optional: child_number, default is zero.
                                    optional: decorate to print further node information. default is 0,
                                    1 => print further node information such as cost, filter_predicates etc.
                                    2 => in addition to the above, print row vector information
                                    sample usage:
                                    # ora webplan 4019453623
                                    print more information (decorate 1)
                                    # ora webplan 4019453623/1 1
                                    more information, overload! (decorate 2)
                                    # ora webplan 4019453623/1 2
                                    using sql_id along with child number instead of hash value
                                    # ora webplan aca4xvmz0rzup/3 1
      - hash_to_sqlid $SQLID:       get the sql_id of the cursor given its hash value
      - sqlid_to_hash <sql_id>:     get the hash value of the cursor given its
                                    (unquoted) sql_id
      - exptbs:                     generate export tablespace script
      - imptbs:                     generate import tablespace script
      - smm [limited]:              SQL memory manager stats for active workareas
      - onepass:                    Run an ora wplan on all one-pass cursors
      - mpass:                      Run an ora wplan on all multi-pass cursors
      - pga:                        tell how much pga memory is used
      - pga_detail <os_pid>|
                   -mem <size_mb>:  Gives details on how PGA memory is consumed by a process (given its os PID) or
                                    by the set of precesses consuming more than <size_mb> MB of PGA memory (-mem option)
      - pgasnap [<snaptab>]         Snapshot the pga advice stats
      - pgaadv  [-s [<snaptab>]]
                [-o graphfile]
                [-m min_size]:      generate a graph from v$pga_target_advice and display it or store it in a file if the -o option is used.
                                      -s [<snaptab>] to diff with a previous snapshot (see pgasnap cmd)
                                      -o [graphfile] to store the result in a file instead of displaying it
                                      -m [min_size] only consider workareas with a minimum size
      - pgaadvhist [-f <f_min>
                       [<f_max>]]   display the advice history for all factors or for factor between f_min and f_max
      - sga:                        tell how much sga memory is used
      - sga_stats:                  tell how sga is dynamically used
      - sort_usage:                 tell how temp tablespace is used in detail
      - sgasnap [<snaptab>]         Snapshot the sga advice stats
      - sgaadv  [-s [<snaptab>]]
                [-o graphfile]      generate a graph from v$db_cache_advice and v$shared_pool_advice and store it in a file if the -o option is used.
                                      -s [<snaptab>] to diff with a previous snapshot (see sgasnap cmd)
                                      -o [graphfile] to store the result in a file instead of displaying it
      - process [<min_mb>]:         display process info with pga memory
      - version:                    display Oracle version number

      - cur_mem [$SQLID]        display the memory used for a given or all cursors
      - shared_mem [$SQLID]     detailed dump of cursor shared mem allocations
      - runtime_mem [$SQLID]    detailed dump of cursor runtime memory allocations
      - all_mem [$SQLID]          do all of the memory dumps
      - pstack <pid>|all
               [<directory>]        run pstack on specified process (or all if 'all' specified) and store
                                    files in specified dir ($T_TRC when not specified)
      - idxdesc [username]
                <tabName>           list all indexes for a given user or for a given user and table
      - segsize [username]
                <objName>           list size of all objects(segments) for given user for a given user and object

      - tempu <username>            list temporary ts usage of all users or for a given user
      - sqlstats [$SQLID]           list sql execution stats (like buffer_gets, phy. reads etc) for a given sql_id/hash_value of statement

      - optstats [username]         list optimizer stats for all tables stored
                 <tabname>          in dictionary for a given user or for a given user and table

      - userVs                      list all user Views (user_tables, user_indexes etc)
      - fixedVs                         list all V$ Views
      - fixedXs                         list all X$ Views

      - px_processes                list all px processes (QC and slaves)
      - cursor_summary              summarize stats about (un)pinned cursors
      - rowcache                    summarizes row cache statistics
      - monitor_list                lists all the statements that have been monitored
      - monitor [xml]:              wraps dbms_sqltune.report_sql_monitor().
                                    Directly passe the arguments to the PL/SQL procedure. Args are:
                                      sql_id, session_id, session_serial, sql_exec_start, sql_exec_id, inst_id,
                                      instance_id_filter, parallel_filter, report_level, type.
                                    Examples:
                                      - monitor xml   shows XML report
                                      - monitor   show last monitored stmt
                                      - monitor   sql_id=>'8vz99cy9bydv8', session_id=>105 will
                                        show monitor info for sql_id 8vz99cy9bydv8 and session_id 105
                                    Use simply ora monitor 8vz99cy9bydv8 to display monitoring information for sql_id 8vz99cy9bydv8.

                                    Syntax for parallel filters is:
                                    [qc][servers(<svr_grp>[,] <svr_set>[,] <srv_num>)]

                                    Use /*+ monitor */ to force monitoring.

      - monitor_old [ash_all] [<sqlid>]
                [qc|<slave_grp#> [<slave_set#> [<slave#>]]]
                                    Old version of SQL monitoring, use a SQL query versus the report_sql_monitor()
                                    package. Display monitoring info for the LAST execution of the specified cursor.
                                    Cursor response time needs to be at least 5s for monitoring to start (use the
                                    monitor hint to force monitoring). Without any parameter, will display monitoring info
                                    for the last cursor that was monitored
                                    - ash_all will aggregate ash data over all executions of the cursor (useful for short
                                      queries that are executed many times).
                                    If parallel:
                                    - qc to see only data for qc
                                    - slave_grp# to see only data for one parallelizer
                                    - slave_grp# + slave_set# to see only data for one slave set of one parallelizer,
                                    - slave_grp# + slave_set# + slave# to see data only for the specified slave

      - sql_task [progress | interrupt <task_name> | history <#execs> |
                  report <task_name> <section> <exec_name> ]
                                progress: progress monitoring for executing sql tasks
                                interrupt: interrupt an executing sql task
                                history:   print a history of last n executions
                                report:    get a sql tune report
      - sql_use_temp_segment       Find Who And What SQL Is Using Temp Segments.

      - sh                         Run a shell command. E.g.
                                   ora repeat 5 10 sh 'ps -edf | grep DESC'

      - awr_dbid                   Show AWR dbid
      - awr_delete dbid            Delete AWR awr data from repository by dbid
      - awr_all_snap dbid          Show AWR dbid min_snap max_snap
      - awr_os dbid inst_id
                                   Show OS Load %busy   %user   %sys    %idle   %iowait
      - awr_parse dbid inst        Show AWR parse, hard parse times, hard_parse
      - awr_dbtime dbid inst       Show AWR dbtime per snap
      - awr_dbtime_order dbid inst Show AWR dbtime order by desc
      - awr_dbcpu dbid inst_id     Show DB CPU per snap
      - awr_sql_elaps_time [dbid]
                                   Show AWR SQL elapsed time
      - awr_sql_elaps_time [dbid] [inst]
                                   Show AWR SQL elapsed time
      - awr_sql_elaps_time_order dbid inst
                                   Show AWR SQL elapsed time order by desc
      - awr_logical_reads         dbid  inst
                                   Show AWR logical  reads M
      - awr_logical_reads_order   dbid  inst
                                   Show AWR logical  reads M order by M/s
      - awr_physical_reads        dbid  inst
                                   Show AWR physical reads M
      - awr_physical_reads_order  dbid  inst
                                   Show AWR physical reads M order by M/s
      - awr_physical_writes       dbid  inst
                                   Show AWR physical writes M
      - awr_physical_writes_order dbid  inst
                                   Show AWR physical writes M order by M/s
      - awr_sessions dbid inst_id  Show sessions per snap

      - awr_sql dbid sql_id        Show AWR sql_id executions, per elapsed time.
      - awr_sql_info dbid sql_id   Show AWR sql_id machine, program, module, count.
      - awr_fulltext dbid sql_id   Show AWR sql fulltext
      - awr_plan dbid sql_id plan_hash
                                   Show AWR sql plan, if plan_hash  is null, show all plans.
      - awr_plan_obj dbid obj_name
                                   Plan containing object show AWR sql_id.
      - awr_binds dbid sql_id end_snap_id
                                   Show AWR bind values in end_snap_id.
      - awr_top10_events dbid inst begin_id end_id
      - tab_frag owner [frag_percent]
                                   Show table fragment.
      - index_frag owner [frag_percent]
                                   Show index fragment.
      - rman_fullrestore_scripts dest_dbfile_dir
                                   Generate rman full database restore scripts
      - top_buffers_gets           Top 10 by buffer gets > 10000
      - top_physical_reads         Top 10 by Physical Reads (disk_reads > 1000)
      - top_executions             Top 10 by Executions > 100
      - top_parse_calls            Top 10 by Parse Calls  > 1000
      - top_sharable_memory        Top 10 by Sharable Memory > 1M
      - top_version_count          Top 10 by Version Count > 20
      - top_cpu_usage              Top 10 by CPU usage (cpu_time)
      - top_running_time           Top 10 by Running Time (first_load_time desc)
      - create_tbs path size       Create test database's tablespace script
      - create_tbs path size [dbid]Create dbid's test database's tablespace script

      - hold_txlock                Show sessions holding a TX lock
      - wait_txlock                Show sessions waiting a TX lock
      - rowid   <rowid>            Display rowid's file_id, file_name, block info, object info, extent_id

  Memory: The detailed memory dumps need to have events set to work.
          The events bellow can be added to the init.ora file
  event=\"10277 trace name context forever, level 10\" # mutable mem
  event=\"10235 trace name context forever, level 4\"  # shared mem

  NOTE
  ====
    - Set environment variable ORA_USE_HASH to 1 to get SQL hash values instead of SQL ids
    - Set environment variable DBUSER to change default connect string which is \"/ as sysdba\"
    - Set environment variable ORA_TMP to the default temp directory (default if /tmp when not set)
"

  exit 1
}

setup_hash_value()
{
  EXCLUDE=-1

  # get potential column names
  COLNAME1=$1
  COLNAME2=$2
  shift 2

  case "$1" in
    "-sess")
      temp_hash_value=`$ORA_PROG last_sql_hash $2 | sed -e "s/ \n//g"`
      SHIFT_PARAM=2
      ;;

    "all")
      SHIFT_PARAM=1
      ;;

    "")
      SHIFT_PARAM=0
      EXCLUDE=0
      ;;

    *)
      SHIFT_PARAM=1
      temp_hash_value="$1"
      ;;

  esac

  if [ "$temp_hash_value" != "" ]; then
    HVAL=`echo "$temp_hash_value" | sed -e "s/\([0-9A-Za-z]*\)\/\([0-9]*\)/\1/g"`
    CNUM=`echo "$temp_hash_value" | sed -e "s/\([0-9A-Za-z]*\)\/\([0-9]*\)/\2/g"`
    if [ "$CNUM" = "" -o "$CNUM" = "$temp_hash_value" ]; then
      CNUM=0
    fi

    # determine if sql_id or hash_value. Only sql_id can have 13 characters
    if [ ${#HVAL} -eq 13 ]; then
      COLNAME=$COLNAME2
      HVAL="'$HVAL'"
    else
      COLNAME=$COLNAME1
    fi

  else
    HVAL=0
    CNUM=0
  fi
}

create_format_functions()
{
  sqlplus -s /NOLOG <<EOF | grep '123K'  > /dev/null 2>&1
    connect $DBUSER

    select dbms_xplan.format_number2(123000) from dual;
EOF

  if [ $? = 0 ]; then
    # formatting functions are externalized in dbms_xplan
    FORMAT_SIZE="dbms_xplan.format_size2"
    FORMAT_NUMBER="dbms_xplan.format_number2"
  else
    FORMAT_SIZE="bill_format_size"
    FORMAT_NUMBER="bill_format_number"

  sqlplus -s /NOLOG << ! > /dev/null 2>&1

    connect $DBUSER

    create function bill_format_size(num number)
    return varchar2 as
      tmp number := num;
      idx number := 0;
      postfix varchar2(10) := ' kmgtp####';
    begin
      for idx in 1 .. 6 loop
        if (tmp < 1024) then
          return lpad(round(tmp) || substr(postfix, idx, 1), 5);
        end if;

        tmp := tmp / 1024;
      end loop;

      return '#####';
    end;
    /

    create function bill_format_number(num number)
    return varchar2 as
      tmp number := num;
      idx number := 0;
      postfix varchar2(10) := ' KMGTP####';
    begin
      for idx in 1 .. 6 loop
        if (tmp < 1000) then
          return lpad(round(tmp) || substr(postfix, idx, 1), 5);
        end if;

        tmp := tmp / 1000;
      end loop;

      return '#####';
    end;
    /

!
  fi
}


EXEC_NAME=`basename $0`
ORA_PROG=$0
V=v
INST_ID=""
RAC=0
WHERE=where
ARGS=""
BROWSER=firefox
RENDER=aisee

if [ "$ORA_TMP" = "" ]; then
  ORA_TMP="/tmp"
fi

while [ 1 ]; do
  case "$1" in
    "-u")
      ARGS="$ARGS $1 $2"
      DBUSER=$2
      shift
      ;;

    "-i")
      ARGS="$ARGS $1 $2"
      ORACLE_SID=${ORACLE_SID}$2
      shift
      ;;

    "-sid")
      ARGS="$ARGS $1 $2"
      ORACLE_SID=$2
      shift
      ;;

    "-rac")
      ARGS="$ARGS $1"
      RAC=1
      V=gv
      INST_ID="inst_id,"
      ;;

    "-top")
      ARGS="$ARGS $1 $2"
      WHERE="$WHERE rownum < $2 and"
      shift;
      ;;

    "-pred")
      ARGS="$ARGS $1 \"$2\""
      WHERE="$WHERE $2 and"
      shift;
      ;;


    *)
      break
      ;;
  esac
  shift
done

if [ "$DBUSER" = "" ]; then
  DBUSER="/ as SYSDBA"
fi

if [ "$MAX_INST" = "" ]; then
  MAX_INST=4
fi

if [ "$MIN_SNAP_ID" = "" ]; then
  MIN_SNAP_ID=20
fi

if [ "$MAX_SNAP_ID" = "" ]; then
  MAX_SNAP_ID=30000000
fi

if [ -f "$FRAME_PATH"/env ]; then
  . "$FRAME_PATH"/env
fi

version

if [ $VERSION_MAIN -lt 10 ]; then
  ORA_USE_HASH=1
fi

if [ $# -lt 1 ]; then
  usage "Syntax Error"
fi


if [ "$1" = "fulltext" -o "$1" = "full_text" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    set long 40000000
    col sql_hash format A15
    col sql_id format A18
    col exec format 9999
    col sql_fulltext format A75 WORD_WRAP

    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select $COLNM||
           decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
           sql_fulltext
    from v\$sql
    where child_number=$CNUM
          and $COLNAME=$HVAL;
!
exit 0
fi

if [ "$1" = "ash_sql" -o "$1" = "sqlash" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor sql_id is missing"
  fi

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 1000
    set tab      off
    set linesize 220
    set echo off
    set long     40000000
    col sql_hash format A15
    col sql_id format A18
    col exec format 9999
    col sql_fulltext format A75 WORD_WRAP
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;
    col p2 format a20
    col p1 format a30
    col sample_time format A40
    set pagesize 100
    col activity format A30
    col nb format 999
    col name format a10
    BREAK ON sample_time skip 1

    select sample_time, activity, p1, p2, object_name name,
           count(*) nb
    from
      (select sample_time, nvl(event, 'CPU') activity,
              case when event is null or wait_class = 'User I/O'
                   then '-' else p1text || ': ' || p1
              end p1,
              case when event is null or wait_class = 'User I/O'
                   then '-' else p2text || ': ' || p2
              end p2,
        object_name
       from v\$active_session_history,
            dba_objects
       where object_id(+) = current_obj#
       and  $COLNAME=$HVAL)
    group by sample_time, activity, p1, p2, object_name
    order by 1, 2, 3, 4, 5,6;
!

exit 0
fi


if [ "$1" = "execute" ] || [ "$1" = "executing" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  if [ "$2" != "" ]; then
    if [ $VERSION_MAIN -lt 10 ]; then
      PRED="s.sql_text like '%$2%' "
    else
      PRED="s.sql_fulltext like '%$2%' "
    fi
  else
    PRED="1=1"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 100
    set tab off
    col address format A15
    col sql_hash format A15
    col sql_id format A18
    col exec format 9999
    col sql_text format A75 WORD_WRAP

    select /*+ BDAGEVIL leading(se) */
        $COLNM||decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
        users_executing exec, sql_text
    from v\$sql s
    WHERE $PRED
          and s.users_executing > 0
          and s.sql_text not like '%BDAGEVIL%';
!
exit 0
fi

if [ "$1" = "version" ]; then

  version;

  #
  # Get Oracle version number
  #
  sqlplus -s /NOLOG << !  | grep '###' | sed -e 's/^###\(.*\)###$/\1/g' > $ORA_TMP/oraout$$

    set echo off
    connect $DBUSER

    select '###' || version || '###' version
    from PRODUCT_COMPONENT_VERSION
    where PRODUCT like 'Oracle%';
!
  VERSION=`cat $ORA_TMP/oraout$$`
  rm -f $ORA_TMP/oraout$$

  echo
  echo "Oracle version: $VERSION"
  echo

  exit 0
fi

if [ "$1" = "sql_tune" ]; then

  version;

  #
  # Get Oracle version number
  #
  sqlplus -s /NOLOG << !

    set echo off
    set feedback off
    connect $DBUSER
    set linesize 150
    col name format a10
    col target format a10
    col task_name format a10
    col target_desc format a10
    col info format a50

    select * from
     (select opname name,
             task_name,
             sofar cur_sql,
             totalwork nb_sql,
             START_TIME,
             TIME_REMAINING,
             findings,
             decode(info1_desc, NULL, '', info1_desc || ': '|| info1) ||
             decode(info2_desc, NULL, '', chr(10)||info2_desc || ': '||info2) ||
             decode(info3_desc, NULL, '', chr(10)||info3_desc || ': '||info3) ||
             decode(info4_desc, NULL, '', chr(10)||info4_desc || ': '||info4)
             Info
      from   v\$advisor_progress p,
             dba_advisor_tasks t
      where  t.task_id = p.task_id
      order by START_TIME desc)
      where rownum = 1;
!

  exit 0
fi

if [ "$1" = "repeat" ]; then

  shift;
  interval=$1
  shift
  count=$1
  shift

  while [ 1 = 1 ]; do
    echo
    CURDATE=`date +"%D %T"`
    echo "######################## $CURDATE ########################"
    $ORA_PROG $ARGS $*
    if [ $? -eq 1 ]; then
      exit 1
    fi
    sleep $interval
    if [ "$count" = "forever" ]; then
      continue;
    fi;

    let "count=count-1"
    if [ $count -le 0 ]; then
      break;
    fi;
  done;
fi


if [ "$1" = "smm" ]; then

  version;

  if [ "$2" = "limited" ]; then
    OPTALL=0
  else
    OPTALL=1
  fi

  if [ $SWA_HISTOGRAM -eq 1 ]; then
    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 1000
      set linesize 130
      col users_executing format A5
      col sql_text format A65

      col name format A50
      col VALUE format A20 JUS C
      col TOTAL format A15 JUS L
      col OPTIMAL format A15 JUS L
      col ONEPASS format A15 JUS L
      col MPASS format A15 JUS L

      select sum(TOTAL_EXECUTIONS) || ' ' TOTAL,
             sum(OPTIMAL_EXECUTIONS) || ' (' ||
             round(sum(OPTIMAL_EXECUTIONS)*100/
                   decode(sum(TOTAL_EXECUTIONS), 0, 1, sum(TOTAL_EXECUTIONS)))
                   || '%)' OPTIMAL,
             sum(ONEPASS_EXECUTIONS) || ' (' ||
             round(sum(ONEPASS_EXECUTIONS)*100/
                   decode(sum(TOTAL_EXECUTIONS), 0, 1, sum(TOTAL_EXECUTIONS)))
                   || '%)' ONEPASS,
             sum(MULTIPASSES_EXECUTIONS) || ' (' ||
             round(sum(MULTIPASSES_EXECUTIONS)*100/
                   decode(sum(TOTAL_EXECUTIONS), 0, 1, sum(TOTAL_EXECUTIONS)))
                   || '%)' MPASS
      from   v\$sql_workarea_histogram
      where  LOW_OPTIMAL_SIZE > 64*1024;

      col size_range format A20
      col optimal format 9999999999
      col onepass format 9999999999
      col multipasses format 9999999999
      select lpad(case
              when LOW < 1024*1024
              then round(LOW/1024) || ' KB'
              when LOW < 1024*1024*1024
              then round(LOW/1024/1024) || ' MB'
              when LOW < 1024*1024*1024*1024
              then round(LOW/1024/1024/1024) || ' GB'
              else round(LOW/1024/1024/1024/1024) || ' TB'
            end, 6, ' ') || ' ->' ||
       lpad(case
              when HIGH < 1024*1024
              then round(HIGH/1024) || ' KB'
              when HIGH < 1024*1024*1024
              then round(HIGH/1024/1024) || ' MB'
              when HIGH < 1024*1024*1024*1024
              then round(HIGH/1024/1024/1024) || ' GB'
              else round(HIGH/1024/1024/1024/1024) || ' TB'
            end, 7, ' ') size_range,
       optimal,
       onepass,
       multipasses
     from
       (select decode(rownum,      1, 0,           low_optimal_size) low,
             decode(sum_forward, 0, max_high_size, high_optimal_size) high,
             optimal,
             onepass,
             multipasses
        from
          (select
                low_optimal_size,
                high_optimal_size+1 high_optimal_size,
                optimal_executions optimal,
                onepass_executions onepass,
                multipasses_executions multipasses,
                sum(total_executions)
                  over (order by high_optimal_size desc) sum_forward,
                sum(total_executions)
                  over (order by high_optimal_size) sum_backward,
                sum(total_executions)
                over (order by high_optimal_size rows 1 preceding) sum_with_prev,
                max(high_optimal_size) over () max_high_size
           from v\$sql_workarea_histogram)
        where (sum_forward != 0 or
              (sum_forward = 0 and sum_with_prev != 0))
              and sum_backward != 0)
    order by low;

!

    if [ $PGA_ADVICE -eq 1 ] ; then

      sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 1000
      set linesize 130

      select round(PGA_TARGET_FOR_ESTIMATE/1024/1024) estd_target,
             round(BYTES_PROCESSED/1024/1024) mbytes_process,
             round(ESTD_EXTRA_BYTES_RW/1024/1024) extra_mbytes_rw,
             ESTD_PGA_CACHE_HIT_PERCENTAGE cache_hit,
             ESTD_OVERALLOC_COUNT overalloc
      from v\$pga_target_advice
      order by 1;
!
    MIN_REQ='round(MIN_MEM) MIN_REQ,'

    fi
    else

    MIN_REQ=''

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"


      set pagesize 1000
      set linesize 130
      set feedback off

      col name format A50
      col VALUE format A20 JUS C
      col profile format A35

      connect $DBUSER

      select name profile, cnt,
             decode(total, 0, 0, round(cnt*100/total)) percentage
      from (select name, value cnt, (sum(value) over ()) total
      from v\$sysstat where name like 'workarea exec%');
!
    fi

    # tablespace info available
    if [ $SWA_ACTIVE_TABLESPACE -eq 1 ]; then
       TABLESPACE_SUM_SIZE=', round(sum(TEMPSEG_SIZE/1024/1024)) TSIZE'
       TABLESPACE_SIZE=', round(KTSSOSIZE/1024) TSIZE'
    else
       TABLESPACE_SUM_SIZE=' '
       TABLESPACE_SIZE=' '
    fi

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|Connected|rows selected"

        set pagesize 1000
        set linesize 180
        set feedback off
        col name format A50
        col value format A20

        connect $DBUSER

        select QESMMSGANM name,
              lpad(case
              when QESMMSGAUN = 0
              then case
              when QESMMSGAVL >= 10240
                    then round(QESMMSGAVL/1024) || ' MB'
              else QESMMSGAVL || ' KB'
              end
              when QESMMSGAUN = 1
                  then QESMMSGAVL || ' us'
              when QESMMSGAUN = 3
                  then round((QESMMSGAVL*QESMMSGAMU)/100) || ' %'
              else QESMMSGAVL || '   '
             end,20) VALUE
      from x\$qesmmsga;
!

    #
    # Detail for all workareas
    #
    if [ $OPTALL -eq 1 ]; then
      sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

        set pagesize 1000
        set linesize 180
        set feedback off
        col QCSID format 9999
        col MODULE format A30
        col SID format 9999
        col OPERATION format A21
        col OPID format 9999
        col ESIZE format 99999999
        col MIN_REQ format 99999999
        col OPT_REQ format 99999999
        col ONE_REQ format 99999999
        col IOSIZE format 99999999
        col WSIZE format 99999999
        col SQL_HASH format 99999999999
        col MEM format 99999999
        col TSIZE format 99999999
        col "MAX MEM" format 99999999
        col PASS format 99

        connect $DBUSER

        select /*+ all_rows ordered use_hash(swa) use_nl(s) */
                to_number(decode(QCSID,65535,NULL,QCSID)) qcsid,
                to_number(decode(SID, 65535, NULL, SID)) sid,
                module,
                swa.OPERATION_TYPE OPERATION,
                swa.OPERATION_ID OPID,
                round(swaa.ATIME/1000000) "TIME (s)",
                round(WA_SIZE) WSIZE, $MIN_REQ
                round(ONEPASS_MEM) ONE_REQ,
                round(OPTIMAL_MEM) OPT_REQ,
                round(EXP_SIZE) ESIZE,
                round(ACTUAL_MEM) MEM,
                round(MAX_MEM) "MAX MEM",
                PASSES PASS $TABLESPACE_SIZE
         from x\$qesmmiwt swaa, v\$sql_workarea swa, v\$sql s
         where swaa.WADDR = swa.WORKAREA_ADDRESS(+)
           and swa.ADDRESS = s.ADDRESS(+)
           and swa.HASH_VALUE = s.HASH_VALUE(+)
           and swa.child_number = s.child_number(+)
           and sid != userenv('sid')
         order by 1,5,2;

!
    fi

    if [ "$ORA_USE_HASH" = "" ]; then
      COLNM=sql_id
      COLNM_HEADER=sql_id
    else
      COLNM=hash_value
      COLNM_HEADER=sql_hash
    fi

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connecte            d|rows selected"

      set pagesize 1000
      set linesize 180
      set feedback off

      col QCSID format 9999
      col MODULE format A30
      col SID format 9999
      col OPERATION format A21
      col OPID format 9999
      col ESIZE format 99999999
      col MIN_REQ format 99999999
      col OPT_REQ format 99999999
      col ONE_REQ format 99999999
      col IOSIZE format 99999999
      col WSIZE format 99999999
      col SQL_HASH format 99999999999
      col MEM format 99999999
      col TSIZE format 99999999
      col "MAX MEM" format 99999999
      col PASS format 99

      connect $DBUSER

      select /*+ all_rows ordered use_hash(swa) use_nl(s) */
             to_number(decode(QCSID,65535,NULL,QCSID)) qcsid,
             MODULE, s.$COLNM $COLNM_HEADER,
             swa.WORKAREA_ADDRESS wa_addr,
             swaa.OPERATION_TYPE OPERATION,
             round(sum(WORK_AREA_SIZE)/1024) wsize,
             round(sum(EXPECTED_SIZE)/1024) esize,
             round(sum(ACTUAL_MEM_USED)/1024) mem,
             max(NUMBER_PASSES) pass $TABLESPACE_SUM_SIZE
      from v\$sql_workarea_active swaa, v\$sql_workarea swa, v\$sql s
      where swaa.WORKAREA_ADDRESS = swa.WORKAREA_ADDRESS(+)
        and swa.ADDRESS = s.ADDRESS(+)
        and swa.HASH_VALUE = s.HASH_VALUE(+)
        and swa.child_number = s.child_number(+)
        and sid != userenv('sid')
      group by QCSID, MODULE, s.$COLNM, swa.WORKAREA_ADDRESS,
               swaa.OPERATION_TYPE
      order by 1,2;
!
exit 0
fi

if [ "$1" = "cursors" ]; then
  if [ "$2" = "all" ]; then
    EXCLUDE=-1
    shift
  else
    EXCLUDE=0
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 100
    set tab off
    col address format A15
    col sql_hash format A13
    col sql_id format A16
    col exec format 9999
    col sql_text format A65 WORD_WRAP

    select /* BDAGEVIL */
     $COLNM || decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
     sql_text
    from v\$sql
    $WHERE sql_text like '%$2%'
          and sql_text not like '%BDAGEVIL%'
          and PARSING_USER_ID != $EXCLUDE;
!
exit 0
fi


if [ "$1" = "pgaadv" ]; then

  shift;

  SNAPSHOT=""
  MIN_WS=0
  OUTPUT_ADVICE_HIST_PERC="$ORA_TMP/pga_target_advice_histogram_perc.graph"
  OUTPUT_ADVICE_HIST_CNT="$ORA_TMP/pga_target_advice_histogram_cnt.graph"
  OUTPUT_ADVICE="$ORA_TMP/pga_target_advice.graph"
  while [ "$1" != "" ]; do
    if [ "$1" = "-s" ]; then
      if [ "$2" != "" -a "$2" != "-m" -a "$2" != "-o" ]; then
        SNAPSHOT=$2
        shift 2
      else
        SNAPSHOT="pga_target_advice"
        shift
      fi
      continue
    fi

    if [ "$1" = '-m' ]; then
      MIN_WS=$2
      shift 2
      continue
    fi

    if [ "$1" = '-o' ]; then
      OUTPUT_ADVICE_HIST_CNT="$2"_hist_cnt.graph
      OUTPUT_ADVICE_HIST_PERC="$2"_hist_perc.graph
      OUTPUT_ADVICE="$2".graph
      shift 2
      continue
    fi

    usage "Cannot read arguments for <pgaadv> command"
  done

  #
  # get the base data first
  #
  if [ "$SNAPSHOT" = "" ]; then
    sqlplus -s /NOLOG << ! | egrep '##|@@|#@' > $ORA_TMP/pgaadv$$

      connect $DBUSER

      drop table pga_target_advice_hist_temp;
      create table pga_target_advice_hist_temp
        as select  PGA_TARGET_FACTOR,
                   PGA_TARGET_FOR_ESTIMATE,
                   ESTD_OPTIMAL_EXECUTIONS,
                   ESTD_ONEPASS_EXECUTIONS,
                   ESTD_MULTIPASSES_EXECUTIONS,
                   ESTD_TOTAL_EXECUTIONS,
                   ESTD_OVERALLOC_COUNT,
                   IGNORED_WORKAREAS_COUNT
        from (select AH.PGA_TARGET_FOR_ESTIMATE,
                     AH.PGA_TARGET_FACTOR,
                  sum(ESTD_OPTIMAL_EXECUTIONS)     ESTD_OPTIMAL_EXECUTIONS,
                  sum(ESTD_ONEPASS_EXECUTIONS)     ESTD_ONEPASS_EXECUTIONS,
                  sum(ESTD_MULTIPASSES_EXECUTIONS) ESTD_MULTIPASSES_EXECUTIONS,
                  sum(ESTD_TOTAL_EXECUTIONS)       ESTD_TOTAL_EXECUTIONS,
                  sum(A.ESTD_OVERALLOC_COUNT)   ESTD_OVERALLOC_COUNT,
                  sum(IGNORED_WORKAREAS_COUNT)     IGNORED_WORKAREAS_COUNT,
                  max(sum(estd_optimal_executions))
                    over (order by AH.PGA_TARGET_FOR_ESTIMATE rows
                          between 0         preceding
                          and     unbounded following) max_opt_forward,
                  min(sum(estd_optimal_executions))
                    over (order by AH.PGA_TARGET_FOR_ESTIMATE rows
                          between 0         preceding
                          and     unbounded following) min_opt_forward,
                  first_value(sum(estd_optimal_executions))
                    over (order by AH.PGA_TARGET_FOR_ESTIMATE rows
                          2 preceding) min_opt_pred_1
            from v\$pga_target_advice_histogram ah,
                 v\$pga_target_advice a
            where AH.LOW_OPTIMAL_SIZE >= $MIN_WS * 1024
              and AH.PGA_TARGET_FOR_ESTIMATE = A.PGA_TARGET_FOR_ESTIMATE
            group by AH.PGA_TARGET_FOR_ESTIMATE, AH.PGA_TARGET_FACTOR)
          where max_opt_forward != min_opt_forward
             or min_opt_pred_1 != max_opt_forward;

      drop table pga_target_advice_temp;
      create table pga_target_advice_temp
        as select PGA_TARGET_FOR_ESTIMATE,
                  PGA_TARGET_FACTOR,
                  BYTES_PROCESSED,
                  ESTD_EXTRA_BYTES_RW,
                  ESTD_OVERALLOC_COUNT
           from
             (select  PGA_TARGET_FOR_ESTIMATE,
                      PGA_TARGET_FACTOR,
                      BYTES_PROCESSED,
                      ESTD_EXTRA_BYTES_RW,
                      ESTD_OVERALLOC_COUNT,
                      max(ESTD_EXTRA_BYTES_RW)
                        over (order by  PGA_TARGET_FACTOR rows
                              between 0         preceding
                              and     unbounded following) max_rw_forward,
                      min(ESTD_EXTRA_BYTES_RW)
                        over (order by PGA_TARGET_FACTOR rows
                              between 0         preceding
                              and     unbounded following) min_rw_forward,
                     first_value(ESTD_EXTRA_BYTES_RW)
                       over (order by PGA_TARGET_FACTOR rows
                             2 preceding) min_rw_pred_1
            from v\$pga_target_advice)
         where max_rw_forward != min_rw_forward
            or min_rw_pred_1 != max_rw_forward;


      select '@@'||(s2.qesmmsgavl)||'@@' value
      from x\$qesmmsga s2
      where s2.qesmmsganm like 'BUG count%';

      select '##'||max(IGNORED_WORKAREAS_COUNT)||'##' value
      from pga_target_advice_hist_temp;

      select '#@'||round(PGA_TARGET_FOR_ESTIMATE/1024/1024)||'#@' value
      from pga_target_advice_temp
      where PGA_TARGET_FACTOR = 1;

      exit;
!
  else
    sqlplus -s /NOLOG << ! | egrep '##|@@|#@' > $ORA_TMP/pgaadv$$

      connect $DBUSER

      drop table pga_target_advice_hist_temp;
      create table pga_target_advice_hist_temp
        as select  PGA_TARGET_FOR_ESTIMATE,
                   PGA_TARGET_FACTOR,
                   ESTD_OPTIMAL_EXECUTIONS,
                   ESTD_ONEPASS_EXECUTIONS,
                   ESTD_MULTIPASSES_EXECUTIONS,
                   ESTD_TOTAL_EXECUTIONS,
                   ESTD_OVERALLOC_COUNT,
                   IGNORED_WORKAREAS_COUNT
        from (select S2.PGA_TARGET_FOR_ESTIMATE,
                     S2.PGA_TARGET_FACTOR,
                  sum(S2.ESTD_OPTIMAL_EXECUTIONS -
                      S1.ESTD_OPTIMAL_EXECUTIONS) ESTD_OPTIMAL_EXECUTIONS,
                  sum(S2.ESTD_ONEPASS_EXECUTIONS -
                      S1.ESTD_ONEPASS_EXECUTIONS) ESTD_ONEPASS_EXECUTIONS,
                  sum(S2.ESTD_MULTIPASSES_EXECUTIONS -
                     S1.ESTD_MULTIPASSES_EXECUTIONS) ESTD_MULTIPASSES_EXECUTIONS,
                  sum(S2.ESTD_TOTAL_EXECUTIONS -
                      S1.ESTD_TOTAL_EXECUTIONS) ESTD_TOTAL_EXECUTIONS,
                  sum(A.ESTD_OVERALLOC_COUNT -
                      S1.ESTD_OVERALLOC_COUNT) ESTD_OVERALLOC_COUNT,
                  sum(S2.IGNORED_WORKAREAS_COUNT -
                      S1.IGNORED_WORKAREAS_COUNT) IGNORED_WORKAREAS_COUNT,
                max(sum(s2.estd_optimal_executions - s1.estd_optimal_executions))
                    over (order by s2.PGA_TARGET_FOR_ESTIMATE rows
                          between 0         preceding
                          and     unbounded following) max_opt_forward,
                min(sum(s2.estd_optimal_executions - s1.estd_optimal_executions))
                    over (order by s2.PGA_TARGET_FOR_ESTIMATE rows
                          between 0         preceding
                          and     unbounded following) min_opt_forward,
                first_value(sum(s2.estd_optimal_executions -
                                s1.estd_optimal_executions))
                    over (order by s2.PGA_TARGET_FOR_ESTIMATE rows
                          2 preceding) min_opt_pred_1
            from v\$pga_target_advice_histogram s2,
                 ${SNAPSHOT}_hist_snap s1,
                 v\$pga_target_advice a
            where S2.LOW_OPTIMAL_SIZE >= $MIN_WS * 1024
              and S2.PGA_TARGET_FOR_ESTIMATE = A.PGA_TARGET_FOR_ESTIMATE
              and S2.PGA_TARGET_FOR_ESTIMATE = S1.PGA_TARGET_FOR_ESTIMATE
              and s1.LOW_OPTIMAL_SIZE = s2.LOW_OPTIMAL_SIZE
              and s1.HIGH_OPTIMAL_SIZE = s2.HIGH_OPTIMAL_SIZE
            group by S2.PGA_TARGET_FOR_ESTIMATE, S2.PGA_TARGET_FACTOR)
         where max_opt_forward != min_opt_forward
            or min_opt_pred_1 != max_opt_forward;

      drop table pga_target_advice_temp;
      create table pga_target_advice_temp
        as select PGA_TARGET_FOR_ESTIMATE,
                  PGA_TARGET_FACTOR,
                  BYTES_PROCESSED,
                  ESTD_EXTRA_BYTES_RW,
                  ESTD_OVERALLOC_COUNT
           from
              (select  S2.PGA_TARGET_FOR_ESTIMATE,
                       S2.PGA_TARGET_FACTOR,
                       (S2.BYTES_PROCESSED -
                        S1.BYTES_PROCESSED) BYTES_PROCESSED,
                       (S2.ESTD_EXTRA_BYTES_RW -
                        S1.ESTD_EXTRA_BYTES_RW) ESTD_EXTRA_BYTES_RW,
                     (S2.ESTD_OVERALLOC_COUNT -
                      S1.ESTD_OVERALLOC_COUNT) ESTD_OVERALLOC_COUNT,
                        max(S2.ESTD_EXTRA_BYTES_RW - S1.ESTD_EXTRA_BYTES_RW)
                          over (order by  S1.PGA_TARGET_FACTOR rows
                                between 0         preceding
                                and     unbounded following) max_rw_forward,
                        min(S2.ESTD_EXTRA_BYTES_RW - S1.ESTD_EXTRA_BYTES_RW)
                          over (order by S1.PGA_TARGET_FACTOR rows
                                between 0         preceding
                                and     unbounded following) min_rw_forward,
                       first_value(S2.ESTD_EXTRA_BYTES_RW-S1.ESTD_EXTRA_BYTES_RW)
                         over (order by S1.PGA_TARGET_FACTOR rows
                               2 preceding) min_rw_pred_1
              from  v\$pga_target_advice S2,
                    ${SNAPSHOT}_snap s1
              where S2.PGA_TARGET_FOR_ESTIMATE = S1.PGA_TARGET_FOR_ESTIMATE)
         where max_rw_forward != min_rw_forward
               or min_rw_pred_1 != max_rw_forward;

      select '@@'||(s2.qesmmsgavl - s1.qesmmsgavl)||'@@' value
      from x\$qesmmsga s2, ${SNAPSHOT}_bug s1
      where s2.qesmmsganm like 'BUG count%';

      select '##'||max(IGNORED_WORKAREAS_COUNT)||'##' value
      from pga_target_advice_hist_temp;

      select '#@'||round(PGA_TARGET_FOR_ESTIMATE/1024/1024)||'#@' value
      from pga_target_advice_temp
      where PGA_TARGET_FACTOR = 1;

      exit;
!

  fi


  NB_IGNORED=`cat $ORA_TMP/pgaadv$$ | grep '##' | sed -e 's/^##\(.*\)##$/\1/g'`
  NB_BUG=`cat $ORA_TMP/pgaadv$$ | grep '@@' | sed -e 's/^@@\(.*\)@@$/\1/g'`
  CURRENT=`cat $ORA_TMP/pgaadv$$ | grep '#@' | sed -e 's/^#@\(.*\)#@$/\1/g'`
  rm -f $ORA_TMP/pgaadv$$

  TITLE="TitleText: PGA Advice Hist % (cur=${CURRENT}MB min=$MIN_WS"

  if [ $NB_IGNORED -ne 0 ]; then
    TITLE="$TITLE, ignored=$NB_IGNORED"
  fi

  if [ $NB_BUG -ne 0 ]; then
    TITLE="$TITLE, bugs=$NB_BUG"
  fi

  TITLE="${TITLE})"

  echo $TITLE > $OUTPUT_ADVICE_HIST_PERC
  echo "XUnitText: PGA_AGGREGATE_TARGET FACTOR" >> $OUTPUT_ADVICE_HIST_PERC
  echo "YUnitText: Percentage" >> $OUTPUT_ADVICE_HIST_PERC
  echo "XLowLimit: 10\n" >> $OUTPUT_ADVICE_HIST_PERC

  sqlplus -s /NOLOG << ! | grep '##' | sed -e 's/^##\(.*\)$/\1/g' >> $OUTPUT_ADVICE_HIST_PERC

      connect $DBUSER

      set pagesize 6000
      set linesize 100
      set tab off

      select '##"Optimal"' value from dual
        union all
      select '##'||PGA_TARGET_FACTOR|| ' ' ||
             round(((ESTD_OPTIMAL_EXECUTIONS*100)/ESTD_TOTAL_EXECUTIONS))
      from
        (select   PGA_TARGET_FACTOR, ESTD_OPTIMAL_EXECUTIONS,
                  ESTD_TOTAL_EXECUTIONS
         from     pga_target_advice_hist_temp
         order by PGA_TARGET_FOR_ESTIMATE)
        union all
      select '##' from dual
        union all
      select '##"One-pass"' from dual
        union all
      select '##'||PGA_TARGET_FACTOR|| ' ' ||
             round(((ESTD_ONEPASS_EXECUTIONS*100)/ESTD_TOTAL_EXECUTIONS))
      from
        (select   PGA_TARGET_FACTOR, ESTD_ONEPASS_EXECUTIONS,
                  ESTD_TOTAL_EXECUTIONS
         from     pga_target_advice_hist_temp
         order by PGA_TARGET_FACTOR)
        union all
      select '##' from dual
        union all
      select '##"Multi-pass"' from dual
        union all
      select '##'||PGA_TARGET_FACTOR|| ' ' ||
             round(((ESTD_MULTIPASSES_EXECUTIONS*100)/ESTD_TOTAL_EXECUTIONS))
      from
        (select   PGA_TARGET_FACTOR, ESTD_MULTIPASSES_EXECUTIONS,
                  ESTD_TOTAL_EXECUTIONS
         from     pga_target_advice_hist_temp
         order by PGA_TARGET_FACTOR)
        union all
      select '##' from dual
        union all
      select '##"Overalloc"' from dual
        union all
      select '##0 0' from dual
        union all
      select '##0 100' from dual
        union all
      select '##'||nvl(max(PGA_TARGET_FACTOR), 0)||' 100'
        from pga_target_advice_hist_temp
        where ESTD_OVERALLOC_COUNT <>0
        union all
      select '##'||nvl(max(PGA_TARGET_FACTOR), 0)||' 0'
        from pga_target_advice_hist_temp
        where ESTD_OVERALLOC_COUNT<>0;
!

  TITLE="TitleText: PGA Advice Hist Count (cur=${CURRENT}MB min=$MIN_WS"

  if [ $NB_IGNORED -ne 0 ]; then
    TITLE="$TITLE, ignored=$NB_IGNORED"
  fi

  if [ $NB_BUG -ne 0 ]; then
    TITLE="$TITLE, bugs=$NB_BUG"
  fi

  TITLE="${TITLE})"

  echo $TITLE > $OUTPUT_ADVICE_HIST_CNT
  echo "XUnitText: PGA_AGGREGATE_TARGET FACTOR" >> $OUTPUT_ADVICE_HIST_CNT
  echo "YUnitText: Count" >> $OUTPUT_ADVICE_HIST_CNT
  echo "XLowLimit: 10\n" >> $OUTPUT_ADVICE_HIST_CNT

  sqlplus -s /NOLOG << ! | grep '##' | sed -e 's/^##\(.*\)$/\1/g' >> $OUTPUT_ADVICE_HIST_CNT

      connect $DBUSER

      set pagesize 6000
      set linesize 100
      set tab off

      select '##"Optimal"' value from dual
        union all
      select '##'||PGA_TARGET_FACTOR|| ' ' ||ESTD_OPTIMAL_EXECUTIONS
      from
        (select   PGA_TARGET_FACTOR, ESTD_OPTIMAL_EXECUTIONS,
                  ESTD_TOTAL_EXECUTIONS
         from     pga_target_advice_hist_temp
         order by PGA_TARGET_FOR_ESTIMATE)
        union all
      select '##' from dual
        union all
      select '##"One-pass"' from dual
        union all
      select '##'||PGA_TARGET_FACTOR|| ' ' ||ESTD_ONEPASS_EXECUTIONS
      from
        (select   PGA_TARGET_FACTOR, ESTD_ONEPASS_EXECUTIONS,
                  ESTD_TOTAL_EXECUTIONS
         from     pga_target_advice_hist_temp
         order by PGA_TARGET_FACTOR)
        union all
      select '##' from dual
        union all
      select '##"Multi-pass"' from dual
        union all
      select '##'||PGA_TARGET_FACTOR|| ' ' ||ESTD_MULTIPASSES_EXECUTIONS
      from
        (select   PGA_TARGET_FACTOR, ESTD_MULTIPASSES_EXECUTIONS,
                  ESTD_TOTAL_EXECUTIONS
         from     pga_target_advice_hist_temp
         order by PGA_TARGET_FACTOR)
        union all
      select '##' from dual
        union all
      select '##"Overalloc"' from dual
        union all
      select '##0 0' from dual
        union all
      select '##0 100' from dual
        union all
      select '##'||nvl(max(PGA_TARGET_FACTOR), 0)||' 100'
        from pga_target_advice_hist_temp
        where ESTD_OVERALLOC_COUNT <>0
        union all
      select '##'||nvl(max(PGA_TARGET_FACTOR), 0)||' 0'
        from pga_target_advice_hist_temp
        where ESTD_OVERALLOC_COUNT<>0;
!

  echo "TitleText: PGA Advice (cur=${CURRENT}MB)" > $OUTPUT_ADVICE
  echo "XUnitText: PGA_AGGREGATE_TARGET FACTOR" >> $OUTPUT_ADVICE
  echo "YUnitText: Cache hit percentage" >> $OUTPUT_ADVICE

  sqlplus -s /NOLOG << ! | grep '##' | sed -e 's/^##\(.*\)$/\1/g' >> $OUTPUT_ADVICE

      connect $DBUSER

      set pagesize 6000
      set linesize 100
      set tab off

      select '##"Cache hit %"' value from dual
        union all
      select *
        from (select '##'||PGA_TARGET_FACTOR|| ' ' ||
               round((BYTES_PROCESSED*100)/(BYTES_PROCESSED+ESTD_EXTRA_BYTES_RW),2)
             from pga_target_advice_temp
            order by PGA_TARGET_FACTOR);
!

  if [ "$OUTPUT_ADVICE_HIST_CNT" = "$ORA_TMP/pga_target_advice_histogram_cnt.graph" ]; then
    mxgraph $OUTPUT_ADVICE_HIST_PERC &
    mxgraph $OUTPUT_ADVICE_HIST_CNT &
    mxgraph $OUTPUT_ADVICE &
    echo
  fi
  echo "\nGraph produced in $OUTPUT_ADVICE_HIST_CNT, $OUTPUT_ADVICE_HIST_PERC and $OUTPUT_ADVICE\n"
exit 0
fi

if [ "$1" = "pgasnap" ]; then

  if [ "$2" != "" ]; then
    SNAPSHOT=$2
  else
    SNAPSHOT="pga_target_advice"
  fi

  sqlplus -s /NOLOG << ! > /dev/null 2>&1

      connect $DBUSER

      drop table ${SNAPSHOT}_hist_snap;
      create table ${SNAPSHOT}_hist_snap
        as select AH.PGA_TARGET_FOR_ESTIMATE,
                  AH.PGA_TARGET_FACTOR,
                  AH.LOW_OPTIMAL_SIZE,
                  AH.HIGH_OPTIMAL_SIZE,
                  AH.ESTD_OPTIMAL_EXECUTIONS,
                  AH.ESTD_ONEPASS_EXECUTIONS,
                  AH.ESTD_MULTIPASSES_EXECUTIONS,
                  AH.ESTD_TOTAL_EXECUTIONS,
                  AH.IGNORED_WORKAREAS_COUNT,
                  A.ESTD_OVERALLOC_COUNT
           from v\$pga_target_advice_histogram ah,
                v\$pga_target_advice a
           where A.PGA_TARGET_FOR_ESTIMATE = AH.PGA_TARGET_FOR_ESTIMATE;

      drop table ${SNAPSHOT}_snap;
      create table ${SNAPSHOT}_snap
        as select A.PGA_TARGET_FOR_ESTIMATE, A.PGA_TARGET_FACTOR,
                  A.BYTES_PROCESSED, A.ESTD_EXTRA_BYTES_RW,
                  A.ESTD_OVERALLOC_COUNT
           from v\$pga_target_advice a;

      drop table ${SNAPSHOT}_bug;
      create table ${SNAPSHOT}_bug
        as  select qesmmsgavl
        from x\$qesmmsga
        where qesmmsganm like 'BUG count%';

      exit;
!

exit 0
fi

if [ "$1" = "sgaadv" ]; then

  shift;

  SNAPSHOT=""
  OUTPUT_ADVICE_BC="$ORA_TMP/bc.graph"
  OUTPUT_ADVICE_SP="$ORA_TMP/sp.graph"

  while [ "$1" != "" ]; do
    if [ "$1" = "-s" ]; then
      if [ "$2" != "" -a "$2" != "-m" -a "$2" != "-o" ]; then
        SNAPSHOT=$2
        shift 2
      else
        SNAPSHOT="sga_advice"
        shift
      fi
      continue
    fi

    if [ "$1" = '-o' ]; then
      OUTPUT_ADVICE_BC="$2"_bc.graph
      OUTPUT_ADVICE_SP="$2"_sp.graph
      shift 2
      continue
    fi

    usage "Cannot read arguments for <sgaadv> command"
  done

  #
  # get the base data first
  #
  if [ "$SNAPSHOT" = "" ]; then
    sqlplus -s /NOLOG << ! | egrep '##|@@' > $ORA_TMP/sgaadv$$

      connect $DBUSER

      drop table bc_advice_temp;
      create table bc_advice_temp
        as select  SIZE_FOR_ESTIMATE,
                   SIZE_FACTOR,
                   ESTD_PHYSICAL_READS
        from  v\$db_cache_advice BC
        where NAME = 'DEFAULT';

      drop table sp_advice_temp;
      create table sp_advice_temp
        as select  SHARED_POOL_SIZE_FOR_ESTIMATE,
                   SHARED_POOL_SIZE_FACTOR,
                   ESTD_LC_TIME_SAVED
            from v\$shared_pool_advice SP;

      select '@@'||(value/1024/1024)||'@@' value
      from v\$parameter
      where NAME='db_cache_size';

      select '##'||(value/1024/1024)||'##' value
      from v\$parameter
      where NAME='shared_pool_size';

      exit;
!
  else
    sqlplus -s /NOLOG << ! | egrep '##|@@' > $ORA_TMP/sgaadv$$

      connect $DBUSER

      drop table bc_advice_temp;
      create table bc_advice_temp
        as select  SIZE_FOR_ESTIMATE,
                   SIZE_FACTOR,
                   ESTD_PHYSICAL_READS
        from (select BC.SIZE_FOR_ESTIMATE,
                     BC.SIZE_FACTOR,
                     (BC.ESTD_PHYSICAL_READS -
                      SN.ESTD_PHYSICAL_READS) ESTD_PHYSICAL_READS
              from v\$db_cache_advice BC,
                   sga_advice_db_snap SN
              where BC.SIZE_FOR_ESTIMATE = SN.SIZE_FOR_ESTIMATE
                and NAME = 'DEFAULT');

      drop table sp_advice_temp;
      create table sp_advice_temp
        as select  SHARED_POOL_SIZE_FOR_ESTIMATE,
                   SHARED_POOL_SIZE_FACTOR,
                   ESTD_LC_TIME_SAVED
        from (select SP.SHARED_POOL_SIZE_FOR_ESTIMATE,
                     SP.SHARED_POOL_SIZE_FACTOR,
                     (SP.ESTD_LC_TIME_SAVED -
                      SN.ESTD_LC_TIME_SAVED) ESTD_LC_TIME_SAVED
              from v\$shared_pool_advice SP,
                   sga_advice_sp_snap SN
              where SP.SHARED_POOL_SIZE_FOR_ESTIMATE =
                    SN.SHARED_POOL_SIZE_FOR_ESTIMATE);

      select '@@'||round(value/1024/1024)||'@@' value
      from v\$parameter
      where NAME='db_cache_size';

      select '##'||round(value/1024/1024)||'##' value
      from v\$parameter
      where NAME='shared_pool_size';

      exit;
!

  fi


  SPSIZE=`cat $ORA_TMP/sgaadv$$ | grep '##' | sed -e 's/^##\(.*\)##$/\1/g'`
  BCSIZE=`cat $ORA_TMP/sgaadv$$ | grep '@@' | sed -e 's/^@@\(.*\)@@$/\1/g'`
  rm -f $ORA_TMP/sgaadv$$

  TITLE="TitleText: Buffer Cache Advice (cur=${BCSIZE}MB)"

  echo $TITLE > $OUTPUT_ADVICE_BC
  echo "XUnitText: BC_SIZE_FACTOR" >> $OUTPUT_ADVICE_BC
  echo "YUnitText: Physical Reads" >> $OUTPUT_ADVICE_BC

  sqlplus -s /NOLOG << ! | grep '##' | sed -e 's/^##\(.*\)$/\1/g' >> $OUTPUT_ADVICE_BC

      connect $DBUSER

      set pagesize 6000
      set linesize 100
      set tab off

      select '##"Size Factor"' value from dual
        union all
      select '##'||SIZE_FACTOR|| ' ' || ESTD_PHYSICAL_READS
      from
        (select *
         from bc_advice_temp
         order by size_factor);
!

  TITLE="TitleText: Shared Pool Advice (cur=${SPSIZE}MB)"

  echo $TITLE > $OUTPUT_ADVICE_SP
  echo "XUnitText: SP_SIZE_FACTOR" >> $OUTPUT_ADVICE_SP
  echo "YUnitText: Time Saved (ms)" >> $OUTPUT_ADVICE_SP

  sqlplus -s /NOLOG << ! | grep '##' | sed -e 's/^##\(.*\)$/\1/g' >> $OUTPUT_ADVICE_SP

      connect $DBUSER

      set pagesize 6000
      set linesize 100
      set tab off

      select '##"Size Factor"' value from dual
        union all
      select '##'||SHARED_POOL_SIZE_FACTOR|| ' ' || ESTD_LC_TIME_SAVED
      from
        (select *
         from sp_advice_temp
         order by SHARED_POOL_SIZE_FACTOR);
!

  if [ "$OUTPUT_ADVICE_SP" = "$ORA_TMP/sp.graph" ]; then
    mxgraph $OUTPUT_ADVICE_BC &
    mxgraph $OUTPUT_ADVICE_SP &
    echo
  fi
  echo "\nGraph produced in $OUTPUT_ADVICE_SP and $OUTPUT_ADVICE_BC\n"
exit 0
fi


if [ "$1" = "sgasnap" ]; then

  if [ "$2" != "" ]; then
    SNAPSHOT=$2
  else
    SNAPSHOT="sga_advice"
  fi

  sqlplus -s /NOLOG << ! > /dev/null 2>&1

      connect $DBUSER

      drop table ${SNAPSHOT}_db_snap;
      create table ${SNAPSHOT}_db_snap
        as select SIZE_FOR_ESTIMATE,
                  SIZE_FACTOR,
                  ESTD_PHYSICAL_READ_FACTOR,
                  ESTD_PHYSICAL_READS
           from v\$db_cache_advice
           where NAME='DEFAULT';

      drop table ${SNAPSHOT}_sp_snap;
      create table ${SNAPSHOT}_sp_snap
        as select SHARED_POOL_SIZE_FOR_ESTIMATE,
                  SHARED_POOL_SIZE_FACTOR,
                  ESTD_LC_TIME_SAVED
           from v\$shared_pool_advice;

      exit;
!

exit 0
fi


if [ "$1" = "pgaadvhist" ]; then

  if [ "$2" = "-f" ]; then
    if [ "$4" != "" ]; then
      FACTOR=" where PGA_TARGET_FACTOR between $3 and $4 "
    else
      FACTOR=" where PGA_TARGET_FACTOR = $3 "
    fi
  else
    FACTOR=""
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected" > $ORA_TMP/pgaadvhist$$
    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select PGA_TARGET_FACTOR
    from v\$pga_target_advice  $FACTOR
    order by 1;
!

  cat $ORA_TMP/pgaadvhist$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    echo
    echo "       -----------------------------------"
    echo "           workarea advice for factor $1"
    echo "       -----------------------------------"
    echo
    sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
      connect $DBUSER

      set pagesize 0
      set tab      off
      set linesize 140
      set echo off
      repfooter off;
      set timing off veri off space 1 flush on pause off termout on numwidth 10;

      col optimal format 9999999999
      col onepass format 9999999999
      col multipasses format 9999999999
      select lpad(case
              when LOW < 1024*1024
              then round(LOW/1024) || ' KB'
              when LOW < 1024*1024*1024
              then round(LOW/1024/1024) || ' MB'
              when LOW < 1024*1024*1024*1024
              then round(LOW/1024/1024/1024) || ' GB'
              else round(LOW/1024/1024/1024/1024) || ' TB'
            end, 6, ' ') || ' ->' ||
       lpad(case
              when HIGH < 1024*1024
              then round(HIGH/1024) || ' KB'
              when HIGH < 1024*1024*1024
              then round(HIGH/1024/1024) || ' MB'
              when HIGH < 1024*1024*1024*1024
              then round(HIGH/1024/1024/1024) || ' GB'
              else round(HIGH/1024/1024/1024/1024) || ' TB'
            end, 7, ' ') size_range,
       optimal,
       onepass,
       multipasses
     from
       (select decode(rownum,      1, 0,           low_optimal_size) low,
             decode(sum_forward, 0, max_high_size, high_optimal_size) high,
             optimal,
             onepass,
             multipasses
        from
          (select
                low_optimal_size,
                high_optimal_size+1 high_optimal_size,
                estd_optimal_executions optimal,
                estd_onepass_executions onepass,
                estd_multipasses_executions multipasses,
                sum(estd_total_executions)
                  over (order by high_optimal_size desc) sum_forward,
                sum(estd_total_executions)
                  over (order by high_optimal_size) sum_backward,
                sum(estd_total_executions)
                  over (order by high_optimal_size rows 1 preceding)
                                                          sum_with_prev,
                max(high_optimal_size) over () max_high_size
           from v\$pga_target_advice_histogram
           where PGA_TARGET_FACTOR = $1)
        where (sum_forward != 0 or
              (sum_forward = 0 and sum_with_prev != 0))
              and sum_backward != 0)
    order by low;
!

  done

  rm -f $ORA_TMP/pgaadvhist$$
exit 0
fi


if [ "$1" = "sessions" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 180
    col username format A10
    col pid format A10
    col cl_pid format A10
    col sql_hash format A15
    col sql_id format A18
    col machine format A18
    col type format A10
    col server format A10
    col program format A40

    select s.sid, s.serial#, s.PROCESS cl_pid, p.spid pid, s.username,
           s.type, s.server, s.machine, s.PROGRAM, $COLNM $COLNM_HEADER
    from v\$session s, v\$process p
    where s.PADDR = p.addr;
!
exit 0
fi

if [ "$1" = "hold_txlock" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 180
    select * from v\$lock where type='TX' and lmode>0;
!
exit 0
fi

if [ "$1" = "tab_pk_fk" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  if [ "$2" = "" ]; then
    usage "Schema name is missing"
  fi

    connect $DBUSER

    set pagesize 6000
    set linesize 130

    col PK_TABLE_NAME    format a31 justify c trunc
    col PK_COLLUMN_NAME  format a31 justify c trunc
    col FK_TABLE_NAME    format a31 justify c trunc
    col FK_COLLUMN_NAME  format a31
    break -
      on PK_TABLE_NAME -
      on PK_COLLUMN_NAME -
      on FK_TABLE_NAME -

    select b.table_name  PK_TABLE_NAME,
                       b.column_name PK_COLLUMN_NAME,
                       a.table_name  FK_TABLE_NAME,
                       a.column_name FK_COLLUMN_NAME
                          from (select c.constraint_name,
                                       cc.table_name,
                                       cc.column_name,
                                       c.r_constraint_name
                                  from dba_constraints c, dba_cons_columns cc
                                 WHERE c.constraint_type = 'R'
                                   and c.constraint_name = cc.constraint_name
                                   and c.owner = upper('$2')
                                   and cc.owner = upper('$2')) a,
                               (select distinct c.r_constraint_name, cc.table_name, cc.column_name
                                  from dba_constraints c, dba_cons_columns cc
                                 WHERE c.constraint_type = 'R'
                                   and c.r_constraint_name = cc.constraint_name
                                   and c.owner = upper('$2')
                                   and cc.owner = upper('$2')) b
                         where a.r_constraint_name = b.r_constraint_name;
!
exit 0
fi
if [ "$1" = "wait_txlock" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 180
    select * from v\$lock where type='TX' and request>0;
!
exit 0
fi

if [ "$1" = "block_session" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 180
    select SID,TYPE,ID1,ID2,LMODE,REQUEST,CTIME from v\$lock l
                        where l.type = 'TX' or l.type = 'TM'
                union
                select /*+ ordered use_nl(l), use_nl(r) +*/
                        s.sid, r.ksqrsidt,
                        r.ksqrsid1, r.ksqrsid2, l.lmode, l.request,l.ctime
                from v\$_lock l,x$ksqrs r , v\$transaction tx , v\$session s
                where l.raddr=r.addr
                        and tx.addr = l.saddr
                        and tx.ses_addr = s.saddr
                        and s.saddr = tx.ses_addr
                        and ( r.KSQRSIDT = 'TM' or r.KSQRSIDT = 'TX')
                        order by 1,2;


                select blocking_session, sid, serial#, wait_class, seconds_in_wait from v\$session
                        where blocking_session is not NULL order by blocking_session;

                        SELECT DECODE(request,0,'Holder: ','Waiter: ')||sid sess,
                        id1, id2, lmode, request, type
                        FROM v\$LOCK
                        WHERE (id1, id2, type) IN
                        (SELECT id1, id2, type FROM v\$LOCK WHERE request>0)
                        ORDER BY id1, request;
!
exit 0
fi

if [ "$1" = "sql_use_temp_segment" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 180
    SELECT a.username, a.sid, a.serial#, a.osuser, b.tablespace, b.blocks, c.sql_text
                        FROM v\$session a, v\$tempseg_usage b, v\$sqlarea c
                WHERE a.saddr = b.session_addr
                        AND c.address= a.sql_address
                        AND c.hash_value = a.sql_hash_value
                ORDER BY b.tablespace, b.blocks;
!
exit 0
fi

if [ "$1" = "wait_object" ]; then
  if [ "$2" = "" ]; then
    usage "SID is missing"
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 180
    col OWNER format a20
    col OBJECT_NAME format a30
    select o.OWNER, o.OBJECT_NAME, o.OBJECT_TYPE, o.STATUS, s.ROW_WAIT_BLOCK#, s.ROW_WAIT_ROW#
      from v\$session s, dba_objects o
     where s.ROW_WAIT_OBJ# = o.object_id and sid=$2;
!
exit 0
fi

if [ "$1" = "rowid" ]; then
  if [ "$2" = "" ]; then
    usage "rowid is missing"
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM="decode(sql_hash_value, 0, NULL, sql_hash_value)"
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|PL/SQL procedure successfully completed."

    connect $DBUSER
            set serveroutput on
                        declare
                                v_block_id number;
                                v_file_id number;
                                v_object_id number;
                                v_extent_id number;
                                v_file_name varchar2(513);
                                v_object_name varchar2(30);
                                v_object_type varchar2(19);
                                v_owner varchar2(30);
                        begin
                                select dbms_rowid.ROWID_BLOCK_NUMBER('$2'),
                                       dbms_rowid.ROWID_RELATIVE_FNO('$2'),
                                       dbms_rowid.ROWID_OBJECT('$2')
                                 into v_block_id,v_file_id,v_object_id
                                from dual;

                                select owner,object_name,OBJECT_TYPE
                                  into v_owner,v_object_name,v_object_type
                                from dba_objects
                                where data_object_id=v_object_id;

                                select extent_id into v_extent_id
                                 from dba_extents
                                where owner=v_owner
                                        and segment_name=v_object_name
                                        and file_id=v_file_id
                                        and v_block_id between block_id and block_id + blocks-1;

                                select FILE_NAME into v_file_name
                                 from dba_data_files
                                 where file_id=v_file_id;

                                dbms_output.put_line('         rowid: '||'$2');
                                dbms_output.put_line('       file_id: '||v_file_id);
                                dbms_output.put_line('     file_name: '||v_file_name);
                                dbms_output.put_line('      block_id: '||v_block_id);
                                dbms_output.put_line('data_object_id: '||v_object_id);
                                dbms_output.put_line('         owner: '||v_owner);
                                dbms_output.put_line('   object_name: '||v_object_name);
                                dbms_output.put_line('     extent_id: '||v_extent_id);
                        end;
                        /
!
exit 0
fi

if [ "$1" = "kill" ]; then

    COLNM=sql_id
    COLNM_HEADER=sql_id

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    spool /tmp/kill.tmp
    connect $DBUSER
    set pagesize 0
    SET NEWPAGE 0
    SET FEEDBACK OFF
    set linesize 180
    SET HEADING OFF
    col username format A20
    col pid format A10
    col cl_pid format A10
    col sql_hash format A15
    col sql_id format A18
    select ' alter system kill session ''' || s.sid ||',' ||  s.serial# || ''';'
           -- , s.PROCESS cl_pid, p.spid pid, s.username,
           --s.type, s.server, s.PROGRAM, $COLNM $COLNM_HEADER
    from v\$session s, v\$process p
    where s.PADDR = p.addr and s.username=upper('$2');
!
sqlplus -s / as sysdba <<!
@/tmp/kill.tmp
!
exit 0
fi


if [ "$1" = "degree" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 100
    col degree format A13
    col instances format A13
    col table_name format A30
    col index_name format A30
      col SID format 99999
      col QCSID format 99999
      col PID format 9999
      col SPID format 9999999
      col Inst format 999999
      col Group format 999999
      col Set format 999999
      col Degree format 999999
      col "Req Degree" format 999999
      col "Wait Event" format A30

    select table_name, degree, instances from user_tables order by 1;
    select index_name, degree, instances from user_indexes order by 1;

      select px.qcsid, px.SID "SID", p.PID, p.SPID "SPID", px.INST_ID "Inst",
             px.SERVER_GROUP "Group", px.SERVER_SET "Set",
             px.DEGREE "Degree", px.REQ_DEGREE "Req Degree"
      from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p
      where s.sid (+) = px.sid
        and s.inst_id (+) = px.inst_id
        and s.paddr = p.addr (+)
        and s.inst_id = p.inst_id (+)
      ORDER BY decode(px.QCINST_ID, NULL, px.INST_ID, px.QCINST_ID), px.QCSID,
               decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
               px.SERVER_SET, px.INST_ID;

!
exit 0
fi

if [ "$1" = "colstats" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 1000
    set linesize 120
    col table_name format A34
    col column_name format A40
    set tab      off

    select table_name, column_name, num_distinct, num_nulls
    from user_tab_columns
    order by 1, 2;
!
exit 0
fi

if [ "$1" = "tabstats" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 90
    col table_name format A34
    col column_name format A34
    col Size format A10
    col avg_row_len format A10
    set tab      off

    select table_name, num_rows Cardinality,
           lpad(decode(avg_row_len, NULL, '?', avg_row_len),10, ' ')avg_row_len,
           lpad(decode(BLOCKS, NULL, '?', round(BLOCKS*8/1024)+1) || ' MB',
                       10, ' ') "Size", degree
    from user_tables order by 1;
!
exit 0
fi

if [ "$1" = "get_obj" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 140

    col OWNER format A30
    col OBJECT_NAME format A30
    col created format A19

    select OWNER, OBJECT_NAME, OBJECT_TYPE,STATUS,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss') "created"
     from dba_objects
    where OBJECT_NAME=upper('$2');
!
exit 0
fi

if [ "$1" = "snap" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80
    col status format A15
    col name format A20

    select name, status
    from all_snapshots order by 1;
!
exit 0
fi

if [ "$1" = "sga_adv" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 100
                column size_for_estimate format 999,999,999,999 heading 'Cache Size (m)'
                column buffers_for_estimate format 999,999,999 heading 'Buffers'
                column estd_physical_read_factor format 999.90 heading 'Estd Phys|Read Fact'
                column estd_physical_reads format 999,999,999 heading 'Estd Phys| Reads'

                SELECT size_for_estimate, buffers_for_estimate,
                                estd_physical_read_factor, estd_physical_reads
                FROM    V\$DB_CACHE_ADVICE
                WHERE name = 'DEFAULT'
                AND     block_size =
                                        (SELECT value FROM V\$PARAMETER
                                         WHERE name = 'db_block_size')
                                        AND     advice_status = 'ON';

!
exit 0
fi

if [ "$1" = "sharepool_adv" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

                select  SHARED_POOL_SIZE_FOR_ESTIMATE "pool size",
                                SHARED_POOL_SIZE_FACTOR "pool size factor",
                                ESTD_LC_SIZE "estd lc size",    ESTD_LC_MEMORY_OBJECTS "estd lc mem obj",
                                ESTD_LC_TIME_SAVED "time saved",
                                ESTD_LC_TIME_SAVED_FACTOR "time saved factor",
                                ESTD_LC_MEMORY_OBJECT_HITS "mem obj hits"
                 from   v\$shared_pool_advice;
!
exit 0
fi

if [ "$1" = "asm" ]; then
  sqlplus -s  /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
  connect $DBUSER
  set linesize 120
  select name, total_mb, free_mb from v\$asm_diskgroup;
!
exit 0
fi

if [ "$1" = "space" ]; then

  if [ "$2" != "" ]; then
    EXTRA_PRED="AND fs.tablespace_name='$2'"
  else
    EXTRA_PRED=""
  fi

  sqlplus -s  /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER

    set pagesize 10000
    set linesize 120
    col TABLESPACE_NAME format A30
    col status format A15
    col name format A20

     select ts.TABLESPACE_NAME, total_space_mb,
            nvl(free_space_mb, 0) free_space_mb,
            nvl(round(free_space_mb*100/total_space_mb),0) "FREE_SPACE_%"
     from (select TABLESPACE_NAME, round(sum(BYTES)/1024/1024) free_space_mb
           from dba_free_space group by TABLESPACE_NAME) fs,
        (select TABLESPACE_NAME, round(sum(BYTES)/1024/1024) total_space_mb
         from dba_data_files group by TABLESPACE_NAME) ts
     where fs.TABLESPACE_NAME(+)=ts.TABLESPACE_NAME ${EXTRA_PRED}
     order by 2;
!
exit 0
fi

if [ "$1" = "params" ]; then

  if [ "$2" != "" ]; then
    PAT="%${2}%"
  else
    PAT="%"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 150

    col name format A45
    col value format A20
    col description format A70

    select ksppinm name, ksppstvl value, ksppdesc description
    from x\$ksppi x, x\$ksppcv y
    where (x.indx = y.indx)
      and ksppinm like '$PAT'
    order by name;
!
exit 0
fi

if [ "$1" = "bc" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80

    select * from (
      select /*+ ordered use_hash(obj\$ v\$bh) */ name, count(*)
      from obj\$, v\$bh
      where obj\$.dataobj#=objd group by name order by 2 desc)
    where rownum <= 10 ;

!
exit 0
fi

if [ "$1" = "get_ddl" ]; then
  if [ "$2" = "" ]; then
    usage "ora get_ddl schema table/index/procedure object_name"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set pagesize 10000
    set long 10000
    select dbms_metadata.get_ddl(upper('$3'),upper('$4'),upper('$2')) "$4" FROM DUAL;
!
exit 0
fi

if [ "$1" = "extent" ]; then
  if [ "$2" = "" ]; then
    usage "ora extent schema seg_name"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set pagesize 10000
    set long 10000
    select file_id, block_id, blocks from dba_extents where segment_name=upper('$3') and owner=upper('$2');
!
exit 0
fi

if [ "$1" = "real_undo" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set pagesize 10000
    set long 10000 line 132
    SELECT (UR * (UPS * DBS) + DBS) AS "Undo Bytes"
  FROM (SELECT value AS UR FROM v\$parameter WHERE name = 'undo_retention'),
       (SELECT (SUM(undoblks) / SUM(((end_time - begin_time) * 86400))) AS UPS
          FROM v\$undostat),
       (SELECT value AS DBS FROM v\$parameter WHERE name = 'db_block_size');
!
exit 0
fi

if [ "$1" = "pga_sort_ratio" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set pagesize 10000
    set long 10000 line 132
    select a.value "DiskSorts",
       b.value"MemorySorts",
       round((100 * b.value) /
             decode((a.value + b.value), 0, 1, (a.value + b.value)),
             2) "PctMemorySorts"
  from v\$sysstat a, v\$sysstat b
 where a.name = 'sorts (disk)'
   and b.name = 'sorts (memory)';
!
exit 0
fi

if [ "$1" = "events" ]; then
  if [ "$2" = "px" ]; then
    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
      connect $DBUSER

      set pagesize 6000
      set linesize 120

      col SID format 99999
      col QCSID format 99999
      col PID format 9999
      col SPID format 9999999
      col Inst format 999999
      col Group format 999999
      col Set format 999999
      col Degree format 999999
      col "Req Degree" format 999999
      col "Wait Event" format A30
      col sql_hash format A15

      select px.qcsid, px.SID "SID", p.PID, p.SPID "SPID", px.INST_ID "Inst",
             px.SERVER_GROUP "Group", px.SERVER_SET "Set",
             px.DEGREE "Degree", px.REQ_DEGREE "Req Degree",
             w.event "Wait Event", s.SQL_HASH_VALUE hash_value
      from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p, GV\$session_wait w
      where s.sid (+) = px.sid
        and s.inst_id (+) = px.inst_id
        and s.sid = w.sid (+)
        and s.inst_id = w.inst_id (+)
        and s.paddr = p.addr (+)
        and s.inst_id = p.inst_id (+)
      ORDER BY decode(px.QCINST_ID, NULL, px.INST_ID, px.QCINST_ID), px.QCSID,
               decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
               px.SERVER_SET, px.INST_ID;
!
        elif [ "$2" = "read_by_other_session" ]; then

        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                        variable v_file_id   NUMBER
                        variable v_block_id  NUMBER
                        variable v_class_id  NUMBER
      connect $DBUSER
      set pagesize 6000
      set linesize 120
      SELECT p1 "file#", p2 "block#", p3 "class#" into :v_file_id, :v_block_id, :v_class_id
                                FROM v\$session_wait WHERE event = 'read by other session';

                        SELECT relative_fno, owner, segment_name, segment_type FROM dba_extents
                                WHERE file_id = :v_file_id AND :v_block_id BETWEEN block_id AND block_id + blocks - 1;
!
        elif [ "$2" = "buffer_cache" ]; then

        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                        variable v_file_id   NUMBER
                        variable v_block_id  NUMBER
                        variable v_class_id  NUMBER
      connect $DBUSER
      set pagesize 6000
      set linesize 150
      col "OWNER.object (object type)" format a40
      col USERNAME format a10
      col MODE_HELD format a15
      col MODE_REQUESTED format a15
      SELECT S.SID SESSION_ID, S.USERNAME, DECODE(LMODE, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive', TO_CHAR(LMODE)) MODE_HELD, DECODE(REQUEST, 0, 'None', 1, 'Null', 2, 'Row-S (SS)', 3, 'Row-X (SX)', 4, 'Share', 5, 'S/Row-X (SSX)', 6, 'Exclusive', TO_CHAR(REQUEST)) MODE_REQUESTED, O.OWNER||'.'||O.OBJECT_NAME||' ('||O.OBJECT_TYPE||')' "OWNER.object (object type)", S.TYPE LOCK_TYPE, L.ID1 LOCK_ID1, L.ID2 LOCK_ID2
        FROM V\$LOCK L, SYS.DBA_OBJECTS O, V\$SESSION S WHERE L.SID = S.SID AND L.ID1 = O.OBJECT_ID ;
!
else
    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 10000
      set linesize 80

      select event, count(*)
      from v\$session_wait
      where wait_time = 0 group by event;
!
  fi
exit 0
fi

if [ "$1" = "temp" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80
    col file_name format A40
    col USED_SPACE format A20
    col MAX_USED_SPACE format A20


    select round(used_blocks*(select max(BLOCK_SIZE)
                              from dba_tablespaces
                              where tablespace_name='SYSTEM')
             /1024/1024)+1 || ' MB (used)' as used_space,
           round(max_used_blocks*8/1024)+1 ||' MB (max used)' as max_used_space
    from v\$sort_segment;

break on dummy
col dummy noprint
compute sum of MB on dummy
    --select sum(round(BYTES/1024/1024)+1) total_size_mb
    --from dba_temp_files ;
    select TABLESPACE_NAME,' ' dummy, sum(round(BYTES/1024/1024)+1) MB from DBA_TEMP_FILES group by TABLESPACE_NAME order by 1;
!
  exit 0
fi

if [ "$1" = "sort_usage" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 200

    select * from v\$sort_usage where tablespace = 'TS_TEMP';
    select * from v\$sort_segment where tablespace_name = 'TS_TEMP';
    rem select * from v\$temp_space_header where tablespace_name = 'TS_TEMP';
    select * from v\$temp_extent_pool where tablespace_name = 'TS_TEMP';
!
  exit 0
fi

if [ "$1" = "sga_stats" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 200

    prompt
    prompt SGA DYNAMIC COMPNENTS
    select substr(COMPONENT,1,25) COMPONENT,
          CURRENT_SIZE/1024/1024 CURRENT_SIZE_mb,
          MIN_SIZE/1024/1024 MIN_SIZE_MB, MAX_SIZE/1024/1024 MAX_SIZE_MB,
          LAST_OPER_TYPE, LAST_OPER_MODE
    from v\$sga_dynamic_components;

    prompt
    prompt CURRENT SGA RESIZE OPERATIONS
    select COMPONENT, OPER_TYPE, OPER_MODE, PARAMETER
    from   v\$sga_current_resize_ops;
!
  exit 0
fi

if [ "$1" = "exptbs" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Connected|selected"

    connect $DBUSER

    set pagesize 0
    set linesize 80

    select '#!/bin/ksh'||chr(10)||chr(10)||'svrmgrl <<!' from dual;
    select '  connect $DBUSER' from dual;

    select '  alter tablespace ' || TABLESPACE_NAME || ' read only;'
    from dba_tablespaces
    where TABLESPACE_NAME != 'SYSTEM' and contents = 'PERMANENT'
          and tablespace_name not in (select TABLESPACE_NAME
                                      from dba_rollback_segs);

    select '!' from dual;
!

  sqlplus -s /NOLOG << ! | egrep -v "Connected|selected" > $ORA_TMP/lst$$

    connect $DBUSER

    set pagesize 0
    set linesize 80

    select TABLESPACE_NAME from dba_tablespaces
    where TABLESPACE_NAME != 'SYSTEM' and contents = 'PERMANENT'
          and tablespace_name not in (select TABLESPACE_NAME
                                      from dba_rollback_segs);

!
  LST_TBS=`cat $ORA_TMP/lst$$`
  LST_TBS=`echo $LST_TBS | sed -e 's/ /,/g'`
  rm -f $ORA_TMP/lst$$

  echo "exp TRANSPORT_TABLESPACE=y TABLESPACES=$LST_TBS"
  echo
exit 0
fi

if [ "$1" = "imptbs" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Connected|selected" > $ORA_TMP/lst$$

    connect $DBUSER

    set pagesize 0
    set linesize 80

    select /*+ ordered use_hash(t) */ '''' || file_name || ''''
    from dba_data_files f, dba_tablespaces t
    where t.TABLESPACE_NAME = f.TABLESPACE_NAME
          and t.TABLESPACE_NAME != 'SYSTEM' and t.contents = 'PERMANENT'
          and t.tablespace_name not in (select TABLESPACE_NAME
                                      from dba_rollback_segs);

!

  LST_FILES=`cat $ORA_TMP/lst$$`
  LST_FILES=`echo $LST_FILES | sed -e 's/ /,/g'`
  rm -f $ORA_TMP/lst$$

  sqlplus -s /NOLOG << ! | egrep -v "Connected|selected" > $ORA_TMP/lst$$

    connect $DBUSER

    set pagesize 0
    set linesize 80

    select TABLESPACE_NAME from dba_tablespaces
    where TABLESPACE_NAME != 'SYSTEM' and contents = 'PERMANENT'
          and tablespace_name not in (select TABLESPACE_NAME
                                      from dba_rollback_segs);

!
  LST_TBS=`cat $ORA_TMP/lst$$`
  LST_TBS=`echo $LST_TBS | sed -e 's/ /,/g'`
  rm -f $ORA_TMP/lst$$

  echo "#!/bin/ksh"
  echo
  echo
  echo "imp LOG=export.log TRANSPORT_TABLESPACE=y BUFFER=100000000 DATAFILES=$LST_FILES TABLESPACES=$LST_TBS"
  echo
  echo "svrmgrl << !"
  echo
  echo "  connect $DBUSER"

  sqlplus -s /NOLOG << ! | egrep -v "Connected|selected"

    connect $DBUSER

    set pagesize 0
    set linesize 80

    select '  alter tablespace ' || TABLESPACE_NAME || ' read write;'
    from dba_tablespaces
    where TABLESPACE_NAME != 'SYSTEM' and contents = 'PERMANENT'
          and tablespace_name not in (select TABLESPACE_NAME
                                      from dba_rollback_segs);

    select '!' from dual;
!

  exit 0
fi

if [ "$1" = "longops" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=sql_hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 120
    column opname format a30 wrap

    select $COLNM $COLNM_HEADER, opname, sofar, totalwork,
           round(sofar*100/totalwork) percent,
           round(elapsed_seconds/60) "Elapsed (min)",
           decode(sofar,0,0,round(elapsed_seconds*(totalwork-sofar)/
                  (sofar*60))) "To go (min)",
       context dfo
  from v\$session_longops
  where sofar != totalwork;
!
exit 0
fi

if [ "$1" = "sga" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Connected"

    connect $DBUSER

    set pagesize 6000
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select nvl(pool, 'Total') pool,
           decode(name, NULL, decode(pool, NULL, NULL, '(total)'), name) name,
           round(sum(bytes)/1024) as size_kb
    from v\$sgastat
    where pool is not null
          and name in ('free memory', 'PX msg pool', 'sql area',
                       'library cache')
    group by rollup(pool, name)
    order by 3;
!
  exit 0
fi

if [ "$1" = "process" ]; then

  version;

  if [ $PGA_ADVICE -eq 1 ] ; then
    FREEABLE="round(PGA_FREEABLE_MEM/1024) freeable, "
  else
    FREEABLE=""
  fi

  MAX=""

  if [ "$2" != "" ]; then
    MAX="and round(PGA_MAX_MEM/1024/1024) > $2"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Connected|PGA_USED_MEM|selected"

      connect $DBUSER

      set pagesize 6000
      set tab      off
      set linesize 140
      set echo off
      col prg format A20
      repfooter off;
      set timing off veri off space 1 flush on pause off termout on numwidth 10;

      select p.pid, p.spid, substr(p.program, 10, 20) prg,
             round(PGA_USED_MEM/1024) used,
             round(PGA_ALLOC_MEM/1024) alloc,
             $FREEABLE  round(PGA_MAX_MEM/1024) max
      from v\$process p
      where spid is not NULL $MAX
      order by 4;
!

  exit 0;
fi

if [ "$1" = "pga" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Connected|PGA_USED_MEM|selected" > $ORA_TMP/pgaout$$

    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select SPID, round(PGA_USED_MEM/1024), round(PGA_ALLOC_MEM/1024),
           round(PGA_MAX_MEM/1024)
    from v\$process
    where spid is not NULL;
!
  printf "%-20s %10s %10s %10s %15s %15s\n" NAME PID "USED(KB)" "ALLOC(KB)" "MAX_ALLOC(KB)" "MAP_SIZE(KB)"

  TOTAL_SIZE=0
  cat $ORA_TMP/pgaout$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    PID=$1
    USED=$2
    ALLOC=$3
    MAX=$4

    SIZE=0

    KB=`/usr/proc/bin/pmap -x $PID 2>/dev/null | grep anon | grep -v exec |  awk '{ s += $2 } END { print s}'`
    if  [ "$KB" != "" ]; then
      let SIZE="SIZE+KB"
    fi

    KB=`/usr/proc/bin/pmap -x $PID 2>/dev/null | grep heap | awk '{ s += $2 } END { print s}'`
    if  [ "$KB" = "" ]; then
      continue;
    fi
    let SIZE="SIZE+KB"

    ps -edf | grep "$PID " | grep -v grep | read com

    if [ "$com" = "" ]; then
      continue;
    fi
    set $com
    PNAME=$8

    let TOTAL_SIZE="TOTAL_SIZE+SIZE/1024"

    printf "%-20s %10u %10u %10u %15u %15u\n" $PNAME $PID $USED $ALLOC $MAX $SIZE
  done

  TOTAL_USED=`cat $ORA_TMP/pgaout$$ | awk '{ s += $2 } END { print int(s/1024)}'`
  TOTAL_ALLOC=`cat $ORA_TMP/pgaout$$ | awk '{ s += $3 } END { print int(s/1024)}'`
  MAX_MAX=`cat $ORA_TMP/pgaout$$ | awk '{ if (max < $3) max = $3} END {print max}'`

  printf "-------------------------------------------------------------------------------------\n"
  printf "%-20s %10s %9uM %9uM %15u %14uM\n" "Total" " " $TOTAL_USED $TOTAL_ALLOC $MAX_MAX $TOTAL_SIZE
  rm -f $ORA_TMP/pgaout$$
  echo
  exit 0
fi

#
# Detail of pga
#
if [ "$1" = "pga_detail" ]; then

  if [ "$2" = "" ]; then
    usage "OS pid or size threshold must be specified"
  fi

  if [ "$2" = "-mem" ] ; then
    if [ "$3" = "" ]; then
      usage "memory threshold not specified"
    else
      PRED="PGA_ALLOC_MEM > $3 * 1024 * 1024"
      OSPID=""
    fi
  else
    PRED="SPID=$2"
    OSPID=$2
  fi

  sqlplus -s /NOLOG << ! | grep '###' | sed -e 's/.*###\(.*\)###\(.*\)###\(.*\)###/\1 \2 \3/g' > $ORA_TMP/pid$$

     connect $DBUSER

     select '###' || pid || '###' || spid || '###' || round(pga_alloc_mem/1024/1024) || '###' version
     from v\$process
     where $PRED;
!

  FOUND=0
  cat $ORA_TMP/pid$$ | while read a; do
    set $a
    ORA_PID=$1
    OSPID=$2
    MEM=$3
    FOUND=1

    echo
    echo "Detail for process $OSPID (PGA allocated is $MEM MB)"
    echo '****************************************************'

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Statement processed|Function returned|rows selected"

      connect $DBUSER

      set pagesize 6000
      set linesize 200
      set tab      off
      set echo off
      set long     4000

      oradebug setmypid
      oradebug call ksmpgd_get_detail $ORA_PID

      ! sleep 10

      select PID, SERIAL#, CATEGORY, NAME, HEAP_NAME, BYTES, ALLOCATION_COUNT,
             HEAP_DESCRIPTOR, PARENT_HEAP_DESCRIPTOR
      from v\$process_memory_detail
      where PID=$ORA_PID
      order by bytes;
!

  done

  if [ $FOUND -eq 1 -a "$OSPID" != "" ]; then
    usage "OS pid $OSPID does not exists in v\$process"
  fi

  rm -f $ORA_TMP/pid$$

exit 0
fi


if [ "$1" = "binds" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  version;

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    col sql_text format A75 WORD_WRAP
    repfooter off;
    col BIND_NAME format A15
    column VALUE_STRING format A20 wrap
    column CAPTURED format A10
    column LAST_CAPTURED format A20
    col sql_hash format A15
    col sql_id format A18
    col sql_text format A75 WORD_WRAP

    select $COLNM ||
           decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
           sql_text
    from v\$sql
    where child_number=$CNUM and $COLNAME=$HVAL;

    select NAME BIND_NAME, POSITION POS, DATATYPE_STRING BIND_TYPE,
           WAS_CAPTURED CAPTURED,
           case
             when WAS_CAPTURED='YES' and LAST_CAPTURED is null
             then 'YES'
             else 'NO'
           end "Reverted",
           TO_CHAR(LAST_CAPTURED, 'HH:MI:SS (DD Mon)') LAST_CAPTURED,
           VALUE_STRING
    from  v\$sql_bind_capture
    where $COLNAME  = $HVAL and CHILD_NUMBER=$CNUM;
!

exit 0
fi

if [ "$1" = "optenv" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  version;

  # get SQL id
  shift
  setup_hash_value hash_value sql_id $1 $2
  shift $SHIFT_PARAM

  if [ "$1" != "" ]; then
    PFIL=" and KQLFSQCE_PNAME like '%${1}%'"
  else
    PFIL=""
  fi

  if [ "$COLNAME" = "sql_id" ]; then
    COLNAME_KQLFSQCE=KQLFSQCE_SQLID
  else
    COLNAME_KQLFSQCE=KQLFSQCE_HASH
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    col sql_text format A75 WORD_WRAP
    repfooter off;
    col sql_text format A75 WORD_WRAP
    col sql_hash format A15
    col sql_id format A18

    select $COLNM ||
           decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
           sql_text
    from v\$sql
    where child_number=$CNUM
          and $COLNAME = $HVAL;

    select KQLFSQCE_PNAME name, KQLFSQCE_PVALUE value,
           decode(bitand(KQLFSQCE_FLAGS, 2), 0, 'NO', 'YES') is_default
    from X\$KQLFSQCE
    where $COLNAME_KQLFSQCE=$HVAL
      and KQLFSQCE_CHNO=$CNUM $PFIL order by 3,1;
!

exit 0
fi

if [ "$1" = "plan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  version;

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  if [ $VERSION_MAIN -lt 10 ]; then

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    set long     4000
    col TQID         format A4
    col "SLAVE SQL"  format A95 WORD_WRAP
    col sql_hash format A15
    col exec format 9999
    col sql_text format A75 WORD_WRAP

    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;
    alter session set "_complex_view_merging"=false;

    select $COLNM||decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
           sql_text
    from v\$sql
    where child_number = $CNUM
      and $COLNAME = $HVAL;

    select '| Operation                       |  Name              |  Rows | Bytes|  Cost  |  TQ  |IN-OUT| PQ Distrib | Pstart| Pstop |' as "Plan Table" from dual
    union all /* QWEKLOIPYRTJHH7 */
    select '---------------------------------------------------------------------------------------------------------------------------' from dual
    union all
    select      rpad('| '||substr(lpad(' ',1*(depth))||operation||
            decode(options, null,'',' '||options), 1, 33), 34, ' ')||'|'||
       rpad(substr(object_name||' ',1, 19), 20, ' ')||'|'||
       lpad(decode(cardinality,null,'  ',
             decode(sign(cardinality-1000), -1, cardinality||' ',
       decode(sign(cardinality-1000000), -1, round(cardinality/1000)||'K',
       decode(sign(cardinality-1000000000), -1, round(cardinality/1000000)||'M',
                       round(cardinality/1000000000)||'G')))), 7, ' ') || '|' ||
       lpad(decode(bytes,null,' ',
                decode(sign(bytes-1024), -1, bytes||' ',
                decode(sign(bytes-1048576), -1, round(bytes/1024)||'K',
                decode(sign(bytes-1073741824), -1, round(bytes/1048576)||'M',
                       round(bytes/1073741824)||'G')))), 6, ' ') || '|' ||
       lpad(decode(cost,null,' ',
                decode(sign(cost-10000000), -1, cost||' ',
                decode(sign(cost-1000000000), -1, round(cost/1000000)||'M',
                       round(cost/1000000000)||'G'))), 8, ' ') || '|' ||
       lpad(decode(object_node,null,' ',
             substr(object_node,length(object_node)-3,1) || ',' ||
             substr(object_node,length(object_node)-1,2))||' ', 6, ' ') || '|' ||
       lpad(decode(other_tag, null,' ',
            decode(other_tag,'PARALLEL_TO_SERIAL', ' P->S',
            decode(other_tag, 'PARALLEL_TO_PARALLEL', ' P->P',
            decode(other_tag, 'PARALLEL_COMBINED_WITH_PARENT', ' PCWP',
            decode(other_tag, 'PARALLEL_FROM_SERIAL', ' S->P',
            decode(other_tag, 'PARALLEL_COMBINED_WITH_CHILD', ' PCWC',
               decode(other_tag,null,' ',other_tag)))))))||' ', 6, ' ') || '|' ||
       rpad(' '||decode(distribution, null,' ',
          decode(distribution, 'PARTITION (ROWID)', 'PART (RID)',
          decode(distribution, 'PARTITION (KEY)', 'PART (KEY)',
          decode(distribution, 'ROUND-ROBIN', 'RND-ROBIN',
          decode(distribution, 'BROADCAST', 'BROADCAST',
                 distribution))))), 12, ' ') || '|' ||
       lpad(decode(partition_start, 'ROW LOCATION', 'ROWID',
            decode(partition_start, 'KEY', 'KEY', decode(partition_start,
            'KEY(INLIST)', 'KEY(I)', decode(substr(partition_start, 1, 6),
            'NUMBER', substr(substr(partition_start, 8, 10), 1,
            length(substr(partition_start, 8, 10))-1),
     decode(partition_start,null,' ',partition_start)))))||' ', 7, ' ')|| '|' ||
       lpad(decode(partition_stop, 'ROW LOCATION', 'ROW L',
          decode(partition_stop, 'KEY', 'KEY', decode(partition_stop,
          'KEY(INLIST)', 'KEY(I)', decode(substr(partition_stop, 1, 6),
          'NUMBER', substr(substr(partition_stop, 8, 10), 1,
          length(substr(partition_stop, 8, 10))-1),
          decode(partition_stop,null,' ',partition_stop)))))||' ',
                 7, ' ')||'|' as "Explain plan"
   from
     (select /*+ no_merge */ hash_value sql_hash, ID, DEPTH, POSITION,
                            OPERATION, OPTIONS,
                            COST COST, CARDINALITY CARDINALITY, BYTES BYTES,
                            OBJECT_NODE,
                            OBJECT_OWNER, OBJECT_NAME, OTHER_TAG,
                            PARTITION_START,
                            PARTITION_STOP, DISTRIBUTION
      from  v\$sql_plan vp
      where $COLNAME = $HVAL and CHILD_NUMBER = $CNUM)
    union all
    select '---------------------------------------------------------------------------------------------------------------------------' from dual;

  REM
  REM Print slave sql
  REM
  select  /* QWEKLOIPYRTJHH7 */ decode(object_node,null,'',
              substr(object_node,length(object_node)-3,1) || ',' ||
              substr(object_node,length(object_node)-1,2)) TQID,
       other "SLAVE SQL"
  from v\$sql_plan vp
  where other is not NULL and
        $COLNAME = $HVAL and CHILD_NUMBER=$CNUM;
!

  else

    shift
    FMT=$*

    if [ "$FMT" = "" ]; then
      FMT="typical"
    fi

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    repfooter off;

    select * from table(dbms_xplan.display_cursor($HVAL, $CNUM, '$FMT'));
!

  fi

exit 0

fi


if [ "$1" = "wplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | egrep -v  "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    set long     4000
    col TQID         format A4
    col "SLAVE SQL"  format A95 WORD_WRAP
    col address format A12
    col sql_hash format A15
    col sql_id format A18
    col exec format 9999
    col sql_text format A75 WORD_WRAP

    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;
    alter session set "_complex_view_merging"=false;

    select $COLNM ||
           decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
           sql_text
    from v\$sql
    where child_number = $CNUM
      and $COLNAME = $HVAL;

    select '| Operation                       |  Name              | Bytes | OMem | 1Mem |  O/1/M  |  Last  | LastMem | Time | ' as "Workarea Table" from dual
    union all
    select '------------------------------------------------------------------------------------------------------------------' from dual
    union all
    select rpad('| '||substr(lpad(' ',1*(depth))||operation||
            decode(options, null,'',' '||options), 1, 33), 34, ' ')||'|'||
       rpad(substr(object_name||' ',1, 19), 20, ' ')||'|'||
       lpad(decode(bytes,null,' ',
                decode(sign(bytes-1024), -1, bytes||' ',
                decode(sign(bytes-1048576), -1, round(bytes/1024)||'K',
                decode(sign(bytes-1073741824), -1, round(bytes/1048576)||'M',
                       round(bytes/1073741824)||'G')))), 7, ' ') || '|' ||
       lpad(decode(estimated_optimal_size,null,' ',
                decode(sign(estimated_optimal_size-1024), -1, estimated_optimal_size||'K',
                decode(sign(estimated_optimal_size-1048576), -1, round(estimated_optimal_size/1024)||'M',
                decode(sign(estimated_optimal_size-1073741824), -1, round(estimated_optimal_size/1048576)||'G',
                       round(estimated_optimal_size/1073741824)||'T')))), 6, ' ') || '|' ||
       lpad(decode(estimated_onepass_size,null,' ',
                decode(sign(estimated_onepass_size-1024), -1, estimated_onepass_size||'K',
                decode(sign(estimated_onepass_size-1048576), -1, round(estimated_onepass_size/1024)||'M',
                decode(sign(estimated_onepass_size-1073741824), -1, round(estimated_onepass_size/1048576)||'G',
                       round(estimated_onepass_size/1073741824)||'T')))), 6, ' ') || '|' ||
       lpad(decode(OPTIMAL_EXECUTIONS, NULL, ' ',
                   decode(TOTAL_EXECUTIONS, 0, '-',
                   OPTIMAL_EXECUTIONS || '/' || ONEPASS_EXECUTIONS || '/' || MULTIPASSES_EXECUTIONS)), 8, ' ') || ' |' ||
       lpad(decode(LAST_EXECUTION, NULL, ' ',
                   decode(TOTAL_EXECUTIONS, 0, '- ',
                   LAST_EXECUTION)), 8, ' ') || '|' ||
       lpad(decode(last_memory_used,null,' ',
                decode(TOTAL_EXECUTIONS, 0, '- ',
                decode(sign(last_memory_used-1024), -1, last_memory_used||'K',
                decode(sign(last_memory_used-1048576), -1, round(last_memory_used/1024)||'M',
                decode(sign(last_memory_used-1073741824), -1, round(last_memory_used/1048576)||'G',
                       round(last_memory_used/1073741824)||'T'))))), 9, ' ') || '|' ||
       lpad(decode(active_time,null,' ',
                decode(TOTAL_EXECUTIONS, 0, '- ',
                decode(sign(round(active_time)-1000), -1, round(active_time)||'ms',
                decode(sign(round(active_time/1000)-1000), -1, round(active_time/1000)||'s',
                decode(sign(round(active_time/1000)-3600), -1, round(active_time/1000/60)||'m',
                       round(active_time/1000/3600)||'h'))))), 6, ' ') || '|' as "Workarea stats"
    from
      (select /*+ no_merge ordered use_nl(w) */
              p.hash_value, p.ID, p.DEPTH, p.POSITION, p.OPERATION, p.OPTIONS,
              p.BYTES BYTES, p.OBJECT_NODE, p.OBJECT_OWNER, p.OBJECT_NAME,
              round(w.estimated_optimal_size/1024) estimated_optimal_size,
              round(w.estimated_onepass_size/1024) estimated_onepass_size,
              w.TOTAL_EXECUTIONS, w.OPTIMAL_EXECUTIONS, w.ONEPASS_EXECUTIONS,
              w.MULTIPASSES_EXECUTIONS, w.LAST_EXECUTION,
              round(w.last_memory_used/1024) last_memory_used,
              round(w.active_time/1000) active_time
       from v\$sql_plan p, v\$sql_workarea w
       where p.address = w.address(+) and p.id = w.operation_id(+)
            and p.$COLNAME = $HVAL
            and w.$COLNAME(+) = $HVAL
            and p.child_number=$CNUM
            and w.child_number(+)=$CNUM)
    union all
    select '------------------------------------------------------------------------------------------------------------------' from dual;

REM
REM Print slave sql
REM
select /* QWEKLOIPYRTJHH7 */ decode(object_node,null,'',
              substr(object_node,length(object_node)-3,1) || ',' ||
              substr(object_node,length(object_node)-1,2)) TQID,
       other "SLAVE SQL"
  from v\$sql_plan vp
  where other is not NULL and
        $COLNAME = $HVAL and child_number=$CNUM;

!

exit 0
fi

if [ "$1" = "pxplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  echo
  echo "---------------------------------"
  echo "         QC plan  "
  echo "---------------------------------"
  $ORA_PROG $ARGS plan $2

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected" > $ORA_TMP/pxplanout$$
    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select distinct sv.$COLNAME, sv.object_node
    from v\$sql_plan qc,
        (SELECT object_node, $COLNAME
         FROM v\$sql_plan
         WHERE id=0 AND object_node is not null) sv
    WHERE qc.$COLNAME = $HVAL AND qc.child_number = $CNUM
      AND id != 0 AND qc.object_node = sv.object_node
    order by sv.object_node;
!

  cat $ORA_TMP/pxplanout$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    echo
    echo "---------------------------------"
    echo "           DFO $2  "
    echo "---------------------------------"
    $ORA_PROG $ARGS plan $1

  done

exit 0
fi

if [ "$1" = "mpass" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected" > $ORA_TMP/mpassout$$
  connect $DBUSER

  set pagesize 0
  set tab      off
  set linesize 140
  set echo off
  repfooter off;
  set timing off veri off space 1 flush on pause off termout on numwidth 10;

  select distinct $COLNM, child_number
  from v\$sql_workarea
  where MULTIPASSES_EXECUTIONS > 0
  order by 1, 2;
!

  cat $ORA_TMP/mpassout$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    echo
    echo "--------------------------------------"
    echo "       Multi-pass cursor $1/$2 "
    echo "--------------------------------------"
    $ORA_PROG $ARGS wplan $1/$2

  done

  rm -f $ORA_TMP/mpassout$$

  exit 0
fi

if [ "$1" = "onepass" ]; then

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected" > $ORA_TMP/mpassout$$
  connect $DBUSER

  set pagesize 0
  set tab      off
  set linesize 140
  set echo off
  repfooter off;
  set timing off veri off space 1 flush on pause off termout on numwidth 10;


  select distinct $COLNM, child_number
  from v\$sql_workarea
  where ONEPASS_EXECUTIONS > 0
  order by 1, 2;
!

  cat $ORA_TMP/mpassout$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    echo
    echo "--------------------------------------"
    echo "      One-pass cursor $1/$2 "
    echo "--------------------------------------"
    $ORA_PROG $ARGS wplan $1/$2

  done

  rm -f $ORA_TMP/mpassout$$

  exit 0
fi


if [ "$1" = "pxwplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  echo
  echo "---------------------------------"
  echo "         QC workarea plan  "
  echo "---------------------------------"
  $ORA_PROG $ARGS wplan $2

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected" > $ORA_TMP/pxwplanout$$
    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select distinct sv.$COLNM $COLNM_HEADER, sv.object_node
    from v\$sql_plan qc,
        (SELECT object_node, $COLNM
         FROM v\$sql_plan
         WHERE id=0 AND object_node is not null) sv
    WHERE qc.$COLNAME = $HVAL AND qc.child_number = $CNUM
      AND id != 0 AND qc.object_node = sv.object_node
    order by sv.object_node;
!

  cat $ORA_TMP/pxwplanout$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    echo
    echo "----------------------------------------"
    echo "           DFO $2 workarea plan ($1)"
    echo "----------------------------------------"
    $ORA_PROG $ARGS wplan $1

  done

exit 0
fi

if [ "$1" = "eplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  version;

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  if [ $VERSION_MAIN -lt 10 ]; then

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 600
      set tab      off
      set linesize 140
      set echo off
      set long     4000
      col TQID         format A4
      col "SLAVE SQL"  format A95 WORD_WRAP
      col address format A12
      col sql_hash format A15
      col sql_hash format A18
      col exec format 9999
      col sql_text format A75 WORD_WRAP

      repfooter off;
      set timing off veri off space 1 flush on pause off termout on numwidth 10;
      alter session set "_complex_view_merging"=false;

      select $COLNM ||
             decode(child_number, 0, '', '/'||child_number) $COLNM_HEADER,
             sql_text
      from v\$sql
      where child_number=$CNUM
        and $COLNAME=$HVAL;

      select '| Operation                       |  Name              | Starts | E-Rows | A-Rows | Buffers | Reads  | Writes | E-Time |' as "Plan Table" from dual
      union all /* QWEKLOIPYRTJHH7 */
      select '------------------------------------------------------------------------------------------------------------------------' from dual
      union all
      select      rpad('| '||substr(lpad(' ',1*(depth))||operation||
              decode(options, null,'',' '||options), 1, 33), 34, ' ')||'|'||
         rpad(substr(object_name||' ',1, 19), 20, ' ')||'|'||
         lpad(decode(starts,null,'  ',
                  decode(sign(starts-1000), -1, starts||' ',
                  decode(sign(starts-1000000), -1, round(starts/1000)||'K',
                  decode(sign(starts-1000000000), -1, round(starts/1000000)||'M',
                         round(starts/1000000000)||'G')))), 8, ' ') || '|' ||
         lpad(decode(cardinality,null,'  ',
                  decode(sign(cardinality-1000), -1, cardinality||' ',
                  decode(sign(cardinality-1000000), -1, round(cardinality/1000)||'K',
                  decode(sign(cardinality-1000000000), -1, round(cardinality/1000000)||'M',
                         round(cardinality/1000000000)||'G')))), 8, ' ') || '|' ||
         lpad(decode(outrows,null,'  ',
                  decode(sign(outrows-1000), -1, outrows||' ',
                  decode(sign(outrows-1000000), -1, round(outrows/1000)||'K',
                  decode(sign(outrows-1000000000), -1, round(outrows/1000000)||'M',
                         round(outrows/1000000000)||'G')))), 8, ' ') || '|' ||
         lpad(decode(crgets,null,' ',
                  decode(sign(crgets-10000000), -1, crgets||' ',
                  decode(sign(crgets-1000000000), -1, round(crgets/1000000)||'M',
                         round(crgets/1000000000)||'G'))), 9, ' ') || '|' ||
         lpad(decode(reads,null,' ',
                  decode(sign(reads-10000000), -1, reads||' ',
                  decode(sign(reads-1000000000), -1, round(reads/1000000)||'M',
                         round(reads/1000000000)||'G'))), 8, ' ') || '|' ||
         lpad(decode(writes,null,' ',
                  decode(sign(writes-10000000), -1, writes||' ',
                  decode(sign(writes-1000000000), -1, round(writes/1000000)||'M',
                         round(writes/1000000000)||'G'))), 8, ' ') || '|' ||
         lpad(decode(etime,null,' ',
                  decode(sign(etime-10000000), -1, etime||' ',
                  decode(sign(etime-1000000000), -1, round(etime/1000000)||'M',
                         round(etime/1000000000)||'G'))), 8, ' ') || '|'  as "Explain plan"
     from
       (select /*+ no_merge */
               HASH_VALUE, ID, DEPTH, POSITION, OPERATION, OPTIONS,
               COST COST, CARDINALITY CARDINALITY, BYTES BYTES, OBJECT_NODE,
               OBJECT_OWNER, OBJECT_NAME, OTHER_TAG, PARTITION_START,
               PARTITION_STOP, DISTRIBUTION,
               starts, OUTPUT_ROWS outrows, CR_BUFFER_GETS crgets,
               DISK_READS reads, DISK_WRITES writes,
               ELAPSED_TIME etime
        from  v\$sql_plan_statistics_all
        where $COLNAME = $HVAL and CHILD_NUMBER=$CNUM)
      union all
      select '------------------------------------------------------------------------------------------------------------------------' from dual;

    REM
    REM Print slave sql
    REM
    select  /* QWEKLOIPYRTJHH7 */ decode(object_node,null,'',
                substr(object_node,length(object_node)-3,1) || ',' ||
                substr(object_node,length(object_node)-1,2)) TQID,
         other "SLAVE SQL"
    from v\$sql_plan vp
    where other is not NULL and
          $COLNAME  = $HVAL and CHILD_NUMBER=$CNUM;
!

else

  shift
  FMT=$*

  if [ "$FMT" = "" ]; then
    FMT="RUNSTATS_TOT"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 220
    set echo off
    repfooter off;

    select * from table(dbms_xplan.display_cursor($HVAL, $CNUM, '$FMT'));
!
fi

exit 0
fi

if [ "$1" = "pxeplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
    COLNM_HEADER=sql_id
  else
    COLNM=hash_value
    COLNM_HEADER=sql_hash
  fi

  echo
  echo "---------------------------------"
  echo "         QC plan  "
  echo "---------------------------------"
  $ORA_PROG $ARGS eplan $2

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected" > $ORA_TMP/pxeplanout$$
    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select distinct sv.$COLNM $COLNM_HEADER, sv.object_node
    from v\$sql_plan qc,
        (SELECT object_node, $COLNM
         FROM v\$sql_plan
         WHERE id=0 AND object_node is not null) sv
    WHERE qc.$COLNAME = $HVAL AND qc.child_number = $CNUM
      AND id != 0 AND qc.object_node = sv.object_node
    order by sv.object_node;
!

  cat $ORA_TMP/pxeplanout$$ | while read a; do
    if [ "$a" = "" ]; then
      continue;
    fi
    set $a

    echo
    echo "---------------------------------"
    echo "           DFO $2  "
    echo "---------------------------------"
    $ORA_PROG $ARGS eplan $1

  done

exit 0
fi

if [ "$1" = "hash_to_sqlid" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  echo

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select 'SQL id is: ' || sql_id from v\$sql where hash_value = $2;
!
  exit 0
fi

if [ "$1" = "sharing" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor sql_id is missing"
  fi

  version;

  SQLID=`echo "$2" | sed -e "s/\([0-9A-Fa-zA-Z]*\)\/\([0-9]*\)/\1/g"`
  CNUM=`echo "$2" | sed -e "s/\([0-9A-F]*\)\/\([0-9]*\)/\2/g"`
  if [ "$CNUM" = "" -o "$CNUM" = "$2" ]; then
    CNUM=0
    CNUM_MAX=100000000
  else
    CNUM_MAX=$CNUM
  fi

  sqlplus -s /NOLOG << !
    connect $DBUSER

#    set pagesize 0
#    set tab      off
#    set linesize 140
#    set echo off
#    repfooter off;
#    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    set heading on
    set echo on
    set feedback on

    select * from v\$sql_shared_cursor
    where sql_id='$SQLID'
      and child_number>=$CNUM and child_number<=$CNUM_MAX
    order by child_number;

!
  exit 0
fi


if [ "$1" = "sqlid_to_hash" ]; then

  if [ "$2" = "" ]; then
    usage "Sql_id parameter is missing"
  fi

  echo

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
    connect $DBUSER

    set pagesize 0
    set tab      off
    set linesize 140
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    select 'Hash value is: ' || hash_value from v\$sql where sql_id = '$2';
!
  exit 0
fi

if [ "$1" = "last_sql_hash" ]; then

  if [ "$2" = "" ]; then
    SID=0
  else
    SID=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
    connect $DBUSER
      set heading off
      set feedback off
      select prev_hash_value ||
             decode(prev_child_number, 0, '', '/' || prev_child_number)
      from v\$session
      where type = 'USER'
        and username != 'SYS'
        and $SID = 0 or sid = $SID;
!
  exit 0
fi


if [ "$1" = "cur_mem" ]; then

  COLNAME="0"

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  create_format_functions

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    column inst_id heading id format 9
    column lock_mode heading lm format a2
    column pin_mode  heading pm format a2
    column sql_text format a53 word_wrap
    column shr      format a5
    column per      format a5
    column run      format a5


    select /* ora cur_mem */
           $INST_ID sql_text,
           lock_mode, pin_mode,
           $FORMAT_SIZE(sharable_mem)      shr,
           $FORMAT_SIZE(persistent_mem)    per,
           $FORMAT_SIZE(runtime_mem)       run
    from (
      select
        inst_id,
        kglnaobj       sql_text,
        decode(kglhdlmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') lock_mode,
        decode(kglhdpmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') pin_mode,
        kglobhs0+kglobhs1+kglobhs2+kglobhs3+kglobhs4+kglobhs5+kglobhs6+kglobt16
                       sharable_mem,
        kglobt08+kglobt11 persistent_mem,
        kglobt10       runtime_mem,
        kglnahsh       hash_value,
        kglobt03       sql_id,
        kglobt09       child_number,
        kglobt17       parsing_user_id
      from x\$kglcursor_child)
    where ($HVAL = 0 or $COLNAME = $HVAL)
      and PARSING_USER_ID != $EXCLUDE
    order by $INST_ID sharable_mem desc;
!


exit 0
fi


if [ "$1" = "shared_mem" ]; then
#
# Need to set 10235 to level 4 for this to work
#
# alter session set events '10235 trace name context forever, level 4';
#

  COLNAME="0"

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    column sqltext heading sqltext              format a40
    column comm    heading comment              format a16
    column cnt     heading cnt          format 9999
    column avgsize heading avg          format 9999
    column sumsize heading sum          format 9999999

    break on sqltext skip page
    compute sum of sumsize on sqltext

    select sql_text                           sqltext,
           chunk_com                          comm,
           count(*)                           cnt,
           avg(chunk_size)                    avgsize,
           sum(chunk_size)                    sumsize
    from v\$sql_shared_memory
    where ($HVAL = '0' or $COLNAME = $HVAL)
    group by sql_text, chunk_com
    order by 1, 5 desc;

!

exit 0
fi

if [ "$1" = "runtime_mem" ]; then
#
# Need to set 10277 to level 10 for for this to work
#
# alter session set event '10277 trace name context forever, level 10';
#

  COLNAME="0"

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    column sqltext heading sqltext format a38
    column type    heading comment format a24
    column cnt     heading count   format 9999
    column sumsize heading size    format 9999999

    break on sqltext skip page
    compute sum of sumsize on sqltext

    select sql_text                           sqltext,
           kksaicmt                           type,
           count(*)                           cnt,
           sum(kksaisiz)                      sumsize
    from v\$sql v, x\$kksai x
    where v.address = x.kksaipar
      and ($HVAL = 0 or $COLNAME = $HVAL)
      and v.PARSING_USER_ID != $EXCLUDE
    group by sql_text, kksaicmt
    order by 1, 4 desc;

!

exit 0
fi


if [ "$1" = "ash" ]; then

  if [ "$2" = "" ]; then
    usage "<minutes_from_now> parameter is missing"
  fi
  START_TIME=$2

  shift 2

  FNAME="/tmp/ashrpt$$.txt"
  REM=1
  DURATION=""
  while [ "$1" != "" ]; do

    if [ "$1" = "-f" ]; then
      FNAME=$2
      REM=0
      shift 2
      continue;
    fi

    DURATION="$1"
    shift
  done

  sqlplus -s /NOLOG << ! >/dev/null 2>&1
    connect $DBUSER

    set pagesize 600
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    define report_type = 'text';
    define begin_time  = '-$START_TIME';
    define duration    = '$DURATION';
    define report_name = '$FNAME';
    @?/rdbms/admin/ashrpt
!

  echo
  echo "                 ASH Report Output"
  echo "                 ================="
  echo
  cat $FNAME
  if [ $REM -eq 1 ]; then
    rm -f $FNAME
  fi

exit 0
fi


if [ "$1" = "ash_wait" ]; then

  if [ "$2" = "" ]; then
    usage "<minutes_from_now> parameter is missing"
  fi
  START_TIME=$2

  shift 2

  FNAME="wait.graph"
  DURATION=$START_TIME
  while [ "$1" != "" ]; do

    if [ "$1" = "-f" ]; then
      FNAME=$2
      shift 2
      continue;
    fi

    DURATION="$1"
    shift
  done

  FMT='MON DD HH24:MI:SS'

  sqlplus -s /NOLOG << ! > $FNAME 2>/dev/null

   variable begin_date VARCHAR2(100)
   variable end_date VARCHAR2(100)

   connect $DBUSER

   set serveroutput on feedback off echo off verify off;

   begin
     select to_char(sysdate - ((1/24/60) * $START_TIME), '$FMT'),
            to_char(sysdate - ((1/24/60) * ($START_TIME - $DURATION)), '$FMT')
            into :begin_date, :end_date
     from dual;
   end;
   /

   DECLARE
       event NUMBER;
       slottime NUMBER;
       waitonevent NUMBER;
       event_name VARCHAR2(64);

       -- Get top 10 events for query duration based  on count of event samples
       -- mxgraph cannot display only 1 point per line. Eliminate 1 point lines.
       cursor top_10_events
       is
            select event#, event
            from  (
                    select
                            ash.event#,
                            ash.event,
                            count(*) as total_wait_count
                    from  v\$active_session_history  ash
                    where sample_time between to_date( :begin_date, '$FMT' )
                                      and to_date( :end_date, '$FMT' )   and
                          session_state = 'WAITING'
                    group by ash.event#, ash.event  order by total_wait_count desc )
            where  rownum < 10;

       -- Get graph co-ordinates (time,wait_counts) for each of the top 10 events
       cursor sesshist (cevent NUMBER)
       is
       select
              min_slot,
              evt_cnt
        from (
            select
                (slot_id - min(slot_id) over ()) * slot_time as min_slot,
                event#,
                trunc((event_counts_per_slot/slot_time),1) as evt_cnt
            from (
                select
                    trunc( (cast(ash.sample_time as date) -
                                 to_date('00:00:00 01/01/1970',
                                     'HH24:MI:SS MM/DD/YYYY')) * 86400 / (v.slot_time) ) as slot_id,
                    event#,
                    count(*) as event_counts_per_slot,
                    v.slot_time as slot_time
                from v\$active_session_history  ash,
                ( select
                    (case when trunc(duration/200) > 5 then trunc(duration/200)
                                                        else 5 end) as slot_time
                  from
                    ( select ((to_date(:end_date, '$FMT') -
                               to_date(:begin_date, '$FMT'))*86400) as duration
                      from  dual)) v
                where   sample_time between to_date( :begin_date, '$FMT' ) and
                        to_date( :end_date, '$FMT' ) and
                        session_state = 'WAITING'
                group by trunc( (cast(ash.sample_time as date) -
                         to_date('00:00:00 01/01/1970', 'HH24:MI:SS MM/DD/YYYY')) * 86400 /
                                  (v.slot_time) ) ,
                event#))
        where event# =  cevent;


      BEGIN
        dbms_output.enable(10000);
        dbms_output.put_line('TitleText: Top Wait Events - Count'||chr(10)||'XUnitText: Time (s)'||chr(10)||'YUnitText: Num of Slaves');
        dbms_output.put_line('BarGraph: True'||chr(10)||'NoLines: True'||chr(10)||'PixelMarkers: True'||chr(10)||'BarWidth: 2');
        OPEN top_10_events;
        LOOP
         FETCH top_10_events into event,event_name;
         EXIT WHEN top_10_events%NOTFOUND;
         dbms_output.put_line(chr(10)||'"'||event_name||'"');
           OPEN sesshist (event);
           LOOP
             FETCH sesshist into slottime,waitonevent;
             EXIT WHEN sesshist%NOTFOUND;
             dbms_output.put_line(slottime||' '||waitonevent);
           END LOOP;
           CLOSE sesshist;
        END LOOP;

        CLOSE top_10_events;

      END;
      /

!

  mxgraph $FNAME

exit 0
fi


#
# all_mem: all the memory for a given hash value
#
if [ "$1" = "all_mem" ]; then
#    $ORA_PROG plan $temp_hash_value
    $ORA_PROG $ARGS cur_mem $2 $3
    $ORA_PROG $ARGS shared_mem $2 $3
    $ORA_PROG $ARGS runtime_mem $2 $3
exit 0
fi


if [ "$1" = "idxdesc" ]; then

  if [ "$2" = "" ]; then
       usage "username is missing"
  fi

  if [ "$3" != "" ]; then
    EXTRA_PRED="and ind.table_name = upper('$3')"
  else
    EXTRA_PRED=""
  fi
    sqlplus -s /NOLOG <<! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER
    set pagesize 300
    set linesize 180
    set feedback off
    col uniq    format a1 heading 'Uniqueness'  justify c trunc
    col indname format a31 heading 'Index Name'  justify c trunc
    col colname format a25 heading 'Column Name' justify c trunc
    col type format A6 trunc

    break -
      on table_name -
      on indname -
      on uniq -
      on type -

  select col.table_name, decode(ind.uniqueness,'UNIQUE','Y','N') uniq,
       decode(ind.index_type,'NORMAL','',ind.index_type) type,
       col.index_name  indname,
       col.column_name                 colname
  from   all_ind_columns  col,
         all_indexes      ind
  where  col.table_owner = ind.table_owner
    and  col.index_name = ind.index_name
    and  ind.table_owner = upper('$2') ${EXTRA_PRED}
  order by col.table_name, col.index_name, col.column_position;
!
  exit 0
fi

if [ "$1" = "segsize" ]; then

  if [ "$2" = "" ]; then
       usage "username is missing"
  fi

  if [ "$3" != "" ]; then
    EXTRA_PRED="and seg.segment_name = upper('$3')"
  else
    EXTRA_PRED=""
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER
  set linesize 140
  set pagesize 300
  column segment_name    format a40;
  column owner           format a10;
  column tablespace_name format a30;
  column Size_MB      format 999999999;
  break  on segment_name skip 1

  -- compute sum label Total of Size_MB on segment_name;

  select tablespace_name, segment_name||
        decode(segment_type,'TABLE','[Tab]','INDEX','[Idx]', 'ROLLBACK', '[Rbs]') segment_name
      , sum(bytes)/(1024*1024) Size_MB
  from dba_segments seg
  where seg.owner = upper ('$2') ${EXTRA_PRED}
  group by tablespace_name, segment_name||
        decode(segment_type,'TABLE','[Tab]','INDEX','[Idx]', 'ROLLBACK', '[Rbs]')
  order by Size_Mb;
!
exit 0
fi

if [ "$1" = "tempu" ]; then
  if [ "$2" != "" ]; then
    EXTRA_PRED="AND   s.username=upper('$2')"
  else
    EXTRA_PRED=""
  fi

  if [ "$ORA_USE_HASH" = "" ]; then
    COLNM=sql_id
  else
    COLNM=sqlhash
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 100
    set linesize 100
    col sql_text format a90
    col username format a15
    col tablespace format a20

    SELECT u.$COLNM, t.sql_text, s.username, u.tablespace, u.segtype,
           u.contents, u.extents, u.blocks
    FROM v\$session s, v\$sort_usage u, v\$sqlarea t
    WHERE s.saddr=u.session_addr
    AND   u.sqlhash=t.hash_value  ${EXTRA_PRED} ;

!
exit 0
fi

if [ "$1" = "sqlstats" ]; then

    if [ "$2" = "" ]; then
       usage "Cursor hash value is missing"
    fi

    if [ $VERSION_MAIN -ge 10 ]; then
      DWRITES=", DIRECT_WRITES dw "
      PLSQL="round(PLSQL_EXEC_TIME/1000000, 2) plsql,"
    fi

    setup_hash_value hash_value sql_id $2 $3
    shift $SHIFT_PARAM

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 100
    set linesize 160

    select executions exe,
           round(CPU_TIME/1000000, 2) cpu,
           round(ELAPSED_TIME/1000000, 2) elaps, $PLSQL
           BUFFER_GETS bgets, DISK_READS dr $DWRITES
   from v\$sql
   where $COLNAME = $HVAL ;

!
exit 0
fi

if [ "$1" = "optstats" ]; then

  if [ "$2" = "" ]; then
       usage "username is missing"
  fi

  if [ "$3" != "" ]; then
    EXTRA_PRED="and table_name = upper('$3')"
  else
    EXTRA_PRED=""
  fi

    sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 400
    set linesize 130
    col DISTRATIO format 9999.99
    col table_name format a30
    col column_name format a30
    break on table_name  skip 1
    col num_rows format 99999999999
    col num_distinct format 99999999999

    select * from (
    select t.table_name, column_name, num_rows, num_distinct,
           (num_distinct/num_rows)*100 DistRatio, row_number()
    OVER( PARTITION BY  t.table_name
          order by (num_distinct/num_rows)*100  desc) Top100
    from dba_tab_cols c, dba_tables t
    where t.table_name=c.table_name
    and t.num_rows > 0
    and t.owner=upper('$2')
    and c.table_name in (select distinct table_name from dba_tables
        where owner=upper('$2') ${EXTRA_PRED} )
    ) where Top100 <= 100;
    -- assuming we get most distinct columns within first 100
!
exit 0
fi


if [ "$1" = "userVs" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER
  set pagesize 300
  select view_name
  from all_views
  where owner='SYS' and view_name like 'ALL%'
  order by view_name ;

!
exit 0
fi

if [ "$1" = "fixedVs" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER
  set pagesize 300
  select name
  from v\$fixed_table
  where name like 'V\$%'
  order by name;
!
exit 0
fi

if [ "$1" = "datapump_proc" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER
        set lines 150 pages 100 numwidth 7
        col program for a38
        col username for a10
        col spid for a7
        select to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') "DATE", s.program, s.sid,
               s.status, s.username, d.job_name, p.spid, s.serial#, p.pid
          from v\$session s, v\$process p, dba_datapump_sessions d
         where p.addr=s.paddr and s.saddr=d.saddr;
!
exit 0
fi

if [ "$1" = "fixedXs" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER

  set pagesize 300
  select name
  from v\$fixed_table
  where name like 'X\$%' order by name;
!
exit 0
fi

#
# Dump the stack
#
if [ "$1" = "stack" ]; then

  if [ "$2" = "" ]; then
    usage "OS pid must be specified (ora stack <os_pid>)"
  fi

  OSPID=$2

  sqlplus -s /NOLOG << ! | egrep "##" | sed -e 's/^##\(.*\)$/\1/g' > $ORA_TMP/ora

    connect $DBUSER

    set pagesize 600
    set linesize 300
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    oradebug setospid $OSPID
    rem oradebug setvar pga ksedsl 1
    rem oradebug call ksedst 0
    oradebug dump callstack 1

    column value format A200
    select unique '##'||ksppstvl value
    from x\$ksppi x, x\$ksppcv y
    where (x.indx = y.indx)
      and ksppinm in ('background_dump_dest','user_dump_dest','core_dump_dest');
!

  # no yet found
  rm -f $ORA_TMP/ora_file_res

  cat $ORA_TMP/ora | while read DIR; do

    FILE=`ls -C1 $DIR/*_${OSPID}.trc 2>/dev/null`

    if [ "$FILE" != "" ]; then
      egrep -n '\---- Call Stack Trace -----|----- End of Call Stack Trace' $FILE > $ORA_TMP/ora_file

      NB_LINES=`tail -1 $ORA_TMP/ora_file`
      if [ "$NB_LINES" != "" ]; then
        FOUND=1
        echo "$FILE" > $ORA_TMP/ora_file_res
        break;
      fi
    fi
  done

  FILE=`cat $ORA_TMP/ora_file_res`

  #
  # Dump stack
  #
  if [ "$FILE" != "" ]; then
    LINE_START=`tail -2 $ORA_TMP/ora_file | head -1 | sed -e 's/\([0-9]*\):.*/\1/g'`
    LINE_END=`tail -1 $ORA_TMP/ora_file | sed -e 's/\([0-9]*\):.*/\1/g'`

    let LINE_COUNT="LINE_END-LINE_START+1"

    echo
    echo
    head -${LINE_END} $FILE | tail -${LINE_COUNT}
    echo

  else
    echo
    echo "Trace file not found, probably os pid does not exists"
    echo
  fi
exit 0
fi


#
# Do pstack on all process
#
if [ "$1" = "pstack" ]; then

  HOST_NAME=`uname -n`

  PID=$2
  shift 2

  if [ "$1" != "" ]; then
    DIR=$1
  else
    DIR=$T_TRC
  fi

  if [ ! -d $DIR ]; then
    usage "Directory $DIR does not exists"
  fi

  if [ "$ORACLE_SID" = "" ]; then
    usage "ORACLE_SID must be defined"
  fi

  if [ "$PID" = "all" ]; then
    ps -edf | egrep "ora_[a-z0-9]*_${ORACLE_SID}|oracle${ORACLE_SID}" | grep -v egrep | while read a; do
      set $a

      PID=$2

      TARGET_FILE="$DIR/pstack_${PID}_${HOST_NAME}.trc"

      echo >> $TARGET_FILE
      CURDATE=`date +"%T (%D)"`
      echo "######################## $CURDATE ########################" >> $TARGET_FILE

      pstack $PID >> $TARGET_FILE 2> /dev/null
      echo >> $TARGET_FILE

    done

    CURDATE=`date +"%T (%D)"`
    echo "pstack_all completed for all process at $CURDATE"

  else

    pstack $PID
    echo
  fi

  exit 0
fi


#
# Get system state dump and place result in specified directory
#
if [ "$1" = "system_state" ]; then

  shift
  if [ "$1" != "" ]; then
    DIR=$1
  else
    DIR=$T_TRC
  fi

  if [ ! -d $DIR ]; then
    usage "Directory $DIR does not exists"
  fi

  CURDATE=`date +"%T_%m|%d"`
  HOST_NAME=`uname -n`

  sqlplus -s /NOLOG << ! | egrep "##" | sed -e 's/^##\(.*\)$/\1/g' > $ORA_TMP/ora$$

    connect $DBUSER

    set pagesize 600
    set linesize 300
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    alter session set events 'immediate trace name systemstate level 266';

    select '##'||VALUE || '/${ORACLE_SID}_ora_'|| spid ||'.trc' file_name
    from v\$parameter, v\$process
    where name = 'user_dump_dest' and pid=userenv('pid');
!

    FILE=`cat $ORA_TMP/ora$$`
    rm -f $ORA_TMP/ora$$
    mv $FILE "$DIR/sysstate_${CURDATE}_${HOST_NAME}.trc"

    echo "System state file 'sysstate_$CURDATE.trc' successfully produced"
  exit 0
fi


if [ "$1" = "px_processes" ]; then
  #
  # This query was donated by Patrick
  #

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"

    connect $DBUSER
    set linesize 150
    col "Wait Event" format a30
    col SPID format A10

    select px.SID "SID",
           p.PID,
           p.SPID "SPID",
           px.INST_ID "Inst",
           px.SERVER_GROUP "Group",
           px.SERVER_SET "Set",
           px.DEGREE "Degree",
           px.REQ_DEGREE "Req Degree",
           w.event "Wait Event"
    from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p, GV\$SESSION_WAIT w
    where s.sid (+) = px.sid and
          s.inst_id (+) = px.inst_id and
          s.sid = w.sid (+) and
          s.inst_id = w.inst_id (+) and
          s.paddr = p.addr (+) and
          s.inst_id = p.inst_id (+)
    ORDER BY decode(px.QCINST_ID,  NULL, px.INST_ID,  px.QCINST_ID),
             px.QCSID,
             decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
             px.SERVER_SET,
             px.INST_ID;
!

  exit 0
fi


if [ "$1" = "cursor_summary" ] || [ "$1" = "pinned_cursors" ]; then
  #
  # This query summarizes information about pinned/locked/unpinned cursors
  # and their sizes
  #

  create_format_functions

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"

    connect $DBUSER

    set echo off
    set lines 100
    set pages 200

    column curtyp           heading curtyp      format a6 truncate
    column lmd              heading lmd         format a2
    column pmd              heading pmd         format a2
    column pc               heading pc          format a3
    column tot              heading total       format a5
    column cnt              heading count       format a5

    column sum_heap0        heading sum0        format a5
    column sum_heap4        heading sum4        format a5
    column sum_heap6        heading sum6        format a5

    column cnt_heap0        heading cnt0        format a5
    column cnt_heap4        heading cnt4        format a5
    column cnt_heap6        heading cnt6        format a5

    column avg_heap0        heading avg0        format a5
    column avg_heap4        heading avg4        format a5
    column avg_heap6        heading avg6        format a5

    column max_heap0        heading max0        format a5
    column max_heap4        heading max4        format a5
    column max_heap6        heading max6        format a5

    select /* ora pinned_cursors */
           case
             when pc = 'PAR' and lmd = '0' and pmd = '0' then
               'Parent Freeable'
             when pc = 'PAR' and lmd = 'N' and pmd = '0' then
               'Parent Inuse'
             when pc = 'CHI' and lmd = '0' and pmd = '0' then
               'Child Freeable'
             when pc = 'CHI' and lmd = '0' and pmd = 'S' then
               'Pseudo Cursor '
             when pc = 'CHI' and lmd = 'N' and pmd = '0' then
               'Child Cached'
             when pc = 'CHI' and lmd = 'N' and pmd = 'S' then
               'Child Executing'
             else
               'Not Sure'
           end cursor_type,
           pc, lmd, pmd,
           $FORMAT_NUMBER(count(*))           cnt,
           $FORMAT_SIZE(sum(tot))      tot,
           $FORMAT_SIZE(count(decode(KGLOBHS0, 0, NULL, KGLOBHS0))) cnt_heap0,
           $FORMAT_SIZE(count(decode(KGLOBHS6, 0, NULL, KGLOBHS6))) cnt_heap6,
           $FORMAT_SIZE(sum(KGLOBHS0)) sum_heap0,
--           $FORMAT_SIZE(sum(KGLOBHS4)) sum_heap4,
           $FORMAT_SIZE(sum(KGLOBHS6)) sum_heap6,
           $FORMAT_SIZE(avg(KGLOBHS0)) avg_heap0,
--         $FORMAT_SIZE(avg(KGLOBHS4)) avg_heap4,
           $FORMAT_SIZE(avg(KGLOBHS6)) avg_heap6,
           $FORMAT_SIZE(max(KGLOBHS0)) max_heap0,
--           $FORMAT_SIZE(max(KGLOBHS4)) max_heap4,
           $FORMAT_SIZE(max(KGLOBHS6)) max_heap6
    from (
            select KGLOBHS0,
                   KGLOBHS4,
                   KGLOBHS6,
                   kglobhs0+kglobhs4+kglobhs6 tot,
                   decode(kglhdadr, kglhdpar, 'PAR', 'CHI') pc,
                   decode(kglhdlmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') lmd,
                   decode(kglhdpmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') pmd,
                   case
                      when KGLOBT09 = 65535 then
                            '0 PAR'
                      when KGLHDLMD = 1 and KGLHDPMD > 0 then
                            '1 PN CHI'
                      when KGLHDLMD = 1 then
                            '2 LK CHI'
                      else
                            '3 CHI'
                   end cursor_type
            from x\$kglcursor)
    group by pc, lmd, pmd
    order by pc desc, lmd, pmd
    ;

!

##  $ORA_PROG $ARGS -pred "pin_mode = 'S'" cur_mem all

  exit 0
fi


if [ "$1" = "rowcache" ]; then
  #
  # This query summarizes information about row cache objects
  #

  create_format_functions

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"

    connect $DBUSER

    set echo off
    set lines 80
    set pages 200

    column cache_name format a30 trunc
    column subcache_name format a30 trunc

    select $INST_ID parameter, count
    from $V\$rowcache
    order by 1,2;

    select $INST_ID cache_name, lock_mode, lock_request, count(*)
    from $V\$rowcache_parent
    group by $INST_ID cache_name, lock_mode, lock_request
    order by $INST_ID cache_name, lock_mode, lock_request;

    select $INST_ID cache#, subcache_name, existent, count(*)
    from $V\$rowcache_subordinate rs
    group by $INST_ID cache#, subcache_name, existent
    order by $INST_ID cache#, subcache_name, existent;
!

  exit 0
fi


if [ "$1" = "gplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  setup_hash_value hash_value sql_id $2 $3
  shift $SHIFT_PARAM

  sqlplus -s /NOLOG << ! | grep '###' | sed -e 's/^###\(.*\)$/\1/g' > $ORA_TMP/oraout$$

    connect $DBUSER

    set pagesize 6000
    set linesize 100
    set tab off
    col address format A15
    col sql_hash format A15
    col exec format 9999
    col sql_text format A75 WORD_WRAP

create or replace procedure todot(d_rwo in number)
is
  lvalue   varchar2(100);
  distr    varchar2(32);
  dfoname  varchar(32);
  rv       varchar2(4000);
  id       number;
  pid      number;
  dfonumber  number;
  cdfo     number;
  cpxid    number;
  pxid     number;
  mpxid    number;

  cursor nodes is
    select 'n_' || id ||
           '[label="' || operation ||  decode(object_name,'','','('||object_name||')') || '"];'
    from v\$sql_plan
    where id > 0 and $COLNAME = $HVAL and child_number = $CNUM;

  cursor edges is
    select parent_id, id, distribution
    from v\$sql_plan
    where id > 0 and $COLNAME = $HVAL and child_number = $CNUM;

  cursor rwo is
    select id, regexp_replace(regexp_replace(regexp_replace(projection,',[[:digit:]]+',''),'"',''),',','|')
    from v\$sql_plan
    where id > 0 and $COLNAME = $HVAL and child_number = $CNUM;

  cursor dfos is
    select id, to_number(substr(object_node, 3,1)) pxid, to_number(substr(object_node, 4)) dfo
    from v\$sql_plan
    where id > 0 and $COLNAME = $HVAL and child_number = $CNUM and
          object_node is not null
    order by pxid, dfo;

begin
  dbms_output.put_line('### digraph G {');
  dbms_output.put_line('### graph [fontsize=12 labeljust=l];');
  dbms_output.put_line('### edge [arrowhead=none arrowtail=normal fontsize=8];');
  dbms_output.put_line('### node [shape=ellipse fontsize=8];');


  SELECT max(to_number(substr(object_node, 3,1))) INTO mpxid FROM plan_table;

  cdfo := -1;
  cpxid := -1;
  open dfos;
  loop
    fetch dfos into id, pxid, dfonumber;
    EXIT WHEN dfos%NOTFOUND;

    if ( (cdfo != dfonumber) or (pxid != cpxid) )then
      if (cdfo != -1) then
        dbms_output.put_line('### }');
      end if;
      if (mpxid > 1) then
        dfoname := 'DFO ' || (1000 * pxid + dfonumber);
      else
        dfoname := 'DFO ' || dfonumber;
      end if;
      dbms_output.put_line('### subgraph "cluster_dfo_' || (pxid*1000 + dfonumber) || '" { label = "' || dfoname || '";');
      cdfo := dfonumber;
      cpxid := pxid;
    end if;

    dbms_output.put_line('### n_' || id || ';');

  end loop;
  close dfos;

  if (cdfo != -1) then
    dbms_output.put_line('### }');
  end if;

  open nodes;
  loop
    fetch nodes into lvalue;
    EXIT WHEN nodes%NOTFOUND;
    dbms_output.put_line('### '|| lvalue);
  end loop;
  close nodes;

  if (d_rwo = 1) then
    open rwo;
    loop
      fetch rwo into id, rv;
      EXIT WHEN rwo%NOTFOUND;
      dbms_output.put_line('### rwo_' || id || '[label="' || rv || '"];');
      dbms_output.put_line('### n_'|| id || '->' || 'rwo_' || id || ';');
    end loop;
    close rwo;
  end if;

  open edges;
  loop
    fetch edges into pid, id, distr;
    EXIT WHEN edges%NOTFOUND;
    if (pid != 0) then
      if (distr is null) then
        dbms_output.put_line('### n_'|| pid || '->' || 'n_' || id || ';');
      else
        dbms_output.put_line('### n_'|| pid || '->' || 'n_' || id || '[label="'|| distr || '"];');
      end if;
    end if;
  end loop;
  close edges;


  dbms_output.put_line('### }');

end todot;
/
show errors;

    set serveroutput on
    call todot(0);
!
    dotty  $ORA_TMP/oraout$$
exit 0
fi


if [ "$1" = "webplan" ]; then

  if [ "$2" = "" ]; then
    usage "Cursor hash value is missing"
  fi

  setup_hash_value hash_value sql_id $2
  shift $SHIFT_PARAM

  if [ "$2" = "" ]; then
    DECORATE=0
  else
    DECORATE=$2
  fi

  sqlplus -s /NOLOG <<EOF  | grep '###' | sed -e 's/^###\(.*\)###$/\1/g' > $ORA_TMP/oragdlpre-$$

    set echo off heading off feedback off
    connect $DBUSER

    select distinct '###' || hash_value || '###' from v\$sql where $COLNAME=$HVAL;
    exit;

EOF
    GDLHASH=`cat $ORA_TMP/oragdlpre-$$`
    rm -f $ORA_TMP/oragdlpre-$$

  if [ "$GDLHASH" = "" ]; then
    print "Cursor hash value is absent in cursor cache"
    exit 1;
  fi


# Quick check to save recompiling procedures.

sqlplus -s /NOLOG <<EOF | grep 'ORA-'  > /dev/null  2>&1
    connect $DBUSER

    call ora_togdl(0,0,0) ;
EOF

## procedure does not exist,so compile it first time
 if [ $? = 0 ]; then

  sqlplus -s /NOLOG << !  > $ORA_TMP/oragdlpre$$ 2>&1

    connect $DBUSER

    set pagesize 6000
    set linesize 4400
    set tab off
    col address format A15
    col sql_hash format A15
    col exec format 9999
    col sql_text format A75 WORD_WRAP

create or replace procedure ora_print_edge(pid in number, id in number, distribution in varchar2)
is
begin
  dbms_output.put_line('### edge: {');
  dbms_output.put_line('###   source:"n_' || pid || '"');
  dbms_output.put_line('###   target:"n_' || id  || '"');
  if (distribution is not null) then
    dbms_output.put_line('###   label:"' || distribution || '"');
  end if;
  dbms_output.put_line('###   color:red');
  dbms_output.put_line('### }');
end ora_print_edge;
/
show errors;

create or replace procedure ora_print_node(decorate in number, pxid in number, dfo in number, id in number,
                                       position in number, label in varchar2,
                                       cost in number, cpu_cost in number, io_cost in number, access_pred in varchar2,
                                       card in number, bytes in number, temp_space in number, filter_pred in varchar2,
                                       projection in varchar2)
is
  newline boolean;
  color1 number;
  color2 number;
begin
  newline := FALSE;
  dbms_output.put_line('### node: {');
  dbms_output.put_line('###   title:"n_' || id || '"');
  if (decorate <> 0 ) then
    dbms_output.put('###   label:"\fu\fb ' || id || ' : '  || label || '\fn\n');

    if (cost is not null) then
      dbms_output.put('cost:\f02' || cost || '\f31');
      newline := TRUE;
    end if;

    if (cpu_cost is not null) then
      dbms_output.put(',cpu_cost:\f02' || cpu_cost || '\f31');
      newline := TRUE;
    end if;

    if (io_cost is not null) then
      dbms_output.put(',io_cost:\f02' || io_cost || '\f31');
      newline := TRUE;
    end if;

    if (card is not null) then
     if (newline = TRUE) then
      dbms_output.put('\n');
     end if;
     dbms_output.put('card:\f02' || card || '\f31');
     newline := TRUE;
   end if;

   if (bytes is not null) then
     dbms_output.put(',bytes:\f02' || bytes || '\f31');
     newline := TRUE;
   end if;

   if (temp_space is not null) then
     dbms_output.put(',temp_space:\f02' || temp_space || '\f31');
     newline := TRUE;
   end if;

   if (access_pred is not null) then
     if (newline = TRUE) then
      dbms_output.put('\n');
     end if;
     dbms_output.put('access (' || access_pred || ')');
     newline := TRUE;
   end if;

   if (filter_pred is not null) then
     if (newline = TRUE) then
      dbms_output.put('\n');
     end if;
     dbms_output.put('filter: (' || filter_pred || ')');
     newline := TRUE;
   end if;

   if (decorate = 2) then
     if (projection is not null) then
       if (newline = TRUE) then
        dbms_output.put('\n');
       end if;
       dbms_output.put('projection: ' || projection);
       newline := TRUE;
     end if;
   end if;

  dbms_output.put_line('"');
  else
    dbms_output.put_line('###   label:"' || label || '"');
  end if;
  dbms_output.put_line('###   horizontal_order:' || id );
  dbms_output.put_line('###   shape:ellipse');

  if (pxid is null) then
   color1 := 0;
   color2 := 0;
  else
    color1 := 13 + pxid;
    color2 := 23 + pxid;
  end if;

  if (mod(dfo,2) = 0) then
    dbms_output.put_line('###   color :' || color1);
  else
    dbms_output.put_line('###   color :' || color2);
  end if;

  dbms_output.put_line('### }');
  dbms_output.put_line('###');
end ora_print_node;
/

create or replace procedure ora_print_graph_prolog(dfonumber in number, pxid in number)
is
  dfoname  varchar(100);
  color1   number;
  color2   number;
begin
  if (pxid > 1) then
    dfoname := 'PX:' || pxid || ':DFO ' || dfonumber;
  else
    dfoname := 'DFO ' || dfonumber;
  end if;

  dbms_output.put_line('###graph: {');
  dbms_output.put_line('###   title   :"' || dfoname || '"');
  dbms_output.put_line('###   label   :"' || dfoname || '"');
  dbms_output.put_line('###   status  :clustered');
  dbms_output.put_line('###   shape  :triangle');

  color1 := 13 + pxid;
  color2 := 23 + pxid;

  if (mod(dfonumber,2) = 0) then
    dbms_output.put_line('###   color :' || color1);
  else
    dbms_output.put_line('###   color :' || color2);
  end if;
  dbms_output.put_line('###');
end ora_print_graph_prolog;
/

create or replace procedure ora_print_graph_epilog
is
begin
 dbms_output.put_line('### }');
end ora_print_graph_epilog;
/

create or replace procedure ora_print_topgraph_properties(complexity in number)
is
begin
  dbms_output.put_line('###graph: {');
  dbms_output.put_line('###   display_edge_labels: yes');
  dbms_output.put_line('###   fontname: "timR"');
  dbms_output.put_line('###   edge.arrowstyle:none');
  dbms_output.put_line('###   layoutalgorithm:dfs');

  -- complicated parallel trees, need some finetuning.

  if (complexity > 3) then
    dbms_output.put_line('###   equal_y_dist: yes');
    dbms_output.put_line('###   layout_downfactor: 100');
    dbms_output.put_line('###   layout_upfactor: 0');
    dbms_output.put_line('###   layout_nearfactor: 10');
    dbms_output.put_line('###   dirty_edge_labels: yes');
    dbms_output.put_line('###   manhattan_edges: yes');
  else
    dbms_output.put_line('###   splines:yes');
    dbms_output.put_line('###   xspace: 10');
    dbms_output.put_line('###   manhattan_edges: yes');
  end if ;

  dbms_output.put_line('###');
end ora_print_topgraph_properties;
/

create or replace procedure ora_togdl (sql_hash in number, cnum in number, decorate in number)
is
  label    varchar2(100);
  distr    varchar2(100);
  id       number;
  pid      number;
  pxid     number;
  position number;
  cdfo     number;
  cpxid    number;
  dfonumber  number;
  cost     number;
  cpu_cost     number;
  io_cost     number;
  access_pred   varchar2(4000);
  filter_pred    varchar2(4000);
  projection    varchar2(4000);
  card    number;
  bytes    number;
  temp_space    number;
  complexity  number;

  cursor edge is
    select parent_id, id, lower(distribution) || case other_tag
                                          when 'PARALLEL_TO_PARALLEL' then '  P->P  '
                                          when 'PARALLEL_TO_SERIAL'   then '  P->S  '
                                          when 'PARALLEL_FROM_SERIAL' then '  S->P  '
                                          else '' end
    from v\$sql_plan
    where  id >0 and
     hash_value   =  sql_hash
     and  child_number = cnum;

  cursor node is
    select id,
      to_number(substr(object_node, 3,1)) pxid,
      to_number(substr(object_node, 4)) dfo,
      position position,
      lower(operation) || ' ' || lower(options)  || nvl2(object_name, '(' ||
                        nvl2(object_owner, object_owner || '.' ,'') ||
                     object_name  ||
                     nvl2(object_alias, ' ' ||
                     regexp_replace(object_alias, '(@.*)', '') , '') || ')', '')  label,
      cost,
      cpu_cost,
      io_cost,
      replace(access_predicates, '"',''),
      cardinality,
      bytes,
      temp_space,
      replace(filter_predicates, '"',''),
      replace(projection, '"','')
    from v\$sql_plan
    where hash_value   =  sql_hash
     and  child_number = cnum
    order by pxid desc, dfo desc, id;

begin
  if (sql_hash = 0) then
    return;
  end if;

  select max(nvl(to_number(substr(object_node, 4)), 0)) into complexity
  from v\$sql_plan
  where hash_value  = sql_hash
  and  child_number = cnum;

  ora_print_topgraph_properties(complexity);

  cdfo := -1;
  cpxid := -1;

  open node;
  loop
    fetch node into id, pxid, dfonumber, position,label,cost,cpu_cost,io_cost, access_pred, card, bytes, temp_space,
                    filter_pred, projection;
    EXIT WHEN node%NOTFOUND;

    if ( (cdfo != dfonumber) or (pxid != cpxid) ) then
      if (cdfo != -1) then
        ora_print_graph_epilog;
      end if;

      ora_print_graph_prolog(dfonumber, pxid);

      cdfo  := dfonumber;
      cpxid := pxid;
    end if;

    ora_print_node(decorate, pxid, dfonumber,id, position,label, cost, cpu_cost, io_cost, access_pred, card, bytes,
               temp_space, filter_pred, projection);

  end loop;
  close node;

  if (cdfo != -1) then
    ora_print_graph_epilog;
  end if;

  open edge;
  loop
    fetch edge into pid, id, distr;
    EXIT WHEN edge%NOTFOUND;

    ora_print_edge(pid, id, distr);

  end loop;
  close edge;


  ora_print_graph_epilog;

end ora_togdl;
/
show errors;

!
  rm -f $ORA_TMP/oragdlpre$$
fi
### All procedures compiled, now ready for graph generation.
  sqlplus -s /NOLOG << ! | grep '###' | sed -e 's/^###\(.*\)$/\1/g' > $ORA_TMP/oragdl$$

    connect $DBUSER

    set pagesize 6000
    set linesize 4400
    set tab off


    set serveroutput on
    call ora_togdl($GDLHASH, $CNUM, $DECORATE);
!

# Convert gdl file to png, and show it on the browser

$RENDER  -lm 0px -tm 0px -scale 100 -pngoutput $ORA_TMP/oraXpl$$.png -htmloutput $ORA_TMP/oraXpl$$.html $ORA_TMP/oragdl$$  > /dev/null 2>&1
$BROWSER  $ORA_TMP/oraXpl$$.png
## SVG/Javascript/clickable nodes  sometime later...
#$RENDER -svgoutput $ORA_TMP/oraXpl$$.svg $ORA_TMP/oragdl$$
#$BROWSER  $ORA_TMP/oraXpl$$.svg
rm -f $ORA_TMP/oragdl$$
rm -f $ORA_TMP/oraXpl$$.html
exit 0
fi

if [ "$1" = "monitor_list" ]; then

  sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

  connect $DBUSER

  set echo on
  set linesize 180
  set pages 6000

  col sql_text format A80 wrap
  select m.sql_id, sql_exec_id, round(m.elapsed_time/1000000) "Elapsed(s)",
         round(m.CPU_TIME/1000000) "Cpu(s)", sql_text
  from v\$sql_monitor m, v\$sql s
  where m.SQL_ID = s.SQL_ID
    and m.SQL_CHILD_ADDRESS = s.CHILD_ADDRESS
    and m.PX_SERVER# is null
  order by SQL_EXEC_START;
!
  exit 0
fi


if [ "$1" = "monitor" ]; then

  shift 1

  if [ "$1" = "xml" ]; then
    ARGS=", type=>'XML'"
    shift
  elif [ "$1" = "html" ]; then
    ARGS=", type=>'HTML'"
    shift
  elif [ "$1" = "active" ]; then
    ARGS=", type=>'ACTIVE'"
    shift
  else
    ARGS=""
  fi

  SQLID="'$1'"

  #
  # Check if sql_id
  #
  if [ ${#SQLID} -eq 15 ]; then
    ARGS="sql_id=>'$1' $ARGS"
  else
    ARGS="$* $ARGS"
  fi

  sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

  connect $DBUSER

  set echo on
  set linesize 300
  set pages 50000
  set long 200000000
  set longchunksize 20000000

  alter session set time_zone = '+00:00';
  select dbms_sqltune.report_sql_monitor($ARGS) Monitor_report from dual;
!
  exit 0
fi


if [ "$1" = "monitor_old" ]; then

  if [ "$2" = "ash_all" ]; then
    shift

    #
    # Use all rows from ash for the execution of that statement. This way, with
    # short running queries, we would get more ash samples
    #
    ASH_JOIN_COLUMN_OUTER="sql_id, sql_plan_hash_value"
    ASH_JOIN_COLUMN_INNER="ma.sql_id, ma.sql_plan_hash_value"

  else
    #
    # Only use ash samples for the specified target
    #
    ASH_JOIN_COLUMN_OUTER="sql_id, session_id, sql_exec_start, sql_exec_id,
                           sql_plan_hash_value"
    ASH_JOIN_COLUMN_INNER="ma.sql_id, ma.sid, ma.SQL_EXEC_START, ma.SQL_EXEC_ID,
                           ma.sql_plan_hash_value"
  fi

  if [ "$2" = "" -o "$2" = "qc" -o "$2" = "1" -o "$2" = "2" ]; then
    PRED=" sql_id = (select unique sql_id
                     from v\$sql_monitor
                     where
          to_char(sql_exec_start,'YY:MM:DD:HH24:MI:SS:')||
          to_char(sql_exec_id, '0000000000') =
                  (select  max(to_char(sql_exec_start,'YY:MM:DD:HH24:MI:SS:')||
                               to_char(sql_exec_id, '0000000000'))
                            from v\$sql_monitor))";
    EXTRA_PRED=" and 1=1"

  else

    SQLID="'$2'"
    HASHVAL=$2

    shift

    #
    # Check if numeric hash
    #
    if [ ${#SQLID} -eq 15 ]; then
      PRED="sql_id = $SQLID"
    else
      PRED="hash_value = $HASHVAL"
    fi
  fi

  EXTRA_PRED=" and 1=1";
  if [ "$2" != "" ]; then
    if [ "$2" = "qc" ]; then
      EXTRA_PRED=" and PX_SERVER_GROUP is NULL"
    else
      EXTRA_PRED="$EXTRA_PRED and PX_SERVER_GROUP=$2"
    fi
    if [ "$3" != "" ]; then
      EXTRA_PRED="$EXTRA_PRED and PX_SERVER_SET=$3"
    fi
    if [ "$4" != "" ]; then
      EXTRA_PRED="$EXTRA_PRED and PX_SERVER#=$4"
    fi
  fi

  sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

  connect $DBUSER

  set echo on
  set linesize 300
  set pages 6000

  var sqlid varchar2(13)

  begin
    select unique sql_id into :sqlid
    from v\$sqlarea
    where $PRED ;
  end;
  /

  with
    monattr as (select unique SQL_ID, SQL_EXEC_START, SQL_EXEC_ID
    from v\$sql_monitor
    where sql_id = :sqlid and
          to_char(sql_exec_start,'YY:MM:DD:HH24:MI:SS:')||
          to_char(sql_exec_id, '0000000000') =
                    (select  max(to_char(sql_exec_start,'YY:MM:DD:HH24:MI:SS:')||
                                 to_char(sql_exec_id, '0000000000'))
                            from v\$sql_monitor
                            where sql_id = :sqlid))
  select SQL_ID, STATUS, PX_SERVER_GROUP slave_grp,
         PX_SERVER_SET slave_set, PX_SERVER# slave#,
         round(CPU_TIME/1000000) "Cpu (s)",
         round(ELAPSED_TIME/1000000) "Elapsed (s)", DISK_READS "IO Reads",
         DIRECT_WRITES "IO Writes"
  from gv\$sql_monitor
  where (sql_id, SQL_EXEC_START, SQL_EXEC_ID) in
                 (select sql_id, SQL_EXEC_START, sql_exec_id from monattr)
        $EXTRA_PRED
  order by 1, slave_grp nulls first, slave_set, slave#;


  set linesize 300

  col Operation format A60 wrap
  col id format 999
  col "Starts#" format A9
  col "Rows#" format A9
  col "Cpu(%)" format 999
  col "IO(%)" format 999
  col "Tot(%)" format 999
  col "Wait(%)" format 999
  col "Prog(%)" format A7

  with
    monattr as (select KEY, SQL_ID, SID, SQL_EXEC_START, SQL_EXEC_ID,
                       SQL_PLAN_HASH_VALUE
                from gv\$sql_monitor
                where sql_id = :sqlid $EXTRA_PRED and
                   to_char(sql_exec_start,'YY:MM:DD:HH24:MI:SS:')||
                   to_char(sql_exec_id, '0000000000') =
                  (select  max(to_char(sql_exec_start,'YY:MM:DD:HH24:MI:SS:')||
                               to_char(sql_exec_id, '0000000000'))
                            from v\$sql_monitor
                            where sql_id = :sqlid))
  select case when active_sec is NULL then NULL
              when active_sec < 5 then 'X'
              else '.'
         end s,
         line_id Id,
         op "Operation",
         decode(nbstarts, 0, NULL, nbstarts) "Starts#",
         decode(nbstarts, 0, NULL, nbrows)  "Rows#",
         decode(percent, 0, NULL, percent) "Prog(%)",
         mem "Mem (KB)", spill "Spill (KB)",
         case when cpu_20 = 0 and io_20 = 0 and wait_20 = 0 then '|.'
              when cpu_20 > io_20 and cpu_20 > wait_20 then '|cpu'
              when cpu_20 < io_20 and io_20 > wait_20 then '|io'
              else '|wait' end t20,
         case when cpu_40 = 0 and io_40 = 0 and wait_40 = 0 then '.'
              when cpu_40 > io_40 and cpu_40 > wait_40 then 'cpu'
              when cpu_40 < io_40 and io_40 > wait_40 then 'io'
              else 'wait' end t40,
         case when cpu_60 = 0 and io_60 = 0 and wait_60 = 0 then '.'
              when cpu_60 > io_60 and cpu_60 > wait_60 then 'cpu'
              when cpu_60 < io_60 and io_60 > wait_60 then 'io'
              else 'wait' end t60,
         case when cpu_80 = 0 and io_80 = 0 and wait_80 = 0 then '.'
              when cpu_80 > io_80 and cpu_80 > wait_80 then 'cpu'
              when cpu_80 < io_80 and io_80 > wait_80 then 'io'
              else 'wait' end t80,
         case when cpu_100 = 0 and io_100 = 0 and wait_100 = 0 then '.   |'
              when cpu_100 > io_100 and cpu_100 > wait_100 then 'cpu |'
              when cpu_100 < io_100 and io_100 > wait_100 then 'io  |'
              else 'wait|' end t100,
         round((cpu+io+wait) * 100 / total_cnt) "Tot(%)",
         round(cpu * 100 / total_cnt) "Cpu(%)",
         round(io * 100 / total_cnt) "IO(%)",
         round(wait * 100 / total_cnt) "Wait(%)"
  from
    (select line_id, op, nbrows, nbstarts, mem, spill,
            case when max(ala) is null and max(plc) is NULL then NULL
            else ((case when max(status) like 'DONE%' then sysdate
                             else max(last_refresh_time)
                        end) -
                  (case when max(ala) is NULL then max(plc)
                        when max(plc) is NULL then max(ala)
                        when max(ala) > max(plc) then max(ala) else max(plc)
                   end)) * 3600 * 24
            end active_sec,
     max(total_cnt) total_cnt,
     sum(case when class = 'CPU' then cnt else 0 end) cpu,
     sum(case when class = 'IO'  then cnt else 0 end) io,
     sum(case when class = 'WAIT' then cnt else 0 end) wait,
     sum(case when class = 'CPU' and period = 20 then cnt else 0 end) cpu_20,
     sum(case when class = 'IO' and period = 20 then cnt else 0 end) io_20,
     sum(case when class = 'WAIT' and period = 20 then cnt else 0 end) wait_20,
       sum(case when class = 'CPU' and period = 40 then cnt else 0 end) cpu_40,
       sum(case when class = 'IO' and period = 40 then cnt else 0 end) io_40,
       sum(case when class = 'WAIT' and period = 40 then cnt else 0 end) wait_40,
       sum(case when class = 'CPU' and period = 60 then cnt else 0 end) cpu_60,
       sum(case when class = 'IO' and period = 60 then cnt else 0 end) io_60,
       sum(case when class = 'WAIT' and period = 60 then cnt else 0 end) wait_60,
       sum(case when class = 'CPU' and period = 80 then cnt else 0 end) cpu_80,
       sum(case when class = 'IO' and period = 80 then cnt else 0 end) io_80,
       sum(case when class = 'WAIT' and period = 80 then cnt else 0 end) wait_80,
       sum(case when class = 'CPU' and period = 100 then cnt else 0 end) cpu_100,
       sum(case when class = 'IO' and period = 100 then cnt else 0 end) io_100,
      sum(case when class = 'WAIT' and period = 100 then cnt else 0 end) wait_100
    from (
      select p.period, p.class, p.line_id, p.op, p.nbstarts, p.nbrows, p.mem,
             p.spill, a.cnt, a.total_cnt, a.ash_active_date ala,
             p.last_change_time plc, p.last_refresh_time, p.status
      from
        (select p.period, c.stype class, p.line_id, p.op, m.nbrows,
                m.nbstarts, m.mem, m.spill, m.last_change_time,
                m.last_refresh_time, m.status
         from
           (select unique decode(depth, 0, '', lpad(' ', depth, ' '))||
                  OPERATION ||
                  decode(OPTIONS, null, '', ' '||OPTIONS) ||
                  decode(OBJECT_NAME, null, '', ' ('|| OBJECT_NAME || ')') op,
                             id line_id
             from   v\$sql_plan pl
             where  (sql_id, plan_hash_value) =
                              (select unique ma.sql_id, ma.sql_plan_hash_value
                               from monattr ma)) p,
           (select max(status) status, plan_line_id line_id,
                   sum(OUTPUT_ROWS) nbrows, sum(STARTS) nbstarts,
                   round(sum(workarea_mem)/1024) mem,
                   round(sum(workarea_tempseg)/1024) spill,
                   max(last_refresh_time) last_refresh_time,
                   max(last_change_time) last_change_time
             from gv\$sql_plan_monitor
             where key in (select ma.key from monattr ma)
             group by plan_line_id) m,
          (select 'IO' stype from dual
             union all select 'CPU' stype from dual
             union all select 'WAIT' stype from dual) c,
          (            select 20 period from dual
             union all select 40 period from dual
             union all select 60 period from dual
             union all select 80 period from dual
             union all select 100 period from dual) p
         where  m.line_id = p.line_id) p,
       (select part * 20 period, line_id,
                   case when wait_class = 'System I/O'
                             or wait_class = 'User I/O'
                        then 'IO'
                        when wait_class is NULL then 'CPU'
                        else 'WAIT' end class,
                   count(*) cnt, max(total) total_cnt,
                   round(count(*)*100/max(total)) perc,
                   max(ash_active_date) ash_active_date
            from (select NTILE(5) OVER (ORDER BY sample_time) AS part,
                sql_plan_line_id line_id, wait_class, (count(*) over ()) total,
                  cast(SAMPLE_TIME as date) ash_active_date
                  from gv\$active_session_history
                  where ($ASH_JOIN_COLUMN_OUTER) in
                          (select $ASH_JOIN_COLUMN_INNER
                           from   monattr ma))
            group by part, line_id, wait_class) a
      where  a.line_id(+) = p.line_id
        and  a.class(+) = p.class
        and  a.period(+) = p.period)
    group by line_id, op, nbrows, nbstarts, mem, spill, status) mon,
    (select SQL_PLAN_LINE_ID, round(sum(sofar)*100/sum(totalwork)) percent
     from   gv\$session_longops
     where  (SQL_ID, SQL_EXEC_START, SQL_EXEC_ID) in
                         (select ma.sql_id, ma.SQL_EXEC_START, ma.SQL_EXEC_ID
                          from monattr ma)
     group by SQL_PLAN_LINE_ID) lo
    where lo.SQL_PLAN_LINE_ID(+) = line_id
  order by line_id;


!

exit 0
fi

#
# sql_task command
#
if [ "$1" = "sql_task" ]; then

  if [ "$2" = "progress" ]; then
    sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

    connect $DBUSER

    set echo on
    set linesize 180
    set pages 6000
    column cur_sqlid format a13
    column task_name format a25

    select decode(t.advisor_id, 4, 'SQL Tune', 8, 'SPA', 9, 'SQL Repair')
             adv_name, t.task_id, t.task_name, p.sofar, p.totalwork,
           max(o.attr1) keep (dense_rank last order by object_id asc) cur_sqlid
    from v\$advisor_progress p, dba_advisor_tasks t, dba_advisor_objects o
    where p.task_id = t.task_id
      and t.status = 'EXECUTING'
      and t.advisor_id in (4,8,9)
      and p.last_update_time >= t.execution_start
      and o.task_id (+) = t.task_id
      and o.type (+) = 'SQL'
    group by t.advisor_id, t.task_id, t.task_name, p.sofar, p.totalwork,
             p.start_time
    order by p.start_time;
!
    exit 0
  fi

  if [ "$2" = "interrupt" ]; then
    sqlplus -s /NOLOG  << !

    connect $DBUSER

    set echo on
    set linesize 180
    set pages 6000

    exec dbms_sqltune.interrupt_tuning_task('$3');
!
    exit 0
  fi

  if [ "$2" = "history" ]; then

    NUMEXECS=$3
    if [ "$NUMEXECS" = "" ]; then
      NUMEXECS=10
    fi

    sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

    connect $DBUSER

    set echo on
    set linesize 180
    set pages 6000
    column exec_name format a12
    column task_name format a25

    alter session set nls_date_format = 'MM/DD HH24:MI';

    select * from (
    select decode(t.advisor_id, 4, 'SQL Tune', 8, 'SPA', 9, 'SQL Repair')
             adv_name, t.task_name, e.execution_name exec_name,
           e.execution_start exec_start, e.status,
           count(*) num_sqls
    from   dba_advisor_tasks t, dba_advisor_executions e, dba_advisor_objects o
    where  t.advisor_id in (4,8,9) and o.task_id = t.task_id and
           e.task_id = t.task_id and
           nvl(o.execution_name, e.execution_name) = e.execution_name and
           o.type = 'SQL'
    group by t.task_id, t.task_name, e.execution_start, e.execution_name,
             e.status, t.advisor_id
    order by exec_start desc) where rownum <= $NUMEXECS;
!
    exit 0
  fi

  if [ "$2" = "params" ]; then

    TASK=$3
    PARAMETER=$4

    sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

    connect $DBUSER

    set echo on
    set linesize 180
    set pages 6000
    column exec_name format a12
    column exec_param_value format a30
    column task_param_value format a30
    column task_name format a25

    alter session set nls_date_format = 'MM/DD HH24:MI';

    select execution_name exec_name, parameter_name,
           parameter_value exec_param_value
    from dba_advisor_exec_parameters
    where task_name = '$TASK' and
          nvl('$PARAMETER', parameter_name) = parameter_name;

    select parameter_name, parameter_value task_param_value
    from dba_advisor_parameters
    where task_name = '$TASK' and
          nvl('$PARAMETER', parameter_name) = parameter_name;
!

    exit 0
  fi

  if [ "$2" = "report" ]; then

    SECTION="$4"
    if [ "$SECTION" = "" ]; then
      SECTION="ALL"
    fi

    sqlplus -s /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully"

    connect $DBUSER

    set echo on
    set linesize 180
    set pages 6000
    set long 1000000000 longchunksize 1000

    select dbms_sqltune.report_tuning_task('$3', 'TEXT', 'ALL', '$SECTION',
                                           null, null, null, '$5')
    from dual;
!

    exit 0
  fi

fi


if [ "$1" = "session_trace" ]; then
                        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                        connect $DBUSER
                        set pagesize 6000
                        set linesize 120
                        SELECT s.sid,
                               s.server,
                               lower(
                                 CASE
                                   WHEN s.server IN ('DEDICATED','SHARED') THEN
                                     i.instance_name || '_' ||
                                     nvl(pp.server_name, nvl(ss.name, 'ora')) || '_' ||
                                     p.spid || '.trc'
                                   ELSE NULL
                                 END
                               ) AS trace_file_name
                        FROM v\$instance i,
                             v\$session s,
                             v\$process p,
                             v\$px_process pp,
                             v\$shared_server ss
                        WHERE s.paddr = p.addr
                        AND s.sid = pp.sid (+)
                        AND s.paddr = ss.paddr(+)
                        AND s.type = 'USER'
                        ORDER BY s.sid;
!
exit 0
fi

if [ "$1" = "rman_fullrestore_scripts" ]; then
  if [ "$2" = "" ]; then
    usage "Dest_dbfile_dir is missing"
  fi

  sqlplus -s  /NOLOG  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
  connect $DBUSER
  set linesize 1000
  set trimspool on
  set pagesize 0
   select '[ sourcehost ] rman target /' scripts
     from dual
   union all
   select 'RMAN> backup database plus archivelog;' scripts
     from dual
   union all
   select '[ desthost ] cd $ORACLE_HOME/dbs' scripts
     from dual
   union all
   select 'orapwd file=orapw' || instance_name || ' password=oracle' scripts
     from v\$instance
   union all
   select 'rman target /' scripts
     from dual
   union all
   select 'RMAN> set DBID=' || to_char(dbid) scripts
     from v\$database
   union all
   select 'RMAN> restore controlfile from '''';' scripts
     from dual
   union all
   select 'SQL> alter database mount;' scripts
     from dual
   union all
   select 'RMAN> run {' || chr(10) scripts
     from dual
   union all
   select *
     from (select '  set newname for datafile ' || to_char(FILE_ID) ||
                  ' to '''||'$2'||'/'||lower(tablespace_name)|| '' || to_char(file_id,'FM00000') || '.dbf'';' scripts
             from dba_data_files
            order by file_id)
   union all
   select '  restore database;' || chr(10) || '  switch datafile all;' ||
          chr(10) || '  recover database;' || chr(10) || '}' scripts
     from dual
   union all
   select 'SQL>' scripts
     from dual
   union all
   select *
     from (select 'alter database rename file ''' || member || ''' to ''' ||
                  '$2' || '/redo' ||
                  to_char(group#,'FM00000') || '.log'';' scripts
             from v\$logfile
            order by group#)
   union all
   select 'alter database open resetlogs; ' || chr(10) ||
          'create temporary tablespace temp1 tempfile ''' ||
          '$2' || '/temp0001.dbf'' size 200M;' || chr(10) ||
          'alter database default temporary tablespace temp1;' || chr(10) ||
          'drop tablespace temp including contents and datafiles;'
     from dual
   union all
   select '----Archivelog Mode' || chr(10) ||
          'select thread#,group#,sequence#,bytes,status,archived from v$log;' || chr(10) ||
          'alter database disable thread 2;' || chr(10) ||
          'select thread#,group#,sequence#,bytes,status,archived from v$log;' || chr(10) ||
          'alter system archive log all;' || chr(10) ||
          'select thread#,group#,sequence#,bytes,status,archived from v$log;' || chr(10) ||
          'alter database drop logfile group 2-all;'
     from dual
   union all
   select '----No Archivelog Mode' || chr(10) ||
          'alter database disable thread 2;' || chr(10) ||
          'select thread#,status,enabled,groups,instance from v$thread;' || chr(10) ||
          'alter database drop logfile group 2-all;' || chr(10) ||
          'select thread#,status,enabled,groups,instance from v$thread;' || chr(10) ||
          'select thread#,group#,sequence#,bytes,status from v$log;'
     from dual;
!
exit 0
fi

if [ "$1" = "awr_dbid" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set line 130
    set pagesize 60
    col HOST for a15
    col dbbid for a20
    col INSTT_NAME for a12

                select distinct
                       (case when cd.dbid = wr.dbid and
                                  cd.name = wr.db_name and
                                  ci.instance_number = wr.instance_number and
                                  ci.instance_name   = wr.instance_name
                             then '* '
                             else '  '
                        end) || wr.dbid   dbbid
                     , wr.instance_number instt_num
                     , wr.db_name         dbb_name
                     , wr.instance_name   instt_name
                     , wr.host_name       host
                     , wr.version
                  from dba_hist_database_instance wr, v\$database cd, v\$instance ci
                  order by dbbid,instt_num;
!
exit 0
fi

if [ "$1" = "awr_delete" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_delete dbid"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
    exec dbms_swrf_internal.unregister_database($2);
!
exit 0
fi

if [ "$1" = "awr_all_snap" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_all_snap dbid -- Show awr repository min and max snap_id."
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
                SELECT MIN(SNAP_ID) MIN_ID, MAX(SNAP_ID) MAX_ID
                  FROM DBA_HIST_SNAPSHOT
                 WHERE DBID =$2;
!
exit 0
fi

if [ "$1" = "awr_trans" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_trans dbid inst  -- Show TPS(transactions per second), TRANSACTIONS, USER_COMMIT, USER_ROLLBACK, TRANSACTION_ROLLBACK per snap_id."
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set linesize 120
    set pagesize 6000

    col USER_COMMIT for 99999999999999
    col USER_ROLLBACK for 99999999999999
    col TRANSACTION_ROLLBACK for 99999999999999
    col TRANSACTIONS for 99999999999999
    col TPS for 999,999,999.9

                SELECT T.END_SNAP_ID,
                       T.SNAP_TIME,
                       (T.UC + T.UR + T.TR) / INTVL TPS,
                       (T.UC + T.UR + T.TR) TRANSACTIONS,
                       UC USER_COMMIT,
                       UR USER_ROLLBACK,
                       TR TRANSACTION_ROLLBACK
                  FROM (SELECT UC.SNAP_ID AS "END_SNAP_ID",
                               TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               --'user commits',
                               CASE
                                 WHEN (ROUND((UC.VALUE - LAG(UC.VALUE, 1)
                                              OVER(ORDER BY UC.SNAP_ID)))) < 0 THEN
                                  0
                                 ELSE
                                  ROUND((UC.VALUE - LAG(UC.VALUE, 1) OVER(ORDER BY UC.SNAP_ID)))
                               END AS UC,
                               --'user rollbacks',
                               CASE
                                 WHEN (ROUND((UR.VALUE - LAG(UR.VALUE, 1)
                                              OVER(ORDER BY UR.SNAP_ID)))) < 0 THEN
                                  0
                                 ELSE
                                  ROUND((UR.VALUE - LAG(UR.VALUE, 1) OVER(ORDER BY UR.SNAP_ID)))
                               END AS UR,
                               --'transaction rollbacks',
                               CASE
                                 WHEN (ROUND((TR.VALUE - LAG(TR.VALUE, 1)
                                              OVER(ORDER BY TR.SNAP_ID)))) < 0 THEN
                                  0
                                 ELSE
                                  ROUND((TR.VALUE - LAG(TR.VALUE, 1) OVER(ORDER BY TR.SNAP_ID)))
                               END AS TR,
                               (CAST(B.END_INTERVAL_TIME AS DATE) -
                               CAST(B.BEGIN_INTERVAL_TIME AS DATE)) * 86400 INTVL
                          FROM (SELECT SNAP_ID, VALUE
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'user commits'
                                   AND DBID = $2
                                   AND INSTANCE_NUMBER = $3) UC,
                               (SELECT SNAP_ID, VALUE
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'transaction rollbacks'
                                   AND DBID = $2
                                   AND INSTANCE_NUMBER = $3) TR,
                               (SELECT SNAP_ID, VALUE
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'user rollbacks'
                                   AND DBID = $2
                                   AND INSTANCE_NUMBER = $3) UR,
                               DBA_HIST_SNAPSHOT B
                         WHERE B.DBID = $2
                           AND UC.SNAP_ID = B.SNAP_ID
                           AND TR.SNAP_ID = B.SNAP_ID
                           AND UR.SNAP_ID = B.SNAP_ID
                           AND B.INSTANCE_NUMBER = $3
                         ORDER BY 1) T;
!
exit 0
fi

if [ "$1" = "awr_redo" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_redo dbid inst_id -- Show redo size per snap per second"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set linesize 120
    set pagesize 6000

                col snap_time for a20
                col REDO_SIZE format 999,999,999,999.9
                col REDO_SIZE_PER_SEC format 999,999,999,999.9

                SELECT END_SNAP_ID,
                                       SNAP_TIME,
                                       REDO_SIZE,
                                       REDO_SIZE / INTVL REDO_SIZE_PER_SEC
                                  FROM (SELECT A.SNAP_ID END_SNAP_ID,
                                               TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                               CASE
                                                 WHEN ((A.VALUE - LAG(A.VALUE, 1)
                                                              OVER(ORDER BY A.SNAP_ID))) < 0 THEN
                                                  0
                                                 ELSE
                                                  (A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID))
                                               END AS REDO_SIZE,
                                               (CAST(B.END_INTERVAL_TIME AS DATE) -
                                               CAST(B.BEGIN_INTERVAL_TIME AS DATE)) * 86400 INTVL
                                          FROM (SELECT SNAP_ID, VALUE
                                                  FROM DBA_HIST_SYSSTAT
                                                 WHERE STAT_NAME = 'redo size'
                                                   AND DBID = $2
                                                   AND INSTANCE_NUMBER = $3) A,
                                               DBA_HIST_SNAPSHOT B
                                         WHERE B.DBID = $2
                                           AND A.SNAP_ID = B.SNAP_ID
                                           AND B.INSTANCE_NUMBER = $3
                                         ORDER BY 1) T;
!
exit 0
fi

if [ "$1" = "awr_os" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_os dbid inst_id  --Show os load, busy_time, idle_time, user_time, sys_time, iowait_time"
  fi

        if [ "$4" = "" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 130
            set pagesize 6000

            col SNAP_TIME for a19
            col LOAD for 999.99
            col BUSY_PCT for 999.99
            col USER_PCT for 999.99
            col SYS_PCT for 999.99
            col IDL_PCT for 999.99
            col WIO_PCT for 999.99

                        SELECT TO_CHAR(S.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               LOAD,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      BUSY_TIME / (BUSY_TIME + IDLE_TIME) * 100) BUSY_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      USER_TIME / (BUSY_TIME + IDLE_TIME) * 100) USER_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      SYS_TIME / (BUSY_TIME + IDLE_TIME) * 100) SYS_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      IDLE_TIME / (BUSY_TIME + IDLE_TIME) * 100) IDL_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      WIO_TIME / (BUSY_TIME + IDLE_TIME) * 100) WIO_PCT
                          FROM (SELECT SNAP_ID,
                                       INSTANCE_NUMBER,
                                       DBID,
                                       COUNT(*) CNT,
                                       SUM(DECODE(STAT_NAME, 'LOAD', VALUE, 0)) LOAD,
                                       SUM(DECODE(STAT_NAME, 'BUSY_TIME', VALUE - PREV_VALUE, 0)) BUSY_TIME,
                                       SUM(DECODE(STAT_NAME, 'IDLE_TIME', VALUE - PREV_VALUE, 0)) IDLE_TIME,
                                       SUM(DECODE(STAT_NAME, 'USER_TIME', VALUE - PREV_VALUE, 0)) USER_TIME,
                                       SUM(DECODE(STAT_NAME, 'SYS_TIME', VALUE - PREV_VALUE, 0)) SYS_TIME,
                                       SUM(DECODE(STAT_NAME, 'IOWAIT_TIME', VALUE - PREV_VALUE, 0)) WIO_TIME
                                  FROM (SELECT SNAP_ID,
                                               INSTANCE_NUMBER,
                                               DBID,
                                               STAT_NAME,
                                               VALUE,
                                               LAG(VALUE, 1) OVER(PARTITION BY STAT_NAME, INSTANCE_NUMBER, DBID ORDER BY SNAP_ID) PREV_VALUE
                                          FROM DBA_HIST_OSSTAT
                                         WHERE DBID = $2
                                           AND INSTANCE_NUMBER = $3
                                         ORDER BY STAT_NAME, INSTANCE_NUMBER, SNAP_ID)
                                 GROUP BY SNAP_ID, DBID, INSTANCE_NUMBER) OS,
                               DBA_HIST_SNAPSHOT S
                         WHERE OS.SNAP_ID = S.SNAP_ID
                           AND OS.INSTANCE_NUMBER = S.INSTANCE_NUMBER
                           AND OS.DBID = S.DBID
                         ORDER BY OS.INSTANCE_NUMBER, OS.SNAP_ID;
!
exit 0
        fi
        if [ "$4" = "html" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set pagesize 6000
            set markup html on
            spool $1_$2_$3.html

            col SNAP_TIME for a19
            col LOAD for 999.99
            col BUSY_PCT for 999.99
            col USER_PCT for 999.99
            col SYS_PCT for 999.99
            col IDL_PCT for 999.99
            col WIO_PCT for 999.99

                        SELECT TO_CHAR(S.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               LOAD,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      BUSY_TIME / (BUSY_TIME + IDLE_TIME) * 100) BUSY_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      USER_TIME / (BUSY_TIME + IDLE_TIME) * 100) USER_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      SYS_TIME / (BUSY_TIME + IDLE_TIME) * 100) SYS_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      IDLE_TIME / (BUSY_TIME + IDLE_TIME) * 100) IDL_PCT,
                               DECODE(BUSY_TIME + IDLE_TIME,
                                      0,
                                      TO_NUMBER(NULL),
                                      WIO_TIME / (BUSY_TIME + IDLE_TIME) * 100) WIO_PCT
                          FROM (SELECT SNAP_ID,
                                       INSTANCE_NUMBER,
                                       DBID,
                                       COUNT(*) CNT,
                                       SUM(DECODE(STAT_NAME, 'LOAD', VALUE, 0)) LOAD,
                                       SUM(DECODE(STAT_NAME, 'BUSY_TIME', VALUE - PREV_VALUE, 0)) BUSY_TIME,
                                       SUM(DECODE(STAT_NAME, 'IDLE_TIME', VALUE - PREV_VALUE, 0)) IDLE_TIME,
                                       SUM(DECODE(STAT_NAME, 'USER_TIME', VALUE - PREV_VALUE, 0)) USER_TIME,
                                       SUM(DECODE(STAT_NAME, 'SYS_TIME', VALUE - PREV_VALUE, 0)) SYS_TIME,
                                       SUM(DECODE(STAT_NAME, 'IOWAIT_TIME', VALUE - PREV_VALUE, 0)) WIO_TIME
                                  FROM (SELECT SNAP_ID,
                                               INSTANCE_NUMBER,
                                               DBID,
                                               STAT_NAME,
                                               VALUE,
                                               LAG(VALUE, 1) OVER(PARTITION BY STAT_NAME, INSTANCE_NUMBER, DBID ORDER BY SNAP_ID) PREV_VALUE
                                          FROM DBA_HIST_OSSTAT
                                         WHERE DBID = $2
                                           AND INSTANCE_NUMBER = $3
                                         ORDER BY STAT_NAME, INSTANCE_NUMBER, SNAP_ID)
                                 GROUP BY SNAP_ID, DBID, INSTANCE_NUMBER) OS,
                               DBA_HIST_SNAPSHOT S
                         WHERE OS.SNAP_ID = S.SNAP_ID
                           AND OS.INSTANCE_NUMBER = S.INSTANCE_NUMBER
                           AND OS.DBID = S.DBID
                         ORDER BY OS.INSTANCE_NUMBER, OS.SNAP_ID;
                         spool off
!
exit 0
        fi
fi

if [ "$1" = "awr_dbtime" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_dbtime dbid inst_id  --Show dbtime per snap"
  fi

  if [ "$4" = "" ]; then
                        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                          connect $DBUSER

                          set echo on
                          set linesize 130
                          set pages 6000

                          col snap_time for a20

                          SELECT a.snap_id  AS "END_SNAP_ID",TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                                                  --'DB Time(s)',
                                                  CASE
                                                    WHEN (ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000))<0
                                                    THEN 0
                                                    ELSE ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000)
                                                  END AS "DB Time(s)"
                                                FROM
                                                  (SELECT snap_id,
                                                    VALUE
                                                  FROM dba_hist_sys_time_model
                                                  WHERE stat_name     = 'DB time'
                                                  and dbid = $2
                                                  AND INSTANCE_NUMBER = $3) a,
                                                  dba_hist_snapshot b
                                                WHERE b.dbid = $2
                                                AND a.snap_id       = b.snap_id
                                                AND b.INSTANCE_NUMBER = $3
                                                ORDER BY 1;
!
exit 0
        fi

  if [ "$4" = "html" ]; then
                        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                          connect $DBUSER

                          set pages 6000
                          set markup html on

                          spool $1_$2_$3.html

                          SELECT a.snap_id  AS "END_SNAP_ID",TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                                                  --'DB Time(s)',
                                                  CASE
                                                    WHEN (ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000))<0
                                                    THEN 0
                                                    ELSE ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000)
                                                  END AS "DB Time(s)"
                                                FROM
                                                  (SELECT snap_id,
                                                    VALUE
                                                  FROM dba_hist_sys_time_model
                                                  WHERE stat_name     = 'DB time'
                                                  and dbid = $2
                                                  AND INSTANCE_NUMBER = $3) a,
                                                  dba_hist_snapshot b
                                                WHERE b.dbid = $2
                                                AND a.snap_id       = b.snap_id
                                                AND b.INSTANCE_NUMBER = $3
                                                ORDER BY 1;
                                spool off
!
exit 0
        fi

  if [ "$4" = "AAS" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 200
                  set pages 6000
                  col AAS format 99999.999

                        select snap_id as END_SNAP_ID, snap_time, dbt "DB Time(s)", dbt / intvl as AAS
                          from (SELECT a.snap_id,
                                       TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                                       CASE
                                         WHEN (ROUND((a.VALUE - lag(a.VALUE, 1)
                                                      OVER(ORDER BY a.snap_id)) / 1000000)) < 0 THEN
                                          0
                                         ELSE
                                          ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) /
                                                1000000)
                                       END AS dbt,
                                       EXTRACT(HOUR
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT snap_id, VALUE
                                          FROM dba_hist_sys_time_model
                                         WHERE stat_name = 'DB time'
                                           and dbid = $2
                                           AND INSTANCE_NUMBER = $3) a,
                                       dba_hist_snapshot b
                                 WHERE b.dbid = $2
                                   AND a.snap_id = b.snap_id
                                   AND b.INSTANCE_NUMBER = $3)
                         ORDER BY 1;
!
exit 0
        fi
fi

if [ "$1" = "awr_dbtime_order" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_dbtime_order dbid inst_id  --Show dbtime per snap order by dbtime"
  fi

        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
  connect $DBUSER

  set echo on
  set linesize 300
  set pages 6000

  col snap_time for a20

    SELECT A.SNAP_ID AS "END_SNAP_ID",
           TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
           --'DB Time(s)',
           CASE
             WHEN (ROUND((A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID)) /
                         1000000)) < 0 THEN
              0
             ELSE
              ROUND((A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID)) /
                    1000000)
           END AS "DB Time(s)"
      FROM (SELECT SNAP_ID, VALUE
              FROM DBA_HIST_SYS_TIME_MODEL
             WHERE STAT_NAME = 'DB time'
               AND DBID = $2
               AND INSTANCE_NUMBER = $3) A,
           DBA_HIST_SNAPSHOT B
     WHERE B.DBID = $2
       AND A.SNAP_ID = B.SNAP_ID
       AND B.INSTANCE_NUMBER = $3
     ORDER BY 3;
!
exit 0
fi


if [ "$1" = "awr_parse" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_parse dbid inst_id  --Show parse, hard parse times, hard_parse per snap order by parse"
  fi

        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
  connect $DBUSER

  set echo on
  set linesize 300
  set pages 6000

  col snap_time for a20

    SELECT A.SNAP_ID AS "END_SNAP_ID",
           TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
           --'DB Time(s)',
           CASE
             WHEN (ROUND((A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID)) /
                         1000000)) < 0 THEN
              0
             ELSE
              ROUND((A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID)) /
                    1000000)
           END AS "DB Time(s)"
      FROM (SELECT SNAP_ID, VALUE
              FROM DBA_HIST_SYS_TIME_MODEL
             WHERE STAT_NAME = 'DB time'
               AND DBID = $2
               AND INSTANCE_NUMBER = $3) A,
           DBA_HIST_SNAPSHOT B
     WHERE B.DBID = $2
       AND A.SNAP_ID = B.SNAP_ID
       AND B.INSTANCE_NUMBER = $3
     ORDER BY 3;
!
exit 0
fi

if [ "$1" = "awr_sql_elaps_time" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_sql_elaps_time dbid inst_id  --Show sql elsapsed time per snap"
  fi
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set echo on
          set linesize 130
          set pages 6000

      col snap_time for a20

            SELECT a.snap_id  AS "END_SNAP_ID",TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                                          CASE
                                            WHEN (ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000))<0
                                            THEN 0
                                            ELSE ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000)
                                          END AS "SQL Elapsed Time(s)"
                                        FROM
                                          (SELECT snap_id,
                                            VALUE
                                          FROM dba_hist_sys_time_model
                                          WHERE stat_name     = 'sql execute elapsed time'
                                          and dbid = $2
                                          AND INSTANCE_NUMBER = $3) a,
                                          dba_hist_snapshot b
                                        WHERE b.dbid = $2
                                        AND a.snap_id       = b.snap_id
                                        AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
!
exit 0
fi

if [ "$1" = "awr_dbcpu" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_dbcpu dbid inst_id  --Show DB CPU per snap"
  fi

  if [ "$4" = "" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                  connect $DBUSER

                  set echo on
                  set linesize 130
                  set pages 6000

                  col snap_time for a20

                  SELECT a.snap_id  AS "END_SNAP_ID",TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                                          --'DB Time(s)',
                                          CASE
                                            WHEN (ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000))<0
                                            THEN 0
                                            ELSE ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000)
                                          END AS "DB CPU(s)"
                                        FROM
                                          (SELECT snap_id,
                                            VALUE
                                          FROM dba_hist_sys_time_model
                                          WHERE stat_name     = 'DB CPU'
                                          and dbid = $2
                                          AND INSTANCE_NUMBER = $3) a,
                                          dba_hist_snapshot b
                                        WHERE b.dbid = $2
                                        AND a.snap_id       = b.snap_id
                                        AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
!
exit 0
        fi

        if [ "$4" = "html" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                  connect $DBUSER

                  set echo on
                  set linesize 130
                  set pages 6000

                  col snap_time for a20

                  set markup html on
                  spool $1_$2_$3.html

                  SELECT a.snap_id  AS "END_SNAP_ID",TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                                          --'DB Time(s)',
                                          CASE
                                            WHEN (ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000))<0
                                            THEN 0
                                            ELSE ROUND((a.VALUE - lag(a.VALUE, 1) OVER(ORDER BY a.snap_id)) / 1000000)
                                          END AS "DB CPU(s)"
                                        FROM
                                          (SELECT snap_id,
                                            VALUE
                                          FROM dba_hist_sys_time_model
                                          WHERE stat_name     = 'DB CPU'
                                          and dbid = $2
                                          AND INSTANCE_NUMBER = $3) a,
                                          dba_hist_snapshot b
                                        WHERE b.dbid = $2
                                        AND a.snap_id       = b.snap_id
                                        AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
                        spool off
!
exit 0
        fi
fi

if [ "$1" = "awr_logical_reads" ]; then
        if [ "$2" = "" ]; then
    usage "ora awr_logical_reads dbid inst_id  --Show awr logical reads blocks/s, M/s, blocks, M per snap_id"
  fi

  if [ "$4" = "" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 300
                  set pages 6000

            col snap_time for a20
            col "logical reads (blocks/s)" format 999,999,999,999.9
            col "logical reads (M/s)" format 999,999,999,999.9
            col "logical reads (blocks)" format 999,999,999,999
            col "logical reads (M)" format 999,999,999,999.9


                        SELECT END_SNAP_ID,
                               SNAP_TIME,
                               LOGICAL_READS_BLOCKS / INTVL "logical reads (blocks/s)",
                               LOGICAL_READS_BLOCKS * (select value
                                                         from dba_hist_parameter
                                                        where dbid = $2
                                                          and parameter_name = 'db_block_size'
                                                          and rownum < 2) / INTVL / 1024 / 1024 "logical reads (M/s)",
                               LOGICAL_READS_BLOCKS "logical reads (blocks)",
                               LOGICAL_READS_BLOCKS * (select value
                                                         from dba_hist_parameter
                                                        where dbid = $2
                                                          and parameter_name = 'db_block_size'
                                                          and rownum < 2) / 1024 / 1024 "logical reads (M)"
                          FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                                       TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                       CASE
                                         WHEN A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID) < 0 THEN
                                          0
                                         ELSE
                                          A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID)
                                       END AS LOGICAL_READS_BLOCKS,
                                       EXTRACT(HOUR
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT SNAP_ID, VALUE, DBID
                                          FROM DBA_HIST_SYSSTAT
                                         WHERE STAT_NAME = 'session logical reads'
                                           AND INSTANCE_NUMBER = $3) A,
                                       DBA_HIST_SNAPSHOT B
                                 WHERE a.dbid = b.dbid
                                   AND A.SNAP_ID = B.SNAP_ID
                                   AND B.INSTANCE_NUMBER = $3
                                   AND A.DBID = $2
                                   AND B.DBID = $2
                                 ORDER BY 1) T;
!
exit 0
        fi
        if [ "$4" = "html" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set markup html on
                  set pages 6000

            col snap_time for a20
            col "logical reads (blocks/s)" format 999,999,999,999.9
            col "logical reads (M/s)" format 999,999,999,999.9
            col "logical reads (blocks)" format 999,999,999,999
            col "logical reads (M)" format 999,999,999,999.9

            spool $1_$2_$3.html

                        SELECT END_SNAP_ID,
                               SNAP_TIME,
                               LOGICAL_READS_BLOCKS / INTVL "logical reads (blocks/s)",
                               LOGICAL_READS_BLOCKS * (select value
                                                         from dba_hist_parameter
                                                        where dbid = $2
                                                          and parameter_name = 'db_block_size'
                                                          and rownum < 2) / INTVL / 1024 / 1024 "logical reads (M/s)",
                               LOGICAL_READS_BLOCKS "logical reads (blocks)",
                               LOGICAL_READS_BLOCKS * (select value
                                                         from dba_hist_parameter
                                                        where dbid = $2
                                                          and parameter_name = 'db_block_size'
                                                          and rownum < 2) / 1024 / 1024 "logical reads (M)"
                          FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                                       TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                       CASE
                                         WHEN A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID) < 0 THEN
                                          0
                                         ELSE
                                          A.VALUE - LAG(A.VALUE, 1) OVER(ORDER BY A.SNAP_ID)
                                       END AS LOGICAL_READS_BLOCKS,
                                       EXTRACT(HOUR
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT SNAP_ID, VALUE, DBID
                                          FROM DBA_HIST_SYSSTAT
                                         WHERE STAT_NAME = 'session logical reads'
                                           AND INSTANCE_NUMBER = $3) A,
                                       DBA_HIST_SNAPSHOT B
                                 WHERE a.dbid = b.dbid
                                   AND A.SNAP_ID = B.SNAP_ID
                                   AND B.INSTANCE_NUMBER = $3
                                   AND A.DBID = $2
                                   AND B.DBID = $2
                                 ORDER BY 1) T;
                        spool off
!
exit 0
        fi
fi

if [ "$1" = "awr_logical_reads_order" ]; then
        if [ "$2" = "" ]; then
    usage "ora awr_logical_reads_order dbid inst_id --Show awr logical reads blocks/s, M/s, blocks, M per snap_id order by LRBPS"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set echo on
          set linesize 300
          set pages 6000

    col snap_time for a20
    col "logical reads (blocks/s)" format 999,999,999,999.9
    col "logical reads (M/s)" format 999,999,999,999.9
    col "logical reads (blocks)" format 999,999,999,999
    col "logical reads (M)" format 999,999,999,999.9

                SELECT END_SNAP_ID,
                       SNAP_TIME,
                       LOGICAL_READS_BLOCKS / INTVL "logical reads (blocks/s)",
                       LOGICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/INTVL/1024/1024 "logical reads (M/s)",
                       LOGICAL_READS_BLOCKS "logical reads (blocks)",
                       LOGICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/1024/1024 "logical reads (M)"
                  FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                               TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               CASE
                                 WHEN A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID) < 0 THEN 0
                                 ELSE
                                   A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID)
                               END AS LOGICAL_READS_BLOCKS,
                               EXTRACT(HOUR
                           FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                               EXTRACT(MINUTE
                                       FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                               EXTRACT(SECOND
                                       FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                          FROM (SELECT SNAP_ID, VALUE, DBID
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'session logical reads'
                                   AND INSTANCE_NUMBER = $3) A,
                               DBA_HIST_SNAPSHOT B
                         WHERE a.dbid=b.dbid
                           AND A.SNAP_ID = B.SNAP_ID
                           AND B.INSTANCE_NUMBER = $3
                           AND A.DBID = $2
                           AND B.DBID = $2
                         ORDER BY 1) T order by 3;
!
exit 0
fi

if [ "$1" = "awr_physical_reads" ]; then
        if [ "$2" = "" ]; then
    usage "ora awr_physical_reads dbid inst_id  --Show awr physical reads blocks/s, M/s, blocks, M per snap_id"
  fi

  if [ "$4" = "" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 300
                  set pages 6000

            col snap_time for a20
            col "physical reads (blocks/s)" format 999,999,999,999.9
            col "physical reads (M/s)" format 999,999,999,999.9
            col "physical reads (blocks)" format 999,999,999,999
            col "physical reads (M)" format 999,999,999,999.9

                        SELECT END_SNAP_ID,
                               SNAP_TIME,
                               PHYSICAL_READS_BLOCKS / INTVL "physical reads (blocks/s)",
                               PHYSICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/INTVL/1024/1024 "physical reads (M/s)",
                               PHYSICAL_READS_BLOCKS "physical reads (blocks)",
                               PHYSICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/1024/1024 "physical reads (M)"
                          FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                                       TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                       CASE
                                         WHEN A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID) < 0 THEN 0
                                         ELSE
                                           A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID)
                                       END AS PHYSICAL_READS_BLOCKS,
                                       EXTRACT(HOUR
                           FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT SNAP_ID, VALUE, DBID
                                          FROM DBA_HIST_SYSSTAT
                                         WHERE STAT_NAME = 'physical reads'
                                           AND INSTANCE_NUMBER = $3) A,
                                       DBA_HIST_SNAPSHOT B
                                 WHERE a.dbid=b.dbid
                                   AND A.SNAP_ID = B.SNAP_ID
                                   AND B.INSTANCE_NUMBER = $3
                                   AND A.DBID = $2
                                   AND B.DBID = $2
                                 ORDER BY 1) T;
!
exit 0
        fi

        if [ "$4" = "html" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 300
                  set pages 6000

            col snap_time for a20
            col "physical reads (blocks/s)" format 999,999,999,999.9
            col "physical reads (M/s)" format 999,999,999,999.9
            col "physical reads (blocks)" format 999,999,999,999
            col "physical reads (M)" format 999,999,999,999.9
                        set markup html on
            spool $1_$2_$3.html

                        SELECT END_SNAP_ID,
                               SNAP_TIME,
                               PHYSICAL_READS_BLOCKS / INTVL "physical reads (blocks/s)",
                               PHYSICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/INTVL/1024/1024 "physical reads (M/s)",
                               PHYSICAL_READS_BLOCKS "physical reads (blocks)",
                               PHYSICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/1024/1024 "physical reads (M)"
                          FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                                       TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                       CASE
                                         WHEN A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID) < 0 THEN 0
                                         ELSE
                                           A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID)
                                       END AS PHYSICAL_READS_BLOCKS,
                                       EXTRACT(HOUR
                           FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT SNAP_ID, VALUE, DBID
                                          FROM DBA_HIST_SYSSTAT
                                         WHERE STAT_NAME = 'physical reads'
                                           AND INSTANCE_NUMBER = $3) A,
                                       DBA_HIST_SNAPSHOT B
                                 WHERE a.dbid=b.dbid
                                   AND A.SNAP_ID = B.SNAP_ID
                                   AND B.INSTANCE_NUMBER = $3
                                   AND A.DBID = $2
                                   AND B.DBID = $2
                                 ORDER BY 1) T;
                        spool off
!
exit 0
        fi
fi

if [ "$1" = "awr_physical_reads_order" ]; then
        if [ "$2" = "" ]; then
    usage "ora awr_physical_reads_order dbid inst_id  --Show awr physical reads blocks/s, M/s, blocks, M per snap_id order by PRBPS"
  fi

          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 300
                  set pages 6000

            col snap_time for a20
            col "physical reads (blocks/s)" format 999,999,999,999.9
            col "physical reads (M/s)" format 999,999,999,999.9
            col "physical reads (blocks)" format 999,999,999,999
            col "physical reads (M)" format 999,999,999,999.9

                        SELECT END_SNAP_ID,
                               SNAP_TIME,
                               PHYSICAL_READS_BLOCKS / INTVL "physical reads (blocks/s)",
                               PHYSICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/INTVL/1024/1024 "physical reads (M/s)",
                               PHYSICAL_READS_BLOCKS "physical reads (blocks)",
                               PHYSICAL_READS_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/1024/1024 "physical reads (M)"
                          FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                                       TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                       CASE
                                         WHEN A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID) < 0 THEN 0
                                         ELSE
                                           A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID)
                                       END AS PHYSICAL_READS_BLOCKS,
                                       EXTRACT(HOUR
                           FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT SNAP_ID, VALUE, DBID
                                          FROM DBA_HIST_SYSSTAT
                                         WHERE STAT_NAME = 'physical reads'
                                           AND INSTANCE_NUMBER = $3) A,
                                       DBA_HIST_SNAPSHOT B
                                 WHERE a.dbid=b.dbid
                                   AND A.SNAP_ID = B.SNAP_ID
                                   AND B.INSTANCE_NUMBER = $3
                                   AND A.DBID = $2
                                   AND B.DBID = $2
                                 ORDER BY 1) T order by 3;
!
exit 0
fi

if [ "$1" = "awr_physical_writes" ]; then
        if [ "$2" = "" ]; then
    usage "ora awr_physical_writes dbid inst_id  --Show awr physical writes blocks/s, M/s, blocks, M per snap_id"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set echo on
          set linesize 300
          set pages 6000

    col snap_time for a20
    col "physical writes (blocks/s)" format 999,999,999,999.9
    col "physical writes (M/s)" format 999,999,999,999.9
    col "physical writes (blocks)" format 999,999,999,999
    col "physical writes (M)" format 999,999,999,999.9

                SELECT END_SNAP_ID,
           SNAP_TIME,
           PHYSICAL_WRITES_BLOCKS / INTVL "physical writes (blocks/s)",
           PHYSICAL_WRITES_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/INTVL/1024/1024 "physical writes (M/s)",
           PHYSICAL_WRITES_BLOCKS "physical writes (blocks)",
           PHYSICAL_WRITES_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/1024/1024 "physical writes (M)"
                  FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                               TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               CASE
                                 WHEN A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID) < 0 THEN 0
                                 ELSE
                                   A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID)
                               END AS PHYSICAL_WRITES_BLOCKS,
                               EXTRACT(HOUR
                           FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                               EXTRACT(MINUTE
                                       FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                               EXTRACT(SECOND
                                       FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                          FROM (SELECT SNAP_ID, VALUE, DBID
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'physical writes'
                                   AND INSTANCE_NUMBER = $3) A,
                               DBA_HIST_SNAPSHOT B
                         WHERE a.dbid=b.dbid
                           AND A.SNAP_ID = B.SNAP_ID
                           AND B.INSTANCE_NUMBER = $3
                           AND A.DBID = $2
                           AND B.DBID = $2
                         ORDER BY 1) T ;
!
exit 0
fi

if [ "$1" = "awr_physical_writes_order" ]; then
        if [ "$2" = "" ]; then
    usage "ora awr_physical_writes_order dbid inst_id  --Show awr physical writes blocks/s, M/s, blocks, M per snap_id order by PWBPS"
  fi

          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 300
                  set pages 6000

            col snap_time for a20
            col "physical writes (blocks/s)" format 999,999,999,999.9
            col "physical writes (M/s)" format 999,999,999,999.9
            col "physical writes (blocks)" format 999,999,999,999
            col "physical writes (M)" format 999,999,999,999.9

                        SELECT END_SNAP_ID,
             SNAP_TIME,
             PHYSICAL_WRITES_BLOCKS / INTVL "physical writes (blocks/s)",
             PHYSICAL_WRITES_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/INTVL/1024/1024 "physical writes (M/s)",
             PHYSICAL_WRITES_BLOCKS "physical writes (blocks)",
             PHYSICAL_WRITES_BLOCKS * (select value
                                                 from dba_hist_parameter
                                                where dbid = $2
                                                  and parameter_name = 'db_block_size'
                                                  and rownum < 2)/1024/1024 "physical writes (M)"
                          FROM (SELECT A.SNAP_ID AS END_SNAP_ID,
                                       TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                                       CASE
                                         WHEN A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID) < 0 THEN 0
                                         ELSE
                                           A.VALUE - LAG(A.VALUE, 1)  OVER(ORDER BY A.SNAP_ID)
                                       END AS PHYSICAL_WRITES_BLOCKS,
                                       EXTRACT(HOUR
                           FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 3600 +
                                       EXTRACT(MINUTE
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) * 60 +
                                       EXTRACT(SECOND
                                               FROM(B.END_INTERVAL_TIME - B.BEGIN_INTERVAL_TIME)) AS INTVL
                                  FROM (SELECT SNAP_ID, VALUE, DBID
                                          FROM DBA_HIST_SYSSTAT
                                         WHERE STAT_NAME = 'physical writes'
                                           AND INSTANCE_NUMBER = $3) A,
                                       DBA_HIST_SNAPSHOT B
                                 WHERE a.dbid=b.dbid
                                   AND A.SNAP_ID = B.SNAP_ID
                                   AND B.INSTANCE_NUMBER = $3
                                   AND A.DBID = $2
                                   AND B.DBID = $2
                                 ORDER BY 1) T order by 6;
!
exit 0
fi

if [ "$1" = "awr_sessions" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_sessions dbid inst_id  --Show sessions per snap"
  fi

        if [ "$4" = "" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                  connect $DBUSER

                  set echo on
                  set linesize 130
                  set pages 6000

                  col snap_time for a20
                        SELECT A.SNAP_ID AS END_SNAP_ID,
                               TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               A.VALUE AS sessions
                          from (SELECT snap_id, VALUE
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'logons current'
                                   AND INSTANCE_NUMBER = $3
                                   and DBID = $2) A,
                               dba_hist_snapshot b
                         where B.DBID = $2
                           AND A.SNAP_ID = B.SNAP_ID
                           AND B.INSTANCE_NUMBER = $3
                         ORDER BY 1;
!
exit 0
        fi

        if [ "$4" = "html" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                  connect $DBUSER

                  set echo on
                  set linesize 130
                  set pages 6000

                  set markup html on
                  spool $1_$2_$3.html
                        SELECT A.SNAP_ID AS END_SNAP_ID,
                               TO_CHAR(B.END_INTERVAL_TIME, 'yyyy-mm-dd hh24:mi:ss') SNAP_TIME,
                               A.VALUE AS sessions
                          from (SELECT snap_id, VALUE
                                  FROM DBA_HIST_SYSSTAT
                                 WHERE STAT_NAME = 'logons current'
                                   AND INSTANCE_NUMBER = $3
                                   and DBID = $2) A,
                               dba_hist_snapshot b
                         where B.DBID = $2
                           AND A.SNAP_ID = B.SNAP_ID
                           AND B.INSTANCE_NUMBER = $3
                         ORDER BY 1;

                         spool off
!
exit 0
        fi
fi

if [ "$1" = "awr_sql" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_sql dbid sql_id   --Show sql_id history elapsed time."
  fi

        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set echo on
          set linesize 300
          set pages 6000

    col snap_time for a20
    col SCHEMA for a15
    col "EXECUTIONS" format 999999999
    col "ELAPSED TIME PER EXEC (S)" format 9999999.999
    col "ELAPSED TIME (S)" format 99999999999.99

    break -
      on END_SNAP_ID -
      on SNAP_TIME -

                SELECT s.snap_id AS "END_SNAP_ID",
                       TO_CHAR(S.END_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') SNAP_TIME,
                       S.INSTANCE_NUMBER "INSTANCE",
                       SQS.PARSING_SCHEMA_NAME "SCHEMA",
                       SQS.EXECUTIONS_DELTA "EXECUTIONS",
                       SQS.ELAPSED_TIME_DELTA / SQS.EXECUTIONS_DELTA / 1000000 "ELAPSED TIME PER EXEC (S)",
                       SQS.ELAPSED_TIME_DELTA / 1000000 "ELAPSED TIME (S)",
                       SQS.PLAN_HASH_VALUE
                  FROM DBA_HIST_SNAPSHOT S, DBA_HIST_SQLSTAT SQS
                 WHERE SQS.SQL_ID = '$3'
                   AND S.SNAP_ID = SQS.SNAP_ID
                   AND S.DBID = SQS.DBID
                   AND S.INSTANCE_NUMBER = SQS.INSTANCE_NUMBER
                   AND SQS.DBID = $2
                   AND SQS.EXECUTIONS_DELTA > 0
                 ORDER BY S.SNAP_ID, S.INSTANCE_NUMBER;
!
exit 0
fi

if [ "$1" = "awr_sql_info" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_sql_info dbid sql_id   --Show sql_id history client session info, eg session type, machine, programme, module"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

                  set echo on
                  set linesize 130
                  set pages 6000

            col MACHINE for a13
            col PROGRAM for a35
            col MODULE for a35

            break -
              on SQL_ID -
              on SESSION_TYPE -
              on MACHINE -
              on PROGRAM -
              on MODULE -

                        SELECT T.SQL_ID,
                               T.SESSION_TYPE,
                               T.MACHINE,
                               T.PROGRAM,
                               T.MODULE,
                               COUNT(T.SQL_ID) "count"
                          FROM DBA_HIST_ACTIVE_SESS_HISTORY T
                         WHERE DBID = $2
                           AND T.SQL_ID = '$3'
                         GROUP BY T.SQL_ID, T.SESSION_TYPE, T.MACHINE, T.PROGRAM, T.MODULE
                         ORDER BY 2, 3, 4, 5;
!
exit 0
fi

if [ "$1" = "awr_fulltext" ]; then
  if [ "$2" = "" ]; then
    usage "DBID is missing"
  fi

  if [ "$3" = "" ]; then
    usage "SQL_ID is missing"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set echo on
          set linesize 130
          set pages 6000
          set long 40000000

                col sql_text format A130 WORD_WRAP
                SELECT SQL_TEXT
                  FROM DBA_HIST_SQLTEXT
                 WHERE SQL_ID = '$3'
                   AND DBID = $2;
!
exit 0
fi

if [ "$1" = "awr_plan" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_plan dbid sql_id plan_hash_value or null. --Show awr sql_id plan"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
  connect $DBUSER
  set linesize 200
  set pages 6000
  set tab      off
  set echo off
  set long     4000
  select * from table(dbms_xplan.display_awr('$3', '$4', '$2'));
!
exit 0
fi

if [ "$1" = "awr_plan_obj" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_plan_obj dbid object_name. --Show awr sql plan have object name sql_id and sql_text"
  fi

        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set linesize 200
          set pages 6000
    set tab      off
    set echo off
    set long     4000

    col SQLTEXT format a30
    col OPERATION format a20
    col OPTIONS format a23
    col OBJECT_NAME format a25

    break -
      on SQL_ID -
      on SQLTEXT -
      on PLAN_HASH_VALUE -

                SELECT P.SQL_ID,
                       TO_CHAR(SUBSTR(S.SQL_TEXT, 1, 50)) "SQLTEXT",
                       P.PLAN_HASH_VALUE,
                       P.OPERATION,
                       P.OPTIONS,
                       P.OBJECT_NAME
                  FROM DBA_HIST_SQL_PLAN P, DBA_HIST_SQLTEXT S
                 WHERE P.DBID = S.DBID
                   AND P.SQL_ID = S.SQL_ID
                   AND P.OBJECT_NAME = upper('$3')
                   AND P.DBID = $2
                 ORDER BY S.SQL_ID, P.PLAN_HASH_VALUE;
!
exit 0
fi

if [ "$1" = "awr_binds" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_binds dbid sql_id end_id"
  fi

          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

          set echo on
          set linesize 200
          set pages 6000

    col sql_text format A75 WORD_WRAP
    repfooter off;
    col BIND_NAME format A15
    col BIND_value format A29  wrap
    column VALUE_STRING format A20 wrap
    column CAPTURED format A10
    column LAST_CAPTURED format A20
    col sql_hash format A15

                select to_char(b.last_captured, 'YYYY-MM-DD HH24:MI:SS') "last_captured",
                       s.instance_number inst,
                       b.name "BIND_NAME",
                       b.position,
                       b.DATATYPE_STRING BIND_TYPE,
                       case b.DATATYPE
             when 12 then  --DATE
               to_char(ANYDATA.AccessDate(b.value_anydata),'YYYY-MM-DD HH24:MI:SS')
             when 180 then --TIMESTAMP
               to_char(ANYDATA.accesstimestamp(b.value_anydata),'YYYY-MM-DD HH24:MI:SS.FF')
             else
               b.VALUE_STRING
           end as bind_value,
                       s.plan_hash_value
                  from dba_hist_sqlstat s, dba_hist_sqlbind b
                 where s.dbid = b.dbid
                   and s.dbid = $2
                   and s.snap_id = b.snap_id
                   and s.instance_number = b.instance_number
                   and s.sql_id = b.sql_id
                   and s.sql_id = '$3'
                   and s.snap_id = $4
                   and b.was_captured = 'YES'
                 order by b.last_captured, s.plan_hash_value, b.position;

    col GIVEN_VALUE format A120  wrap

                SELECT 'variable '||CASE WHEN SUBSTRC(b.name,2,1) IN ('1','2','3','4','5','6','7','8','9','0')
                                                                                                        THEN
                                                                                                                replace(b.name, ':', 'b_')||' '
                                                                                                        ELSE
                                                                                                                replace(b.name, ':', '')||' '
                                                                                          END
                ||b.datatype_string||';'||CHR(10)||'EXEC '||CASE WHEN SUBSTRC(b.name, 2, 1) IN ('1', '2', '3', '4', '5', '6', '7', '8', '9', '0')
                                                                                                                THEN
                                                                                                                        replace(b.name, ':', ':b_')
                                                                                                                ELSE
                                                                                                                        b.name
                                                                                                                END||' := '||
                              CASE b.DATATYPE
                                WHEN  1 -- 'VARCHAR2'
                                    THEN ''''||b.value_string||''';'
                                WHEN  97 -- 'CHAR'
                                    THEN ''''||b.value_string||''';'
                                WHEN  12 -- 'DATE'
                                    THEN 'to_date('''||to_char(anydata.AccessDate(b.value_anydata), 'YYYY-MM-DD HH24:MI:SS')||''',''YYYY-MM-DD HH24:MI:SS'');'
                                WHEN  180 --  'TIMESTAMP'
                                   THEN 'to_timestamp('''|| to_Char(anydata.AccessTimestamp(b.value_anydata), 'YYYY-MM-DD HH24:MI:SS.FF')||''',''YYYY-MM-DD HH24:MI:SS.FF'');'
                                ELSE           --NUMBER,
                                    b.VALUE_STRING||';'
                                END AS "GIVEN_VALUE"
      from dba_hist_sqlstat s, dba_hist_sqlbind b
     where s.dbid = b.dbid
       and s.dbid = $2
       and s.snap_id = b.snap_id
       and s.instance_number = b.instance_number
       and s.sql_id = b.sql_id
       and s.sql_id = '$3'
       and s.snap_id =$4
       and b.was_captured = 'YES'
     order by b.last_captured, s.plan_hash_value, b.position;
!
exit 0
fi

if [ "$1" = "awr_hash_binds" ]; then
  if [ "$2" = "" ]; then
    usage "SQL_ID is missing"
  fi

  if [ "$3" = "" ]; then
    usage "Plan_hash_value is missing"
  fi

  if [ "$4" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
    connect $DBUSER

          set echo on
          set linesize 200
          set pages 6000

          var v_dbid NUMBER
    begin
        select dbid into :v_dbid
         from v\$database;
    end;
    /

                select distinct to_char(wmsys.wm_concat(b.value_string)) bind_value, max(b.position) bind_count
                  from dba_hist_sqlstat s, dba_hist_sqlbind b
                  where s.dbid = b.dbid
                  and s.instance_number = b.instance_number
                   and s.snap_id = b.snap_id
                   and b.was_captured = 'YES'
                   and s.sql_id = b.sql_id
                  and s.dbid = :v_dbid
                  and s.sql_id = '$2'
                  and s.plan_hash_value = $3
                  group by s.snap_id,s.instance_number
                  order by 1;
!
exit 0
        else
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
            connect $DBUSER

          set echo on
          set linesize 200
          set pages 6000

    col sql_text format A75 WORD_WRAP
    repfooter off;
    col BIND_NAME format A15
    column VALUE_STRING format A20 wrap
    column CAPTURED format A10
    column LAST_CAPTURED format A20

    break -
      on end_snap_id -
      on last_captured -
      on inst -

                select distinct to_char(wmsys.wm_concat(b.value_string)) bind_value, max(b.position) bind_count
                  from dba_hist_sqlstat s, dba_hist_sqlbind b
                  where s.dbid = b.dbid
                  and s.instance_number = b.instance_number
                   and s.snap_id = b.snap_id
                   and b.was_captured = 'YES'
                   and s.sql_id = b.sql_id
                  and s.dbid = $4
                  and s.sql_id = '$2'
                  and s.plan_hash_value = $3
                  group by s.snap_id,s.instance_number
                  order by 1;
!
exit 0
  fi
fi

if [ "$1" = "awr_top_dbtime" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_top_dbtime dbid inst [begin_id end_id]"
  fi

  if [ "$4" = "" ]; then
        # usage "ora awr_top_dbtime dbid inst"
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                connect $DBUSER
                set linesize 200
                set pagesize 0
                select 'ora awr_top_dbtime dbid inst' from dual;

                set pagesize 1500

                col "TOTAL_ELAPSED TIME (S)"   for 999,999,999,999,999.99
                col "TOTAL_EXECS"              for 999,999,999,999,999
                col "AVARAGE_ELAPSED TIME (S)" for 999,999,999,999,999.99

                select *
                  from (select distinct t.*, to_char(substr(s.sql_text, 1, 47)) "SQL_TEXT"
                          from (SELECT sum(ELAPSED_TIME_DELTA) / 1000000 "TOTAL_ELAPSED TIME (S)",
                                       sum(EXECUTIONS_DELTA) "TOTAL_EXECS",
                                                                                 CASE
                                                                                                    WHEN sum(EXECUTIONS_DELTA) = 0
                                                                                                    THEN 0
                                                                                                    ELSE
                                                                                                                sum(ELAPSED_TIME_DELTA) / sum(EXECUTIONS_DELTA) / 1000000
                                                                                  END AS         "AVARAGE_ELAPSED TIME (S)",
                                       sql_id
                                  FROM DBA_HIST_SQLSTAT SQS
                                 WHERE instance_number = $3
                                   AND DBID = $2
                                 group by sql_id) t,
                               dba_hist_sqltext s
                         where t.sql_id = s.sql_id
                         order by "TOTAL_ELAPSED TIME (S)" desc)
                 where rownum < 101
                  order by 1;
!
exit 0
  else
        # usage "ora awr_top_dbtime bid $2 eid $3 dbid $4 inst_id $5"
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected|successfully completed"
                connect $DBUSER
                set linesize 200
                set pagesize 0
                select 'ora awr_top_dbtime dbid $2 inst_id $3 bid $4 eid $5' from dual;

                set pagesize 1500

                col "TOTAL_ELAPSED TIME (S)"   for 999,999,999,999,999.99
                col "TOTAL_EXECS"              for 999,999,999,999,999
                col "AVARAGE_ELAPSED TIME (S)" for 999,999,999,999,999.99

                select *
                  from (select distinct t.*, to_char(substr(s.sql_text, 1, 47)) "SQL_TEXT"
                          from (SELECT sum(ELAPSED_TIME_DELTA) / 1000000 "TOTAL_ELAPSED TIME (S)",
                                       sum(EXECUTIONS_DELTA) "TOTAL_EXECS",
                                                   CASE
                                                                                                    WHEN sum(EXECUTIONS_DELTA) = 0
                                                                                                    THEN 0
                                                                                                    ELSE
                                                                                                                sum(ELAPSED_TIME_DELTA) / sum(EXECUTIONS_DELTA) / 1000000
                                                                                  END AS         "AVARAGE_ELAPSED TIME (S)",
                                       sql_id
                                  FROM DBA_HIST_SQLSTAT SQS
                                 WHERE EXECUTIONS_DELTA > 0
                                   AND instance_number = $3
                                   AND DBID = $2
                                   AND snap_id > $4 and snap_id <= $5
                                 group by sql_id) t,
                               dba_hist_sqltext s
                         where t.sql_id = s.sql_id
                         order by "TOTAL_ELAPSED TIME (S)" desc)
                 where rownum < 101
                                order by 1;
!
exit 0
  fi
fi

if [ "$1" = "awr_top_logical_reads" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_top_logical_reads dbid inst [begin_id end_id]"
  fi

        if [ "$4" = "" ]; then
                # usage "ora awr_top_logical_reads dbid inst"
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
                        set linesize 200
                        set pagesize 5000

                        col END_ID for 99999
                        col owner for a10
                        col tablespace_name for a15
                        col object_name for a20
                        col subobject_name for a20
                        col obj_type for a10

                        select s.snap_id AS "END_ID",
                               TO_CHAR(s.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                               lr.owner,
                               lr.tablespace_name,
                               lr.object_name,
                               lr.subobject_name,
                               lr.object_type,
                               lr.logical_reads_delta logical_reads
                          from (select snap_id,
                                       owner,
                                       tablespace_name,
                                       object_name,
                                       subobject_name,
                                       object_type,
                                       logical_reads_delta,
                                       dbid,
                                       instance_number
                                  from (select s.snap_id,
                                               o.owner,
                                               o.tablespace_name,
                                               o.object_name,
                                               o.subobject_name,
                                               o.object_type,
                                               s.logical_reads_delta,
                                               s.dbid,
                                               s.instance_number,
                                               ROW_NUMBER() OVER(PARTITION BY s.snap_id ORDER BY logical_reads_delta desc) rn
                                          from dba_hist_seg_stat s, dba_hist_seg_stat_obj o
                                         where s.obj# = o.obj#
                                           and s.dbid = o.dbid
                                           and s.dataobj# = o.dataobj#
                                           and s.dbid = $2
                                           and s.instance_number = $3
                                         order by 1)
                                 WHERE rn <= 1) lr,
                               dba_hist_snapshot s
                         where lr.snap_id = s.snap_id
                           and s.dbid = lr.dbid
                           and s.instance_number = lr.instance_number
                           order by s.snap_id;
!
exit 0
        else
          # usage "ora awr_top_logical_reads dbid inst bid eid"
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
                        set linesize 200
                        set pagesize 5000

                        col END_ID for 99999
                        col owner for a10
                        col tablespace_name for a15
                        col object_name for a20
                        col subobject_name for a20
                        col obj_type for a10

                        select s.snap_id AS "END_ID",
                               TO_CHAR(s.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                               lr.owner,
                               lr.tablespace_name,
                               lr.object_name,
                               lr.subobject_name,
                               lr.object_type,
                               lr.logical_reads_delta logical_reads
                          from (select snap_id,
                                       owner,
                                       tablespace_name,
                                       object_name,
                                       subobject_name,
                                       object_type,
                                       logical_reads_delta,
                                       dbid,
                                       instance_number
                                  from (select s.snap_id,
                                               o.owner,
                                               o.tablespace_name,
                                               o.object_name,
                                               o.subobject_name,
                                               o.object_type,
                                               s.logical_reads_delta,
                                               s.dbid,
                                               s.instance_number,
                                               ROW_NUMBER() OVER(PARTITION BY s.snap_id ORDER BY logical_reads_delta desc) rn
                                          from dba_hist_seg_stat s, dba_hist_seg_stat_obj o
                                         where s.obj# = o.obj#
                                           and s.dbid = o.dbid
                                           and s.dataobj# = o.dataobj#
                                           and s.dbid = $2
                                           and s.instance_number = $3
                                         order by 1)
                                 WHERE rn <= 1) lr,
                               dba_hist_snapshot s
                         where lr.snap_id = s.snap_id
                           and s.dbid = lr.dbid
                           and s.instance_number = lr.instance_number
                           order by s.snap_id;
!
exit 0
        fi
fi

if [ "$1" = "awr_top_rowlock" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_top_rowlock dbid inst begin_id end_id"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                ALTER SESSION SET nls_timestamp_format='yyyy-mm-dd hh24:mi:ss';
                set linesize 200
                set pagesize 5000

                col snap_id for 99999
                col owner for a15
                col BEGIN_INTERVAL_TIME for a20
                col tablespace_name for a15
                col object_name for a25
                col subobject_name for a15
                col obj_type for a10

                SELECT P.snap_id,
                  P.begin_interval_time,
                  O.owner,
                  O.object_name,
                  O.subobject_name,
                  O.object_type,
                  S.row_lock_waits_delta
                FROM dba_hist_seg_stat S,
                  dba_hist_seg_stat_obj O,
                  dba_hist_snapshot P
                WHERE S.dbid               =O.dbid
                AND S.dbid                 =$2
                AND O.dbid                 =$2
                AND S.ts#                  =O.ts#
                AND S.obj#                 =O.obj#
                AND S.dataobj#             =O.dataobj#
                AND S.snap_id              =P.snap_id
                AND S.dbid                 =P.dbid
                AND S.instance_number      =P.instance_number
                AND S.instance_number      =$3
                AND P.instance_number      =$3
                AND S.row_lock_waits_delta > 0
                AND P.snap_id BETWEEN      $4  AND $5
                ORDER BY 1,3,4;
!
exit 0
fi

if [ "$1" = "awr_top10_events" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_top10_events dbid inst begin_id end_id"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 200
                set pagesize 5000

                col event for a50
                col time for 9999999999999.9
                col avwait for 999999999.9
                col pctwtt for 99.9
                col wcls for a20

                select t.event,
                       t.wtfg waits,
                       t.tmfg / 1000000 time,
                       decode(t.wtfg, 0, to_number(null), t.tmfg / t.wtfg) / 1000 avwait,
                       decode(t.dbtm, 0, to_number(null), t.tmfg / t.dbtm) * 100 pctwtt,
                       t.wcls
                  FROM (select bid,
                               (select case
                                         when e.value is not null then
                                          (e.value - nvl(b.value, 0))
                                         else
                                          0
                                       end dbtm
                                  from dba_hist_sys_time_model b, dba_hist_sys_time_model e
                                 WHERE b.snap_id = $4
                                   and b.stat_name = 'DB time'
                                   and e.stat_name = 'DB time'
                                   and e.snap_id = $5
                                   and e.dbid = $2
                                   and e.instance_number = $3
                                   and e.dbid = b.dbid
                                   and e.instance_number = b.instance_number) AS dbtm,
                               eid,
                               dbid,
                               instance_number,
                               event,
                               wtfg,
                               tmfg,
                               wcls
                          from (select bid,
                                       eid,
                                       dbid,
                                       instance_number,
                                       event,
                                       wtfg,
                                       ttofg,
                                       tmfg,
                                       wcls
                                  from (SELECT b.snap_id bid,
                                               e.snap_id eid,
                                               b.dbid,
                                               b.instance_number,
                                               e.event_name event,
                                               case
                                                 when e.total_waits_fg is not null then
                                                  e.total_waits_fg - nvl(b.total_waits_fg, 0)
                                                 else
                                                  (e.total_waits - nvl(b.total_waits, 0)) -
                                                  greatest(0,
                                                           (nvl(ebg.total_waits, 0) -
                                                           nvl(bbg.total_waits, 0)))
                                               end wtfg,
                                               case
                                                 when e.total_timeouts_fg is not null then
                                                  e.total_timeouts_fg -
                                                  nvl(b.total_timeouts_fg, 0)
                                                 else
                                                  (e.total_timeouts - nvl(b.total_timeouts, 0)) -
                                                  greatest(0,
                                                           (nvl(ebg.total_timeouts, 0) -
                                                           nvl(bbg.total_timeouts, 0)))
                                               end ttofg,
                                               case
                                                 when e.time_waited_micro_fg is not null then
                                                  e.time_waited_micro_fg -
                                                  nvl(b.time_waited_micro_fg, 0)
                                                 else
                                                  (e.time_waited_micro -
                                                  nvl(b.time_waited_micro, 0)) -
                                                  greatest(0,
                                                           (nvl(ebg.time_waited_micro, 0) -
                                                           nvl(bbg.time_waited_micro, 0)))
                                               end tmfg,
                                               e.wait_class wcls
                                          from dba_hist_system_event     b,
                                               dba_hist_system_event     e,
                                               dba_hist_bg_event_summary bbg,
                                               dba_hist_bg_event_summary ebg
                                         where b.snap_id(+) = $4
                                           and e.snap_id = $5
                                           and bbg.snap_id(+) = $4
                                           and ebg.snap_id(+) = $5
                                           and e.dbid = $2
                                           and e.instance_number = $3
                                           and e.dbid = b.dbid(+)
                                           and e.instance_number = b.instance_number(+)
                                           and e.event_id = b.event_id(+)
                                           and e.dbid = ebg.dbid(+)
                                           and e.instance_number = ebg.instance_number(+)
                                           and e.event_id = ebg.event_id(+)
                                           and e.dbid = bbg.dbid(+)
                                           and e.instance_number = bbg.instance_number(+)
                                           and e.event_id = bbg.event_id(+)
                                           and e.total_waits > nvl(b.total_waits, 0)
                                           and e.wait_class <> 'Idle'
                                        union all
                                        select b.snap_id bid,
                                               e.snap_id eid,
                                               b.dbid,
                                               b.instance_number,
                                               'DB CPU' event,
                                               to_number(null) wtfg,
                                               to_number(null) ttofg,
                                               case
                                                 when e.value is not null then
                                                  (e.value - nvl(b.value, 0))
                                                 else
                                                  0
                                               end tcpu,
                                               ' ' wcls
                                          from dba_hist_sys_time_model b,
                                               dba_hist_sys_time_model e
                                         WHERE b.snap_id(+) = $4
                                           and b.stat_name = 'DB CPU'
                                           and e.stat_name = 'DB CPU'
                                           and e.snap_id = $5
                                           and e.dbid = $2
                                           and e.instance_number = $3
                                           and e.dbid = b.dbid(+)
                                           and e.instance_number = b.instance_number(+))
                                 order by tmfg desc, wtfg desc)
                         where rownum <= 10) t;
!
exit 0
fi

if [ "$1" = "awr_sga_target_advice" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_sga_target_advice dbid inst [factor] "
  fi

        # ora awr_sga_target_advice dbid inst
  if [ "$4" = "" ]; then
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set echo on
    set linesize 130
    set pagesize 6000

    col snap_time for a20
    col "Est DB Time (s)"   for 999,999,999,999,999
    col ESTD_PHYSICAL_READS for 999,999,999,999,999

                SELECT a.snap_id  AS "END_SNAP_ID", TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                        a.sga_size "SGA_Target_MB",
                        a.sga_size_factor "SGA_FACTOR",
                        a.estd_db_time "Est DB Time (s)",
                        a.estd_physical_reads "ESTD_PHYSICAL_READS"
                  from
                                (select snap_id,sga_size, sga_size_factor, estd_db_time, estd_physical_reads
                                  from dba_hist_sga_target_advice e
                                 where dbid = $2
                                   and instance_number = $3
                                   and sga_size_factor = 1
                                 order by sga_size) a,
                        dba_hist_snapshot b
                      where b.dbid = $2
                                                AND a.snap_id = b.snap_id
                                                AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
!
exit 0
        else
                # ora awr_sga_target_advice dbid inst fact
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set echo on
    set linesize 130
    set pagesize 6000

    col snap_time for a20
    col "Est DB Time (s)"   for 999,999,999,999,999
    col ESTD_PHYSICAL_READS for 999,999,999,999,999

                SELECT a.snap_id  AS "END_SNAP_ID", TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                        a.sga_size "SGA_Target_MB",
                        a.sga_size_factor "SGA_FACTOR",
                        a.estd_db_time "Est DB Time (s)",
                        a.estd_physical_reads "ESTD_PHYSICAL_READS"
                  from
                                (select snap_id,sga_size, sga_size_factor, estd_db_time, estd_physical_reads
                                  from dba_hist_sga_target_advice e
                                 where dbid = $2
                                   and instance_number = $3
                                   and sga_size_factor = $4
                                 order by sga_size) a,
                        dba_hist_snapshot b
                      where b.dbid = $2
                                                AND a.snap_id = b.snap_id
                                                AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
!
exit 0
        fi
fi

if [ "$1" = "awr_shared_pool_advice" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_shared_pool_advice dbid inst [factor] "
  fi

        # ora awr_shared_pool_advice dbid inst
  if [ "$4" = "" ]; then
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set echo on
    set linesize 130
    set pagesize 6000

    col snap_time for a20
    col "Shared Pool Size(M)"   for 999,999,999,999
    col "SP Size Factr" for 999.99
    col estd_lc_memory_objects for 999,999,999
    col estd_lc_time_saved for 999,999,999,999
    col estd_lc_load_time for 999,999,999,999
    col estd_lc_time_saved_factor for 999,999.99
    col estd_lc_size for 999,999,999,999
    col estd_lc_size for 999,999,999,999
    col estd_lc_size for 999,999,999,999

                SELECT adv.snap_id AS "END_SNAP_ID",
                       TO_CHAR(s.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                       adv.shared_pool_size_for_estimate "Shared Pool Size(M)",
                       adv.shared_pool_size_factor "SP Size Factr",
                       adv.estd_lc_size "Est LC Size (M)",
                       adv.estd_lc_memory_objects "Est LC Mem Obj",
                       adv.estd_lc_time_saved "Est LC Time Saved (s)",
                       adv.estd_lc_time_saved_factor "Est LC Time Saved Factr",
                       adv.estd_lc_load_time "Est LC Load Time (s)",
                       adv.estd_lc_load_time_factor "Est LC Load Time Factr",
                       adv.estd_lc_memory_object_hits_k "Est LC Mem Obj Hits (K)"
                  from (select snap_id,
                               shared_pool_size_for_estimate,
                               shared_pool_size_factor,
                               estd_lc_size,
                               estd_lc_memory_objects,
                               estd_lc_time_saved,
                               estd_lc_time_saved_factor,
                               estd_lc_load_time,
                               estd_lc_load_time_factor,
                               estd_lc_memory_object_hits / 1000 estd_lc_memory_object_hits_k
                          from dba_hist_shared_pool_advice
                         where shared_pool_size_factor = 1
                           and dbid = $2
                           and instance_number = $3) adv,
                       dba_hist_snapshot s
                 where s.dbid = $2
                   AND adv.snap_id = s.snap_id
                   AND s.INSTANCE_NUMBER = $3
                 ORDER BY 1;
!
exit 0
        else
                # ora awr_shared_pool_advice dbid inst fact
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set echo on
    set linesize 130
    set pagesize 6000

    col snap_time for a20
    col "Shared Pool Size(M)"   for 999,999,999,999
    col "SP Size Factr" for 999.99
    col estd_lc_memory_objects for 999,999,999
    col estd_lc_time_saved for 999,999,999,999
    col estd_lc_load_time for 999,999,999,999
    col estd_lc_time_saved_factor for 999,999.99
    col estd_lc_size for 999,999,999,999
    col estd_lc_size for 999,999,999,999
    col estd_lc_size for 999,999,999,999

                SELECT adv.snap_id AS "END_SNAP_ID",
                       TO_CHAR(s.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                       adv.shared_pool_size_for_estimate "Shared Pool Size(M)",
                       adv.shared_pool_size_factor "SP Size Factr",
                       adv.estd_lc_size "Est LC Size (M)",
                       adv.estd_lc_memory_objects "Est LC Mem Obj",
                       adv.estd_lc_time_saved "Est LC Time Saved (s)",
                       adv.estd_lc_time_saved_factor "Est LC Time Saved Factr",
                       adv.estd_lc_load_time "Est LC Load Time (s)",
                       adv.estd_lc_load_time_factor "Est LC Load Time Factr",
                       adv.estd_lc_memory_object_hits_k "Est LC Mem Obj Hits (K)"
                  from (select snap_id,
                               shared_pool_size_for_estimate,
                               shared_pool_size_factor,
                               estd_lc_size,
                               estd_lc_memory_objects,
                               estd_lc_time_saved,
                               estd_lc_time_saved_factor,
                               estd_lc_load_time,
                               estd_lc_load_time_factor,
                               estd_lc_memory_object_hits / 1000 estd_lc_memory_object_hits_k
                          from dba_hist_shared_pool_advice
                         where shared_pool_size_factor = $4
                           and dbid = $2
                           and instance_number = $3) adv,
                       dba_hist_snapshot s
                 where s.dbid = $2
                   AND adv.snap_id = s.snap_id
                   AND s.INSTANCE_NUMBER = $3
                 ORDER BY 1;
!
exit 0
        fi
fi

if [ "$1" = "awr_pga_target_advice" ]; then
  if [ "$2" = "" ]; then
    usage "ora awr_pga_target_advice dbid inst [factor] "
  fi

        # ora awr_pga_target_advice dbid inst
  if [ "$4" = "" ]; then
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set echo on
    set linesize 130
    set pagesize 6000

    col snap_time for a20
    col ESTD_EXTRA_MBYTES_RW for 999,999,999,999,999.99

                SELECT a.snap_id  AS "END_SNAP_ID", TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                        a.PGA_Target_Est_MB "PGA_Target_MB",
                        a.PGA_TARGET_FACTOR "PGA_FACTOR",
                        a.ESTD_EXTRA_MBYTES_RW,
                        a.ESTD_PGA_CACHE_HIT_PERCENTAGE "ESTD_PGA_HIT_PER",
                        a.ESTD_OVERALLOC_COUNT
                  from
                                (select snap_id,
                       PGA_TARGET_FOR_ESTIMATE/1024/1024 PGA_Target_Est_MB,
                       PGA_TARGET_FACTOR,
                       ESTD_EXTRA_BYTES_RW/1024/1024 ESTD_EXTRA_MBYTES_RW ,
                       ESTD_PGA_CACHE_HIT_PERCENTAGE,
                       ESTD_OVERALLOC_COUNT
                        from dba_hist_pga_target_advice t
                      where dbid = $2 and instance_number = $3
                        and pga_target_factor = 1) a,
                        dba_hist_snapshot b
                      where b.dbid = $2
                                                AND a.snap_id = b.snap_id
                                                AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
!
exit 0
        else
                # ora awr_pga_target_advice dbid inst fact
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER

    set echo on
    set linesize 130
    set pagesize 6000

    col snap_time for a20
    col ESTD_EXTRA_MBYTES_RW for 999,999,999,999,999.99

                SELECT a.snap_id  AS "END_SNAP_ID", TO_CHAR(b.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') snap_time,
                        a.PGA_Target_Est_MB "PGA_Target_MB",
                        a.PGA_TARGET_FACTOR "PGA_FACTOR",
                        a.ESTD_EXTRA_MBYTES_RW,
                        a.ESTD_PGA_CACHE_HIT_PERCENTAGE "ESTD_PGA_HIT_PER",
                        a.ESTD_OVERALLOC_COUNT
                  from
                                (select snap_id,
                       PGA_TARGET_FOR_ESTIMATE/1024/1024 PGA_Target_Est_MB,
                       PGA_TARGET_FACTOR,
                       ESTD_EXTRA_BYTES_RW/1024/1024 ESTD_EXTRA_MBYTES_RW ,
                       ESTD_PGA_CACHE_HIT_PERCENTAGE,
                       ESTD_OVERALLOC_COUNT
                        from dba_hist_pga_target_advice t
                      where dbid = $2 and instance_number = $3
                        and pga_target_factor = $4) a,
                        dba_hist_snapshot b
                      where b.dbid = $2
                                                AND a.snap_id = b.snap_id
                                                AND b.INSTANCE_NUMBER = $3
                                        ORDER BY 1;
!
exit 0
        fi
fi

if [ "$1" = "top_buffers_gets" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT * FROM
                (SELECT sql_id, substr(sql_text,1,40) sql,
                buffer_gets, executions, buffer_gets/executions "Gets/Exec",
                hash_value,address
                FROM V\$SQLAREA
                WHERE buffer_gets > 10000 and executions > 0
                ORDER BY buffer_gets DESC)
                WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT * FROM
                (SELECT sql_id, substr(sql_text,1,40) sql,
                buffer_gets, executions, buffer_gets/executions "Gets/Exec",
                hash_value,address
                FROM V\$SQLAREA
                WHERE buffer_gets > 10000 and executions > 0
                ORDER BY buffer_gets DESC)
                WHERE rownum <= $2;
!
exit 0
        fi
fi

if [ "$1" = "top_physical_reads" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    disk_reads,
                    executions,
                    decode(executions,0,0,disk_reads/executions) "Reads/Exec",
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE disk_reads > 1000
                  ORDER BY disk_reads DESC
                  )
                WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    disk_reads,
                    executions,
                    disk_reads/executions "Reads/Exec",
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE disk_reads > 1000
                  ORDER BY disk_reads DESC
                  )
                WHERE rownum <= $2;
!
exit 0
        fi
fi

if [ "$1" = "top_executions" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    executions,
                    rows_processed,
                    rows_processed/executions "Rows/Exec",
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE executions > 100
                  ORDER BY executions DESC
                  )
                WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    executions,
                    rows_processed,
                    rows_processed/executions "Rows/Exec",
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE executions > 100
                  ORDER BY executions DESC
                  )
                WHERE rownum <= $2;
!
exit 0
        fi
fi

if [ "$1" = "top_parse_calls" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    parse_calls,
                    executions,
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE parse_calls > 1000
                  ORDER BY parse_calls DESC
                  )
                WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    parse_calls,
                    executions,
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE parse_calls > 1000
                  ORDER BY parse_calls DESC
                  )
                WHERE rownum <= $2;
!
exit 0
        fi
fi



if [ "$1" = "top_sharable_memory" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    sharable_mem,
                    executions,
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE sharable_mem > 1048576
                  ORDER BY sharable_mem DESC
                  )
                WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    sharable_mem,
                    executions,
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE sharable_mem > 1048576
                  ORDER BY sharable_mem DESC
                  )
                WHERE rownum <= $2;
!
exit 0
        fi
fi


if [ "$1" = "top_version_count" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    version_count,
                    executions,
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE version_count > 20
                  ORDER BY version_count DESC
                  )
                WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) SQL,
                    version_count,
                    executions,
                    hash_value,
                    address
                  FROM V\$SQLAREA
                  WHERE version_count > 20
                  ORDER BY version_count DESC
                  )
                WHERE rownum <= $2;
!
exit 0
        fi
fi


if [ "$1" = "top_cpu_usage" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) sql,
                    ROUND(cpu_time    /1000000) cpu_time,
                    ROUND(elapsed_time/1000000) elapsed_time,
                    disk_reads,
                    buffer_gets,
                    rows_processed
                  FROM v\$sqlarea
                  ORDER BY cpu_time DESC,
                    disk_reads DESC
                  )
                WHERE rownum < 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 120
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
                col SQL_ID for a13

                SELECT *
                FROM
                  (SELECT sql_id,
                    SUBSTR(sql_text,1,40) sql,
                    ROUND(cpu_time    /1000000) cpu_time,
                    ROUND(elapsed_time/1000000) elapsed_time,
                    disk_reads,
                    buffer_gets,
                    rows_processed
                  FROM v\$sqlarea
                  ORDER BY cpu_time DESC,
                    disk_reads DESC
                  )
                WHERE rownum < $2;
!
exit 0
        fi
fi


if [ "$1" = "top_running_time" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 150
    set pagesize 100

    col SQL_ID for a13
    col sql for a35
    col "Run Time" for 999999.99

    SELECT *
    FROM
      (SELECT t.sql_id,
        SUBSTR(sql_text,1,35) sql,
        (t.last_active_time-to_date(t.first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60 "Run Time",
        --disk_reads,
        --buffer_gets,
        rows_processed "Rows_proc",
        to_char(t.last_active_time, 'yyyy-mm-dd hh24:mi:ss') "Last active",
        to_char(t.last_load_time, 'yyyy-mm-dd hh24:mi:ss') "Load lib cache",
        t.first_load_time
      FROM v\$sqlarea t
      ORDER BY t.first_load_time DESC
      )
    WHERE rownum <= 10;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 150
                set pagesize 100

                col SQL_ID for a13
                col sql for a40
    col "Run Time" for 999999.99

    SELECT *
    FROM
      (SELECT t.sql_id,
        SUBSTR(sql_text,1,35) sql,
        (t.last_active_time-to_date(t.first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60 "Run Time",
        --disk_reads,
        --buffer_gets,
        rows_processed "Rows_proc",
        to_char(t.last_active_time, 'yyyy-mm-dd hh24:mi:ss') "Last active",
        to_char(t.last_load_time, 'yyyy-mm-dd hh24:mi:ss') "Load lib cache",
        t.first_load_time
      FROM v\$sqlarea t
      ORDER BY t.first_load_time DESC
      )
    WHERE rownum <= $2;
!
exit 0
        fi
fi

if [ "$1" = "cache_buffers_chains" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set pagesize 10000
    set long 10000
                select *
                        from (select addr, child#, gets, sleeps from v\$latch_children
                                where name = 'cache buffers chains'
                                order by sleeps desc)
                         where rownum < 20;
!
exit 0
fi

if [ "$1" = "hot_block" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
    select 'p1' P1, 'p2' P2 from dual;
!
exit 0
fi


if [ "$1" = "top_segments" ]; then
  if [ "$2" = "" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
        set pagesize 100
                        SET LINESIZE 200
                        SET VERIFY OFF

                        SELECT *
                        FROM   (SELECT name,
                                       addr,
                                       gets,
                                       misses,
                                       sleeps
                                FROM   v\$latch_children
                                WHERE  name = 'cache buffers chains'
                                AND    misses > 0
                                ORDER BY misses DESC)
                        WHERE  rownum < 11;

                        ACCEPT address PROMPT "Enter ADDR: "

                        COLUMN owner FORMAT A15
                        COLUMN object_name FORMAT A30
                        COLUMN subobject_name FORMAT A20

                        SELECT *
                        FROM   (SELECT o.owner,
                                       o.object_name,
                                       o.subobject_name,
                                       bh.tch,
                                       bh.obj,
                                       bh.file#,
                                       bh.dbablk,
                                       bh.class,
                                       bh.state
                                FROM   x\$bh bh,
                                       dba_objects o
                                WHERE  o.data_object_id = bh.obj
                                AND    hladdr = '&address'
                                ORDER BY tch DESC)
                        WHERE  rownum < 11;
!
exit 0
        else
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 150
                set pagesize 100

                COLUMN owner               FORMAT a10
                COLUMN segment_name        FORMAT a30
                COLUMN partition_name      FORMAT a20
                COLUMN segment_type        FORMAT a10
                COLUMN tablespace_name     FORMAT a10
                COLUMN bytes               FORMAT 999,999,999,999,999,999
                COLUMN extents             FORMAT 999,999,999,999

                SELECT
                    a.owner
                  , a.segment_name
                  , a.partition_name
                  , a.segment_type
                  , a.tablespace_name
                  , a.bytes
                  , a.extents
                FROM
                    (select
                         b.owner
                       , b.segment_name
                       , b.partition_name
                       , b.segment_type
                       , b.tablespace_name
                       , b.bytes
                       , b.extents
                     from
                         dba_segments b
                     order by
                         b.bytes desc
                    ) a
    WHERE rownum <= $2;
!
exit 0
        fi
fi

if [ "$1" = "tab_frag" ]; then
  if [ "$2" = "" ]; then
    usage "owner is missing"
  fi
        if [ "$3" = "" ]; then
          # ora tab_frag $owner
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 130
            set pagesize 6000

                        select table_name,
                               round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024), 2) "total",
                               round((num_rows * avg_row_len / 1024 / 1024 / 1024), 2) "used",
                               (1 - round((num_rows * avg_row_len / 1024 / 1024 / 1024) /
                                          (blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024),
                                          2)) * 100 || '%' "fragment_per",
                               round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') - num_rows * avg_row_len) / 1024 / 1024 / 1024,
                                     2) "frag_size g"
                          from dba_tables
                         where round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') - num_rows * avg_row_len) / 1024 / 1024 / 1024,
                                     2) > 0.1
                           and owner = upper('$2')
                         order by 5 desc;
!
exit 0
        else
          # ora tab_frag [owner] [frag_percent]
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 130
            set pagesize 6000

                        select table_name,
                               round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024), 2) "total",
                               round((num_rows * avg_row_len / 1024 / 1024 / 1024), 2) "used",
                               (1 - round((num_rows * avg_row_len / 1024 / 1024 / 1024) /
                                          (blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024),
                                          2)) * 100 || '%' "fragment_per",
                               round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') - num_rows * avg_row_len) / 1024 / 1024 / 1024,
                                     2) "frag_size g"
                          from dba_tables
                         where round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') - num_rows * avg_row_len) / 1024 / 1024 / 1024,
                                     2) > $3
                           and owner = upper('$2')
                         order by 5 desc;
!
exit 0
        fi
fi

if [ "$1" = "index_frag" ]; then
  if [ "$2" = "" ]; then
    usage "owner is missing"
  fi
        if [ "$3" = "" ]; then
          # ora index_frag $owner
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 130

                        select table_name,
                               round(BLOCKS * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024, 2) total_size,
                               round(num_rows * AVG_ROW_LEN / 1024 / 1024 / 1024, 2) used_size,
                               round(((BLOCKS * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024) -
                                     (num_rows * AVG_ROW_LEN / 1024 / 1024 / 1024)),
                                     2) wasted_size,
                               round(round(((BLOCKS * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024) -
                                           (num_rows * AVG_ROW_LEN / 1024 / 1024 / 1024)),
                                           2) / round(BLOCKS * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024, 2),
                                     2) * 100 || '%' wasted_percent
                          from dba_tables
                         where owner = '$2'
                           and round(BLOCKS * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024, 2) <> 0
                         order by 2;
!
exit 0
        else
          # ora index_frag [owner] [frag_percent]
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 130

                        select table_name,
                               round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024), 2) "total",
                               round((num_rows * avg_row_len / 1024 / 1024 / 1024), 2) "used",
                               (1 - round((num_rows * avg_row_len / 1024 / 1024 / 1024) /
                                          (blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') / 1024 / 1024 / 1024),
                                          2)) * 100 || '%' "fragment_per",
                               round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') - num_rows * avg_row_len) / 1024 / 1024 / 1024,
                                     2) "frag_size g"
                          from dba_tables
                         where round((blocks * (SELECT value FROM V\$PARAMETER
                                WHERE name='db_block_size') - num_rows * avg_row_len) / 1024 / 1024 / 1024,
                                     2) > $3
                           and owner = '$2'
                         order by 5 desc;
!
exit 0
        fi
fi

if [ "$1" = "block_session" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120

                SELECT DISTINCT A.SID              "waiting sid",
                                D.SQL_TEXT         "waiting SQL",
                                A.ROW_WAIT_OBJ#    "locked object",
                                A.BLOCKING_SESSION "blocking sid",
                                C.SQL_TEXT         "SQL from blocking session"
                  FROM V\$SESSION A, V\$ACTIVE_SESSION_HISTORY B, V\$SQL C, V\$SQL D
                 WHERE A.EVENT = 'enq: TX - row lock contention'
                   AND A.SQL_ID = D.SQL_ID
                   AND A.BLOCKING_SESSION = B.SESSION_ID
                   AND C.SQL_ID = B.SQL_ID
                   AND B.CURRENT_OBJ# = A.ROW_WAIT_OBJ#
                   AND B.CURRENT_FILE# = A.ROW_WAIT_FILE#
                   AND B.CURRENT_BLOCK# = A.ROW_WAIT_BLOCK#;
!
exit 0
fi

if [ "$1" = "ulock" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120

                set echo off
                set pagesize 60
                Column SID         FORMAT 999 heading "Sess|ID "
                COLUMN OBJECT_NAME FORMAT A17 heading "OBJ NAME or|TRANS_ID" Trunc
                COLUMN OSUSER      FORMAT A10 heading "Op Sys|User ID"
                COLUMN USERNAME    FORMAT A8
                COLUMN TERMINAL    FORMAT A8  trunc
                select B.SID, C.USERNAME, C.OSUSER, C.TERMINAL,
                       DECODE(B.ID2, 0, A.OBJECT_NAME,
                            'Trans-'||to_char(B.ID1)) OBJECT_NAME,
                     B.TYPE,
                       DECODE(B.LMODE,0,'--Waiting--',
                                      1,'Null',
                                      2,'Row Share',
                                      3,'Row Excl',
                                   4,'Share',
                                      5,'Sha Row Exc',
                           6,'Exclusive',
                                        'Other') "Lock Mode",
                       DECODE(B.REQUEST,0,' ',
                                      1,'Null',
                                      2,'Row Share',
                                      3,'Row Excl',
                                      4,'Share',
                                      5,'Sha Row Exc',
                                      6,'Exclusive',
                                     'Other') "Req Mode"
                  from DBA_OBJECTS A, V\$LOCK B, V\$SESSION C
                where A.OBJECT_ID(+) = B.ID1
                  and B.SID = C.SID
                  and C.USERNAME is not null
                order by B.SID, B.ID2;
!
exit 0
fi

if [ "$1" = "locksql" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set pagesize 60
                set linesize 132

                select s.username username,
                       a.sid sid,
                       a.owner||'.'||a.object object,
                       s.lockwait,
                       t.sql_text SQL
                from   v\$sqltext t,
                       v\$session s,
                       v\$access a
                where  t.address=s.sql_address
                and    t.hash_value=s.sql_hash_value
                and    s.sid = a.sid
                and    a.owner != 'SYS'
                and    upper(substr(a.object,1,2)) != 'V$'
/
!
exit 0
fi

if [ "$1" = "db_usage_hwm" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120

                COLUMN name  FORMAT A40
                COLUMN highwater FORMAT 999999999999
                COLUMN last_value FORMAT 999999999999
                SET PAGESIZE 600

                SELECT hwm1.name,
                       hwm1.highwater,
                       hwm1.last_value
                FROM   dba_high_water_mark_statistics hwm1
                WHERE  hwm1.version = (SELECT MAX(hwm2.version)
                                       FROM   dba_high_water_mark_statistics hwm2
                                       WHERE  hwm2.name = hwm1.name)
                ORDER BY hwm1.name;
                COLUMN FORMAT DEFAULT
!
exit 0
fi

if [ "$1" = "row_chain" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set linesize 150
                set pagesize 100
                COLUMN owner              FORMAT a10
                COLUMN table_name         FORMAT a30
                COLUMN partition_name     FORMAT a20
                COLUMN num_rows           FORMAT 999,999,999
                COLUMN pct_chained_rows   FORMAT a65
                COLUMN avg_row_length     FORMAT 9,999,999

                SELECT
                    owner                               owner
                  , table_name                          table_name
                  , ''                                  partition_name
                  , num_rows                            num_rows
                  , ROUND((chain_cnt/num_rows)*100, 2)  pct_chained_rows
                  , avg_row_len                         avg_row_length
                FROM
                    (select
                         owner
                       , table_name
                       , chain_cnt
                       , num_rows
                       , avg_row_len
                     from
                         sys.dba_tables
                     where
                           chain_cnt is not null
                       and num_rows is not null
                       and chain_cnt > 0
                       and num_rows > 0
                       and owner != 'SYS')
                UNION ALL
                SELECT
                    table_owner                         owner
                  , table_name                          table_name
                  , partition_name                      partition_name
                  , num_rows                            num_rows
                  , ROUND((chain_cnt/num_rows)*100, 2)  pct_chained_rows
                  , avg_row_len                         avg_row_length
                FROM
                    (select
                         table_owner
                       , table_name
                       , partition_name
                       , chain_cnt
                       , num_rows
                       , avg_row_len
                     from
                         sys.dba_tab_partitions
                     where
                           chain_cnt is not null
                       and num_rows is not null
                       and chain_cnt > 0
                       and num_rows > 0
                       and table_owner != 'SYS') b
                WHERE (chain_cnt/num_rows)*100 > 10;
!
exit 0
fi

if [ "$1" = "redo_switch" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                SET linesize 150
                SET pagesize 100
                COLUMN DAY FORMAT a6
                COLUMN H00 FORMAT 999
                COLUMN H01 FORMAT 999
                COLUMN H02 FORMAT 999
                COLUMN H03 FORMAT 999
                COLUMN H04 FORMAT 999
                COLUMN H05 FORMAT 999
                COLUMN H06 FORMAT 999
                COLUMN H07 FORMAT 999
                COLUMN H08 FORMAT 999
                COLUMN H09 FORMAT 999
                COLUMN H10 FORMAT 999
                COLUMN H11 FORMAT 999
                COLUMN H12 FORMAT 999
                COLUMN H13 FORMAT 999
                COLUMN H14 FORMAT 999
                COLUMN H15 FORMAT 999
                COLUMN H16 FORMAT 999
                COLUMN H17 FORMAT 999
                COLUMN H18 FORMAT 999
                COLUMN H19 FORMAT 999
                COLUMN H20 FORMAT 999
                COLUMN H21 FORMAT 999
                COLUMN H22 FORMAT 999
                COLUMN H23 FORMAT 999
                COLUMN TOTAL FORMAT 999
                SELECT TO_CHAR(first_time, 'MM/DD') DAY ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'00',1,0)) H00 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'01',1,0)) H01 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'02',1,0)) H02 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'03',1,0)) H03 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'04',1,0)) H04 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'05',1,0)) H05 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'06',1,0)) H06 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'07',1,0)) H07 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'08',1,0)) H08 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'09',1,0)) H09 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'10',1,0)) H10 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'11',1,0)) H11 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'12',1,0)) H12 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'13',1,0)) H13 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'14',1,0)) H14 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'15',1,0)) H15 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'16',1,0)) H16 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'17',1,0)) H17 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'18',1,0)) H18 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'19',1,0)) H19 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'20',1,0)) H20 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'21',1,0)) H21 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'22',1,0)) H22 ,
                  SUM(DECODE(TO_CHAR(first_time, 'HH24'),'23',1,0)) H23 ,
                  COUNT(*) TOTAL
                FROM v\$archived_log a
                WHERE first_time BETWEEN (ADD_MONTHS (TRUNC (SYSDATE, 'mm'), -1)) AND SYSDATE
                   and thread# = (select thread# from v\$instance)
                GROUP BY TO_CHAR(first_time, 'MM/DD')
                ORDER BY TO_CHAR(first_time, 'MM/DD');
!
exit 0
fi

if [ "$1" = "ptest" ]; then
        if [ "$2" != "" ]; then
          case $2 in
            1-3)
              echo "inst $2"
              ;;

            4-9)
              echo "topn $2"
              ;;

            [1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9][0-9][0-9])
              echo "begin_snap $2"
              ;;
            *)
              echo "dbid $2 "
              ;;
          esac
        fi
fi

if [ "$1" = "create_showspace" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                CREATE OR REPLACE PROCEDURE show_space(p_segname_1   IN VARCHAR2,
                                                       p_type_1      IN VARCHAR2 DEFAULT 'TABLE',
                                                       p_space       IN VARCHAR2 DEFAULT 'MANUAL',
                                                       p_analyzed    IN VARCHAR2 DEFAULT 'N',
                                                       p_partition_1 IN VARCHAR2 DEFAULT NULL,
                                                       p_owner_1     IN VARCHAR2 DEFAULT USER)
                  AUTHID CURRENT_USER AS
                  p_segname   VARCHAR2(100);
                  p_type      VARCHAR2(30);
                  p_owner     VARCHAR2(30);
                  p_partition VARCHAR2(50);

                  l_unformatted_blocks NUMBER;
                  l_unformatted_bytes  NUMBER;
                  l_fs1_blocks         NUMBER;
                  l_fs1_bytes          NUMBER;
                  l_fs2_blocks         NUMBER;
                  l_fs2_bytes          NUMBER;
                  l_fs3_blocks         NUMBER;
                  l_fs3_bytes          NUMBER;
                  l_fs4_blocks         NUMBER;
                  l_fs4_bytes          NUMBER;
                  l_full_blocks        NUMBER;
                  l_full_bytes         NUMBER;

                  l_free_blks          NUMBER;
                  l_total_blocks       NUMBER;
                  l_total_bytes        NUMBER;
                  l_unused_blocks      NUMBER;
                  l_unused_bytes       NUMBER;
                  l_LastUsedExtFileId  NUMBER;
                  l_LastUsedExtBlockId NUMBER;
                  l_LAST_USED_BLOCK    NUMBER;

                  PROCEDURE p(p_label IN VARCHAR2, p_num IN NUMBER) IS
                  BEGIN
                    DBMS_OUTPUT.put_line(RPAD(p_label, 40, '.') || p_num);
                  END;
                BEGIN
                  p_segname   := UPPER(p_segname_1);
                  p_owner     := UPPER(p_owner_1);
                  p_type      := p_type_1;
                  p_partition := UPPER(p_partition_1);

                  IF (p_type_1 = 'i' OR p_type_1 = 'I') THEN
                    p_type := 'INDEX';
                  END IF;

                  IF (p_type_1 = 't' OR p_type_1 = 'T') THEN
                    p_type := 'TABLE';
                  END IF;

                  IF (p_type_1 = 'tp' OR p_type_1 = 'TP') THEN
                    p_type := 'TABLE PARTITION';
                  END IF;

                  IF (p_type_1 = 'ip' OR p_type_1 = 'IP') THEN
                    p_type := 'INDEX PARTITION';
                  END IF;

                  IF (p_type_1 = 'c' OR p_type_1 = 'C') THEN
                    p_type := 'CLUSTER';
                  END IF;

                  DBMS_SPACE.UNUSED_SPACE(segment_owner             => p_owner,
                                          segment_name              => p_segname,
                                          segment_type              => p_type,
                                          partition_name            => p_partition,
                                          total_blocks              => l_total_blocks,
                                          total_bytes               => l_total_bytes,
                                          unused_blocks             => l_unused_blocks,
                                          unused_bytes              => l_unused_bytes,
                                          LAST_USED_EXTENT_FILE_ID  => l_LastUsedExtFileId,
                                          LAST_USED_EXTENT_BLOCK_ID => l_LastUsedExtBlockId,
                                          LAST_USED_BLOCK           => l_LAST_USED_BLOCK);

                  IF p_space = 'MANUAL' OR (p_space <> 'auto' AND p_space <> 'AUTO') THEN
                    DBMS_SPACE.FREE_BLOCKS(segment_owner     => p_owner,
                                           segment_name      => p_segname,
                                           segment_type      => p_type,
                                           partition_name    => p_partition,
                                           freelist_group_id => 0,
                                           free_blks         => l_free_blks);

                    p('Free Blocks', l_free_blks);
                  END IF;

                  p('Total Blocks', l_total_blocks);
                  p('Total Bytes', l_total_bytes);
                  p('Unused Blocks', l_unused_blocks);
                  p('Unused Bytes', l_unused_bytes);
                  p('Last Used Ext FileId', l_LastUsedExtFileId);
                  p('Last Used Ext BlockId', l_LastUsedExtBlockId);
                  p('Last Used Block', l_LAST_USED_BLOCK);

                  /*IF the segment is analyzed */
                  IF p_analyzed = 'Y' THEN
                    DBMS_SPACE.SPACE_USAGE(segment_owner      => p_owner,
                                           segment_name       => p_segname,
                                           segment_type       => p_type,
                                           partition_name     => p_partition,
                                           unformatted_blocks => l_unformatted_blocks,
                                           unformatted_bytes  => l_unformatted_bytes,
                                           fs1_blocks         => l_fs1_blocks,
                                           fs1_bytes          => l_fs1_bytes,
                                           fs2_blocks         => l_fs2_blocks,
                                           fs2_bytes          => l_fs2_bytes,
                                           fs3_blocks         => l_fs3_blocks,
                                           fs3_bytes          => l_fs3_bytes,
                                           fs4_blocks         => l_fs4_blocks,
                                           fs4_bytes          => l_fs4_bytes,
                                           full_blocks        => l_full_blocks,
                                           full_bytes         => l_full_bytes);
                    DBMS_OUTPUT.put_line(RPAD('', 50, '*'));
                    DBMS_OUTPUT.put_line('Thesegment is analyzed');
                    p('0% -- 25% free spaceblocks', l_fs1_blocks);
                    p('0% -- 25% free spacebytes', l_fs1_bytes);
                    p('25% -- 50% free spaceblocks', l_fs2_blocks);
                    p('25% -- 50% free spacebytes', l_fs2_bytes);
                    p('50% -- 75% free spaceblocks', l_fs3_blocks);
                    p('50% -- 75% free spacebytes', l_fs3_bytes);
                    p('75% -- 100% free spaceblocks', l_fs4_blocks);
                    p('75% -- 100% free spacebytes', l_fs4_bytes);
                    p('Unused Blocks', l_unformatted_blocks);
                    p('Unused Bytes', l_unformatted_bytes);
                    p('Total Blocks', l_full_blocks);
                    p('Total bytes', l_full_bytes);
                  END IF;
                END;
/
!
exit 0
fi

if [ "$1" = "bind_val" ]; then
  if [ "$2" = "" ]; then
    usage "sid is missing"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set line 120
    set long 100000
    set pagesize 5000
    select xmltype(binds_xml)
        from v\$sql_monitor
        where sid = $2 and status = 'EXECUTING';
!
exit 0
fi

# ora create_tbs /u01/app/oracle/oradata/testdb2/ 5
if [ "$1" = "create_tbs" ]; then
  if [ "$2" = "" ]; then
    usage "Datafile path is missing"
  fi

  if [ "$3" = "" ]; then
    usage "Datafile initial file is missing"
  fi

  if [ "$4" = "" ]; then
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 200
            set pagesize 0
                        select 'create tablespace ' || cr.TABLESPACE_NAME || ' datafile ''' ||
                               '$2' || lower(cr.TABLESPACE_NAME) ||
                                trim(to_char(cr.min_file_id, '0000'))||'.dbf'' size '||'$3'||'m autoextend on;'  create_tbs
                        from (select tablespace_name, min(file_id) min_file_id
                          from dba_data_files
                         where TABLESPACE_NAME not in ('SYSTEM', 'SYSAUX', 'USERS')
                           and TABLESPACE_NAME not like 'UNDOTBS%'
                         group by tablespace_name order by min_file_id) cr
                        union all
                        select 'alter tablespace ' || alt.TABLESPACE_NAME || ' add datafile ''' ||
                               '$2' || lower(alt.TABLESPACE_NAME) ||
                                trim(to_char(alt.file_id, '0000'))||'.dbf'' size '||'$3'||'m autoextend on;'  create_tbs
                        from (select tablespace_name, file_id
                          from dba_data_files
                         where TABLESPACE_NAME not in ('SYSTEM', 'SYSAUX', 'USERS')
                           and TABLESPACE_NAME not like 'UNDOTBS%'
                        minus
                        select tablespace_name, min(file_id) file_id
                          from dba_data_files
                         where TABLESPACE_NAME not in ('SYSTEM', 'SYSAUX', 'USERS')
                           and TABLESPACE_NAME not like 'UNDOTBS%'
                         group by tablespace_name order by file_id) alt
                        union all
                        select 'create temporary tablespace ' || cr.TABLESPACE_NAME || ' tempfile ''' ||
                               '$2' || lower(cr.TABLESPACE_NAME) ||
                                trim(to_char(cr.min_file_id, '0000'))||'.dbf'' size '||'$3'||'m autoextend on;'  create_tbs
                        from (select  tablespace_name,  min(file_id) min_file_id
                        from dba_temp_files
                         where TABLESPACE_NAME <> 'TEMP'
                        group by tablespace_name) cr
                        union all
                        select 'alter tablespace ' || alt.TABLESPACE_NAME || ' add tempfile ''' ||
                               '$2' || lower(alt.TABLESPACE_NAME) ||
                                trim(to_char(alt.file_id, '0000'))||'.dbf'' size '||'$3'||'m autoextend on;'  create_tbs
                        from (select  tablespace_name, file_id
                        from dba_temp_files
                         where TABLESPACE_NAME <> 'TEMP'
                        minus
                        select  tablespace_name,  min(file_id)
                        from dba_temp_files
                         where TABLESPACE_NAME <> 'TEMP'
                        group by tablespace_name) alt;
!
                exit 0
        else
          sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
            connect $DBUSER
            set linesize 200
            set pagesize 0

                        select 'create tablespace ' || cr.tsname || ' datafile ''' ||
                               '$2/' || lower(cr.tsname) ||
                               trim(to_char(cr.min_file_id, '0000')) || '.dbf'' size ' || '$3' ||
                               'm autoextend on;' create_tbs
                          from (select tsname, min(file#) min_file_id
                                  from dba_hist_datafile
                                 where dbid = $4
                                   and tsname not in ('SYSTEM', 'SYSAUX', 'USERS')
                                   and tsname not like 'UNDOTBS%'
                                 group by tsname
                                 order by min_file_id) cr
                        union all
                        select 'alter tablespace ' || alt.tsname || ' add datafile ''' ||
                               '$2/' || lower(alt.tsname) ||
                               trim(to_char(alt.file#, '0000')) || '.dbf'' size ' || '$3' ||
                               'm autoextend on;' create_tbs
                          from (select tsname, file#
                                  from dba_hist_datafile
                                 where dbid = $4
                                   and tsname not in ('SYSTEM', 'SYSAUX', 'USERS')
                                   and tsname not like 'UNDOTBS%'
                                minus
                                select tsname, min(file#) file#
                                  from dba_hist_datafile
                                 where dbid = $4
                                   and tsname not in ('SYSTEM', 'SYSAUX', 'USERS')
                                   and tsname not like 'UNDOTBS%'
                                 group by tsname
                                 order by file#) alt
                        union all
                        select 'create temporary tablespace ' || cr.tsname || ' tempfile ''' ||
                               '$2/' || lower(cr.tsname) ||
                               trim(to_char(cr.min_file_id, '0000')) || '.dbf'' size ' || '$3' ||
                               'm autoextend on;' create_tbs
                          from (select tsname, min(file#) min_file_id
                                  from dba_hist_tempfile
                                 where dbid = $4
                                   and tsname <> 'TEMP'
                                 group by tsname) cr
                        union all
                        select 'alter tablespace ' || alt.tsname || ' add tempfile ''' ||
                               '$2/' || lower(alt.tsname) ||
                               trim(to_char(alt.file#, '0000')) || '.dbf'' size ' || '$3' ||
                               'm autoextend on;' create_tbs
                          from (select tsname, file#
                                  from dba_hist_tempfile
                                 where dbid = $4
                                   and tsname <> 'TEMP'
                                minus
                                select tsname, min(file#)
                                  from dba_hist_tempfile
                                 where dbid = $4
                                   and tsname <> 'TEMP'
                                 group by tsname) alt;
!
                exit 0
        fi
fi

if [ "$1" = "tbs" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 200
    set pagesize 5000
                SELECT d.tablespace_name "Name",
                       NVL(a.bytes / 1024 / 1024, 0) "Size (M)",
                       NVL(a.bytes - NVL(f.bytes, 0), 0) / 1024 / 1024 "Used (M)",
                       TO_CHAR(NVL((a.bytes - NVL(f.bytes, 0)) / a.bytes * 100, 0), '990.00') "Used %",
                       NVL(a.bytes / 1024 / 1024, 0) - NVL(a.bytes - NVL(f.bytes, 0), 0) / 1024 / 1024 "Free (M)",
                       d.contents "Type",
                       d.extent_management "Extent Management"
                  FROM sys.dba_tablespaces d,
                       (select tablespace_name, sum(bytes) bytes
                          from dba_data_files
                         group by tablespace_name) a,
                       (select tablespace_name, sum(bytes) bytes
                          from dba_free_space
                         group by tablespace_name) f
                 WHERE d.tablespace_name = a.tablespace_name(+)
                   AND d.tablespace_name = f.tablespace_name(+)
                   AND NOT
                        (d.extent_management like 'LOCAL' AND d.contents like 'TEMPORARY')
                UNION ALL
                SELECT d.tablespace_name "Name",
                       NVL(a.bytes / 1024 / 1024, 0) "Size (M)",
                       NVL(t.bytes, 0) / 1024 / 1024 "Used (M)",
                       TO_CHAR(NVL(t.bytes / a.bytes * 100, 0), '990.00') "Used %",
                       NVL(a.bytes / 1024 / 1024, 0) - NVL(t.bytes, 0) / 1024 / 1024 "Free (M)",
                       d.contents "Type",
                       d.extent_management "Extent Management"
                  FROM sys.dba_tablespaces d,
                       (select tablespace_name, sum(bytes) bytes
                          from dba_temp_files
                         group by tablespace_name) a,
                       (select tablespace_name, sum(bytes_cached) bytes
                          from v\$temp_extent_pool
                         group by tablespace_name) t
                 WHERE d.tablespace_name = a.tablespace_name(+)
                   AND d.tablespace_name = t.tablespace_name(+)
                   AND d.extent_management like 'LOCAL'
                   AND d.contents like 'TEMPORARY';
!
exit 0
fi

if [ "$1" = "buffer_cache" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"

  connect $DBUSER
                REM List Buffer Cache Details
                SET LINESIZE 200 PAGESIZE 1400
                SELECT /*+ ORDERED USE_HASH(o u) MERGE */
                 DECODE(obj#,
                        NULL,
                        to_char(bh.obj),
                        u.name || '.' || o.name) name,
                 COUNT(*) total,
                 SUM(DECODE((DECODE(lru_flag, 8, 1, 0) + DECODE(SIGN(tch - 2), 1, 1, 0)),
                            2,
                            1,
                            1,
                            1,
                            0)) hot,
                 SUM(DECODE(DECODE(SIGN(lru_flag - 8), 1, 0, 0, 0, 1) +
                            DECODE(tch, 2, 1, 1, 1, 0, 1, 0),
                            2,
                            1,
                            1,
                            0,
                            0)) cold,
                 SUM(DECODE(BITAND(flag, POWER(2, 19)), 0, 0, 1)) fts,
                 SUM(tch) total_tch,
                 ROUND(AVG(tch), 2) avg_tch,
                 MAX(tch) max_tch,
                 MIN(tch) min_tch
                  FROM x\$bh bh, sys.obj\$ o, sys.user\$ u
                 WHERE
                    bh.obj <> 4294967295
                   AND bh.state in (1, 2, 3)
                   AND bh.obj = o.dataobj#(+)
                   AND bh.inst_id = USERENV('INSTANCE')
                 AND o.owner# = u.user#(+)
                --   AND o.owner# > 5
                   AND u.name NOT like 'AURORA$%'
                 GROUP BY DECODE(obj#,
                                 NULL,
                                 to_char(bh.obj),
                                 u.name || '.' || o.name)
                 ORDER BY  total desc
                 /


                 COLUMN object_name FORMAT A30

                SELECT t.name AS tablespace_name,
                       o.object_name,
                       SUM(DECODE(bh.status, 'free', 1, 0)) AS free,
                       SUM(DECODE(bh.status, 'xcur', 1, 0)) AS xcur,
                       SUM(DECODE(bh.status, 'scur', 1, 0)) AS scur,
                       SUM(DECODE(bh.status, 'cr', 1, 0)) AS cr,
                       SUM(DECODE(bh.status, 'read', 1, 0)) AS read,
                       SUM(DECODE(bh.status, 'mrec', 1, 0)) AS mrec,
                       SUM(DECODE(bh.status, 'irec', 1, 0)) AS irec
                FROM   v\$bh bh
                       JOIN dba_objects o ON o.data_object_id = bh.objd
                       JOIN v\$tablespace t ON t.ts# = bh.ts#
                GROUP BY t.name, o.object_name
                order by xcur desc
                /



                set pages 999
                set lines 92

                ttitle 'Contents of Data Buffers'

                drop view buffer_map;
                create view buffer_map as
                select
                   o.owner          owner,
                   o.object_name    object_name,
                   o.subobject_name subobject_name,
                   o.object_type    object_type,
                   count(distinct file# || block#)         num_blocks
                from
                   dba_objects  o,
                   v\$bh         bh
                where
                   o.data_object_id  = bh.objd
                -- and  o.owner not in ('SYS','SYSTEM')
                and
                   bh.status != 'free'
                group by
                   o.owner,
                   o.object_name,
                   o.subobject_name,
                   o.object_type
                order by
                   count(distinct file# || block#) desc
                ;

                column c0 heading "Owner"                                    format a12
                column c1 heading "Object|Name"                              format a30
                column c2 heading "Object|Type"                              format a8
                column c3 heading "Number of|Blocks in|Buffer|Cache"         format 99,999,999
                column c4 heading "Percentage|of object|blocks in|Buffer"    format 999
                column c5 heading "Buffer|Pool"                              format a7
                column c6 heading "Block|Size"                               format 99,999

                select
                   buffer_map.owner                                          c0,
                   object_name                                       c1,
                   case when object_type = 'TABLE PARTITION' then 'TAB PART'
                        when object_type = 'INDEX PARTITION' then 'IDX PART'
                        else object_type end c2,
                   sum(num_blocks)                                     c3,
                   (sum(num_blocks)/greatest(sum(blocks), .001))*100 c4,
                   buffer_pool                                       c5,
                   sum(bytes)/sum(blocks)                            c6
                from
                   buffer_map,
                   dba_segments s
                where
                   s.segment_name = buffer_map.object_name
                and
                   s.owner = buffer_map.owner
                and
                   s.segment_type = buffer_map.object_type
                and
                   nvl(s.partition_name,'-') = nvl(buffer_map.subobject_name,'-')
                group by
                   buffer_map.owner,
                   object_name,
                   object_type,
                   buffer_pool
                having
                   sum(num_blocks) > 10
                order by
                   sum(num_blocks) desc
                ;

                REM dbbuffer

                select decode(pd.bp_id,1,'KEEP',2,'RECYCLE',3,'DEFAULT',
                         4,'2K SUBCACHE',5,'4K SUBCACHE',6,'8K SUBCACHE',
                         7,'16K SUBCACHE',8,'32KSUBCACHE','UNKNOWN') subcache,
                         bh.object_name,bh.blocks
                from x\$kcbwds ds,x\$kcbwbpd pd,(select /*+ use_hash(x) */ set_ds,
                         o.name object_name,count(*) BLOCKS
                         from obj\$ o, x\$bh x where o.dataobj# = x.obj
                         and x.state !=0 and o.owner# !=0
                         group by set_ds,o.name) bh
                where ds.set_id >= pd.bp_lo_sid
                and ds.set_id <= pd.bp_hi_sid
                and pd.bp_size != 0
                and ds.addr=bh.set_ds;

                column segment_name format a35
                     select /*+ RULE */
                       e.owner ||'.'|| e.segment_name  segment_name,
                       e.extent_id  extent#,
                       x.dbablk - e.block_id + 1  block#,
                       x.tch,
                       l.child#
                     from
                       sys.v\$latch_children  l,
                       sys.x\$bh  x,
                       sys.dba_extents  e
                     where
                       x.hladdr  = '&ADDR' and
                       e.file_id = x.file# and
                       x.hladdr = l.addr and
                       x.dbablk between e.block_id and e.block_id + e.blocks -1
                     order by x.tch desc
                /



                with bh_lc as
                       (select /*+ ORDERED */
                          lc.addr, lc.child#, lc.gets, lc.misses, lc.immediate_gets,
                          lc.immediate_misses, lc.spin_gets, lc.sleeps,
                          bh.hladdr, bh.tch tch, bh.file#, bh.dbablk, bh.class,
                          bh.state, bh.obj
                        from
                          x\$kslld ld,
                          v\$session_wait sw,
                          v\$latch_children lc,
                          x\$bh bh
                        where lc.addr =sw.p1raw
                          and sw.p2= ld.indx
                          and ld.kslldnam='cache buffers chains'
                          and lower(sw.event) like '%latch%'
                          and sw.state='WAITING'
                          and bh.hladdr=lc.addr
                       )
                     select bh_lc.hladdr, bh_lc.tch, o.owner, o.object_name, o.object_type,
                            bh_lc.child#, bh_lc.gets,
                            bh_lc.misses, bh_lc.immediate_gets,
                            bh_lc.immediate_misses, spin_gets, sleeps
                     from
                       bh_lc,
                       dba_objects o
                     where bh_lc.obj = o.object_id(+)
                   union
                     select bh_lc.hladdr, bh_lc.tch, o.owner, o.object_name, o.object_type,
                            bh_lc.child#, bh_lc.gets, bh_lc.misses, bh_lc.immediate_gets,
                            bh_lc.immediate_misses, spin_gets, sleeps
                     from
                       bh_lc,
                       dba_objects o
                     where bh_lc.obj = o.data_object_id(+)
                  order by 1,2 desc
                /

                col class form A10
                select decode(greatest(class,10),10,decode(class,1,'Data',2
                            ,'Sort',4,'Header',to_char(class)),'Rollback') "Class",
                       sum(decode(bitand(flag,1),1,0,1)) "Not Dirty",
                 sum(decode(bitand(flag,1),1,1,0)) "Dirty",
                       sum(dirty_queue) "On Dirty",count(*) "Total"
                from x\$bh
                group by decode(greatest(class,10),10,decode(class,1,'Data',2
                         ,'Sort',4,'Header',to_char(class)),'Rollback')
                /
!
exit 0
fi

if [ "$1" = "sudoku" ]; then
  if [ "$2" = "" ]; then
    usage "input is missing"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 130

                with x(s, ind) as
                 (select sud, instr(sud, ' ')
                    from (select '$2' sud
                            from dual)
                  union all
                  select substr(s, 1, ind - 1) || z || substr(s, ind + 1),
                         instr(s, ' ', ind + 1)
                    from x, (select to_char(rownum) z from dual connect by rownum <= 9) z
                   where ind > 0
                     and not exists
                   (select null
                            from (select rownum lp from dual connect by rownum <= 9)
                           where z = substr(s, trunc((ind - 1) / 9) * 9 + lp, 1)
                              or z = substr(s, mod(ind - 1, 9) - 8 + lp * 9, 1)
                              or z = substr(s,
                                            mod(trunc((ind - 1) / 3), 3) * 3 +
                                            trunc((ind - 1) / 27) * 27 + lp +
                                            trunc((lp - 1) / 3) * 6,
                                            1)))
                select s from x where ind = 0;
!
exit 0
fi

if [ "$1" = "itl" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
    col OWNER for a15
    col OBJECT_NAME for a15
    col OBJECT_TYPE for a15
    col STATISTIC_NAME for a15

                SELECT t.OWNER, t.OBJECT_NAME, t.OBJECT_TYPE, t.STATISTIC_NAME, t.VALUE
                FROM v\$segment_statistics t
                WHERE t.STATISTIC_NAME = 'ITL waits'
                AND t.VALUE > 0;
!
exit 0
fi

if [ "$1" = "charset" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
    select value from v\$nls_parameters where parameter='NLS_CHARACTERSET';
!
exit 0
fi

if [ "$1" = "enable_trace" ]; then
  if [ "$2" = "" ]; then
    usage "ora enable_trace session_id serial_number#"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
    EXEC DBMS_SYSTEM.set_ev(si=>$2, se=>$3, ev=>10046, le=>12, nm=>'');
    --EXEC DBMS_SYSTEM.set_sql_trace_in_session(sid=>$2, serial#=>$3, sql_trace=>TRUE);
!
exit 0
fi

if [ "$1" = "disable_trace" ]; then
  if [ "$2" = "" ]; then
    usage "ora enable_trace session_id serial_number#"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 120
    EXEC DBMS_SYSTEM.set_ev(si=>$2, se=>$3, ev=>10046, le=>0, nm=>'');
    --EXEC DBMS_SYSTEM.set_sql_trace_in_session(sid=>$2, serial#=>$3, sql_trace=>FALSE);
!
exit 0
fi

if [ "$1" = "tfsclock" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set lines 200
                set pagesize 66
                break on Kill on sid on  username on terminal
                column Kill heading 'Kill String' format a13
                column res heading 'Resource Type' format 999
                column id1 format 9999990
                column id2 format 9999990
                column locking heading 'Lock Held/Lock Requested' format a40
                column lmode heading 'Lock Held' format a20
                column request heading 'Lock Requested' format a20
                column serial# format 99999
                column username  format a10  heading "Username"
                column terminal heading Term format a6
                column tab format a30 heading "Table Name"
                column owner format a9
                column LAddr heading "ID1 - ID2" format a18
                column Lockt heading "Lock Type" format a40
                column command format a25
                column sid format 990

                select
                nvl(S.USERNAME,'Internal') username,
                        L.SID,
                        nvl(S.TERMINAL,'None') terminal,
                        decode(command,
                0,'None',decode(l.id2,0,U1.NAME||'.'||substr(T1.NAME,1,20),'None')) tab,
                decode(command,
                0,'BACKGROUND',
                1,'Create Table',
                2,'INSERT',
                3,'SELECT',
                4,'CREATE CLUSTER',
                5,'ALTER CLUSTER',
                6,'UPDATE',
                7,'DELETE',
                8,'DROP',
                9,'CREATE INDEX',
                10,'DROP INDEX',
                11,'ALTER INDEX',
                12,'DROP TABLE',
                13,'CREATE SEQUENCE',
                14,'ALTER SEQUENCE',
                15,'ALTER TABLE',
                16,'DROP SEQUENCE',
                17,'GRANT',
                18,'REVOKE',
                19,'CREATE SYNONYM',
                20,'DROP SYNONYM',
                21,'CREATE VIEW',
                22,'DROP VIEW',
                23,'VALIDATE INDEX',
                24,'CREATE PROCEDURE',
                25,'ALTER PROCEDURE',
                26,'LOCK TABLE',
                27,'NO OPERATION',
                28,'RENAME',
                29,'COMMENT',
                30,'AUDIT',
                31,'NOAUDIT',
                32,'CREATE EXTERNAL DATABASE',
                33,'DROP EXTERNAL DATABASE',
                34,'CREATE DATABASE',
                35,'ALTER DATABASE',
                36,'CREATE ROLLBACK SEGMENT',
                37,'ALTER ROLLBACK SEGMENT',
                38,'DROP ROLLBACK SEGMENT',
                39,'CREATE TABLESPACE',
                40,'ALTER TABLESPACE',
                41,'DROP TABLESPACE',
                42,'ALTER SESSION',
                43,'ALTER USER',
                44,'COMMIT',
                45,'ROLLBACK',
                46,'SAVEPOINT',
                47,'PL/SQL EXECUTE',
                48,'SET TRANSACTION',
                49,'ALTER SYSTEM SWITCH LOG',
                50,'EXPLAIN',
                51,'CREATE USER',
                52,'CREATE ROLE',
                53,'DROP USER',
                54,'DROP ROLE',
                55,'SET ROLE',
                56,'CREATE SCHEMA',
                57,'CREATE CONTROL FILE',
                58,'ALTER TRACING',
                59,'CREATE TRIGGER',
                60,'ALTER TRIGGER',
                61,'DROP TRIGGER',
                62,'ANALYZE TABLE',
                63,'ANALYZE INDEX',
                64,'ANALYZE CLUSTER',
                65,'CREATE PROFILE',
                66,'DROP PROFILE',
                67,'ALTER PROFILE',
                68,'DROP PROCEDURE',
                69,'DROP PROCEDURE',
                70,'ALTER RESOURCE COST',
                71,'CREATE SNAPSHOT LOG',
                72,'ALTER SNAPSHOT LOG',
                73,'DROP SNAPSHOT LOG',
                74,'CREATE SNAPSHOT',
                75,'ALTER SNAPSHOT',
                76,'DROP SNAPSHOT',
                79,'ALTER ROLE',
                85,'TRUNCATE TABLE',
                86,'TRUNCATE CLUSTER',
                87,'-',
                88,'ALTER VIEW',
                89,'-',
                90,'-',
                91,'CREATE FUNCTION',
                92,'ALTER FUNCTION',
                93,'DROP FUNCTION',
                94,'CREATE PACKAGE',
                95,'ALTER PACKAGE',
                96,'DROP PACKAGE',
                97,'CREATE PACKAGE BODY',
                98,'ALTER PACKAGE BODY',
                99,'DROP PACKAGE BODY',
                command||' - ???') COMMAND,
                        decode(L.LMODE,1,'No Lock',
                                2,'Row Share',
                                3,'Row Exclusive',
                                4,'Share',
                                5,'Share Row Exclusive',
                                6,'Exclusive','NONE') lmode,
                        decode(L.REQUEST,1,'No Lock',
                                2,'Row Share',
                                3,'Row Exclusive',
                                4,'Share',
                                5,'Share Row Exclusive',
                                6,'Exclusive','NONE') request,
                l.id1||'-'||l.id2 Laddr,
                l.type||' - '||
                decode(l.type,
                'BL','Buffer hash table instance lock',
                'CF',' Control file schema global enqueue lock',
                'CI','Cross-instance function invocation instance lock',
                'CS','Control file schema global enqueue lock',
                'CU','Cursor bind lock',
                'DF','Data file instance lock',
                'DL','Direct loader parallel index create',
                'DM','Mount/startup db primary/secondary instance lock',
                'DR','Distributed recovery process lock',
                'DX','Distributed transaction entry lock',
                'FI','SGA open-file information lock',
                'FS','File set lock',
                'HW','Space management operations on a specific segment lock',
                'IN','Instance number lock',
                'IR','Instance recovery serialization global enqueue lock',
                'IS','Instance state lock',
                'IV','Library cache invalidation instance lock',
                'JQ','Job queue lock',
                'KK','Thread kick lock',
                'MB','Master buffer hash table instance lock',
                'MM','Mount definition gloabal enqueue lock',
                'MR','Media recovery lock',
                'PF','Password file lock',
                'PI','Parallel operation lock',
                'PR','Process startup lock',
                'PS','Parallel operation lock',
                'RE','USE_ROW_ENQUEUE enforcement lock',
                'RT','Redo thread global enqueue lock',
                'RW','Row wait enqueue lock',
                'SC','System commit number instance lock',
                'SH','System commit number high water mark enqueue lock',
                'SM','SMON lock',
                'SN','Sequence number instance lock',
                'SQ','Sequence number enqueue lock',
                'SS','Sort segment lock',
                'ST','Space transaction enqueue lock',
                'SV','Sequence number value lock',
                'TA','Generic enqueue lock',
                'TD','DDL enqueue lock',
                'TE','Extend-segment enqueue lock',
                'TM','DML enqueue lock',
                'TO','Temporary Table Object Enqueue',
                'TT','Temporary table enqueue lock',
                'TX','Transaction enqueue lock',
                'UL','User supplied lock',
                'UN','User name lock',
                'US','Undo segment DDL lock',
                'WL','Being-written redo log instance lock',
                'WS','Write-atomic-log-switch global enqueue lock',
                'TS',decode(l.id2,0,'Temporary segment enqueue lock (ID2=0)',
                                    'New block allocation enqueue lock (ID2=1)'),
                'LA','Library cache lock instance lock (A=namespace)',
                'LB','Library cache lock instance lock (B=namespace)',
                'LC','Library cache lock instance lock (C=namespace)',
                'LD','Library cache lock instance lock (D=namespace)',
                'LE','Library cache lock instance lock (E=namespace)',
                'LF','Library cache lock instance lock (F=namespace)',
                'LG','Library cache lock instance lock (G=namespace)',
                'LH','Library cache lock instance lock (H=namespace)',
                'LI','Library cache lock instance lock (I=namespace)',
                'LJ','Library cache lock instance lock (J=namespace)',
                'LK','Library cache lock instance lock (K=namespace)',
                'LL','Library cache lock instance lock (L=namespace)',
                'LM','Library cache lock instance lock (M=namespace)',
                'LN','Library cache lock instance lock (N=namespace)',
                'LO','Library cache lock instance lock (O=namespace)',
                'LP','Library cache lock instance lock (P=namespace)',
                'LS','Log start/log switch enqueue lock',
                'PA','Library cache pin instance lock (A=namespace)',
                'PB','Library cache pin instance lock (B=namespace)',
                'PC','Library cache pin instance lock (C=namespace)',
                'PD','Library cache pin instance lock (D=namespace)',
                'PE','Library cache pin instance lock (E=namespace)',
                'PF','Library cache pin instance lock (F=namespace)',
                'PG','Library cache pin instance lock (G=namespace)',
                'PH','Library cache pin instance lock (H=namespace)',
                'PI','Library cache pin instance lock (I=namespace)',
                'PJ','Library cache pin instance lock (J=namespace)',
                'PL','Library cache pin instance lock (K=namespace)',
                'PK','Library cache pin instance lock (L=namespace)',
                'PM','Library cache pin instance lock (M=namespace)',
                'PN','Library cache pin instance lock (N=namespace)',
                'PO','Library cache pin instance lock (O=namespace)',
                'PP','Library cache pin instance lock (P=namespace)',
                'PQ','Library cache pin instance lock (Q=namespace)',
                'PR','Library cache pin instance lock (R=namespace)',
                'PS','Library cache pin instance lock (S=namespace)',
                'PT','Library cache pin instance lock (T=namespace)',
                'PU','Library cache pin instance lock (U=namespace)',
                'PV','Library cache pin instance lock (V=namespace)',
                'PW','Library cache pin instance lock (W=namespace)',
                'PX','Library cache pin instance lock (X=namespace)',
                'PY','Library cache pin instance lock (Y=namespace)',
                'PZ','Library cache pin instance lock (Z=namespace)',
                'QA','Row cache instance lock (A=cache)',
                'QB','Row cache instance lock (B=cache)',
                'QC','Row cache instance lock (C=cache)',
                'QD','Row cache instance lock (D=cache)',
                'QE','Row cache instance lock (E=cache)',
                'QF','Row cache instance lock (F=cache)',
                'QG','Row cache instance lock (G=cache)',
                'QH','Row cache instance lock (H=cache)',
                'QI','Row cache instance lock (I=cache)',
                'QJ','Row cache instance lock (J=cache)',
                'QL','Row cache instance lock (K=cache)',
                'QK','Row cache instance lock (L=cache)',
                'QM','Row cache instance lock (M=cache)',
                'QN','Row cache instance lock (N=cache)',
                'QO','Row cache instance lock (O=cache)',
                'QP','Row cache instance lock (P=cache)',
                'QQ','Row cache instance lock (Q=cache)',
                'QR','Row cache instance lock (R=cache)',
                'QS','Row cache instance lock (S=cache)',
                'QT','Row cache instance lock (T=cache)',
                'QU','Row cache instance lock (U=cache)',
                'QV','Row cache instance lock (V=cache)',
                'QW','Row cache instance lock (W=cache)',
                'QX','Row cache instance lock (X=cache)',
                'QY','Row cache instance lock (Y=cache)',
                'QZ','Row cache instance lock (Z=cache)','????') Lockt
                from    V\$LOCK L,
                        V\$SESSION S,
                        SYS.USER$ U1,
                        SYS.OBJ$ T1
                where   L.SID = S.SID
                and     T1.OBJ#  = decode(L.ID2,0,L.ID1,1)
                and     U1.USER# = T1.OWNER#
                and     S.TYPE != 'BACKGROUND'
                order by 1,2,5
/
!
exit 0
fi


if [ "$1" = "sqlm" ]; then
        sqlplus -s / as sysdba  << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                set termout off long 500000000 longchunksize 500000000 pages 0 timing off echo off verify off lines 3000 trimspool on
                spool $2.xml
                select
                DBMS_SQLTUNE.REPORT_SQL_MONITOR(
                   sql_id=>'$2',
                   type=>'xml',
                   report_level=>'ALL') as report
                from dual;
                spool off
                spool $2.html
                select
                DBMS_SQLTUNE.REPORT_SQL_MONITOR(
                   sql_id=>'$2',
                   type=>'html',
                   report_level=>'ALL') as report
                from dual;
                spool off
                set termout on pages 50000 timing on
!
        shift 1
{
echo '<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <base href="http://download.oracle.com/otn_software/"/>
        <script language="javascript" type="text/javascript" src="emviewers/scripts/flashver.js">
            <!--Test flash version-->
        </script>
        <style>
      body { margin: 0px; overflow:hidden }
    </style>
    </head>
    <body scroll="no">
        <script type="text/xml">
            <!--FXTMODEL-->
<report>
'
cat $2.xml
echo '</report>
            <!--FXTMODEL-->
        </script>
        <script language="JavaScript" type="text/javascript" src="emviewers/scripts/loadswf.js">
            <!--Load report viewer-->
        </script>
        <iframe name="_history" frameborder="0" scrolling="no" width="22" height="0">
            <html>
                <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
                    <script type="text/javascript" language="JavaScript1.2" charset="utf-8">
                var v = new top.Vars(top.getSearch(window));
                var fv = v.toString('$_');
              </script>
                </head>
                <body>
                    <script type="text/javascript" language="JavaScript1.2" charset="utf-8" src="emviewers/scripts/document.js">
                        <!--Run document script-->
                    </script>
                </body>
            </html>
        </iframe>
    </body>
</html>
'
}> $2.htm
fi

if [ "$1" = "hugepage" ]; then
        shift 1
        # Check for the kernel version
        KERN=`uname -r | awk -F. '{ printf("%d.%d\n",$1,$2); }'`

        # Find out the HugePage size
        HPG_SZ=`grep Hugepagesize /proc/meminfo | awk '{print $2}'`
        if [ -z "$HPG_SZ" ];then
            echo "The hugepages may not be supported in the system where the script is being executed."
            exit 1
        fi

        # Initialize the counter
        NUM_PG=0

        # Cumulative number of pages required to handle the running shared memory segments
        for SEG_BYTES in `ipcs -m | cut -c44-300 | awk '{print $1}' | grep "[0-9][0-9]*"`
        do
            MIN_PG=`echo "$SEG_BY TES/($HPG_SZ*1024)" | bc -q`
            if [ $MIN_PG -gt 0 ]; then
                NUM_PG=`echo "$NUM_PG+$MIN_PG+1" | bc -q`
            fi
        done

        RES_BYTES=`echo "$NUM_PG * $HPG_SZ * 1024" | bc -q`

        # An SGA less than 100MB does not make sense
        # Bail out if that is the case
        if [ $RES_BYTES -lt 100000000 ]; then
            echo "***********"
            echo "** ERROR **"
            echo "***********"
            echo "Sorry! There are not enough total of shared memory segments allocated for
        HugePages configuration. HugePages can only be used for shared memory segments
        that you can list by command:

            # ipcs -m

        of a size that can match an Oracle Database SGA. Please make sure that:
         * Oracle Database instance is up and running
         * Oracle Database 11g Automatic Memory Management (AMM) is not configured"
            exit 1
        fi

        # Finish with results
        case $KERN in
            '2.2') echo "Kernel version $KERN is not supported. Exiting." ;;
            '2.4') HUGETLB_POOL=`echo "$NUM_PG*$HPG_SZ/1024" | bc -q`;
                   echo "Recommended setting: vm.hugetlb_pool = $HUGETLB_POOL" ;;
            '2.6') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
        esac
        exit 0
fi

if [ "$1" = "lock_sql" ]; then
        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 140
    select distinct
                        a.sid "waiting sid"
                        , d.sql_text "waiting SQL"
                        , a.ROW_WAIT_OBJ# "locked object"
                        , a.BLOCKING_SESSION "blocking sid"
                        , c.sql_text "SQL from blocking session"
                        from v\$session a, v\$active_session_history b, v\$sql c, v\$sql d
                        where a.event='enq: TX - row lock contention'
                        and a.sql_id=d.sql_id
                        and a.blocking_session=b.session_id
                        and c.sql_id=b.sql_id
                        and b.CURRENT_OBJ#=a.ROW_WAIT_OBJ#
                        and b.CURRENT_FILE#= a.ROW_WAIT_FILE#
                        and b.CURRENT_BLOCK#= a.ROW_WAIT_BLOCK#;
!
exit 0
fi

if [ "$1" = "tcb" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 100
    set pagesize 200
       select 'create or replace package p1 is sql1 varchar2(4000) := q''#' || chr(10) ||
          'select * from emp#'';' || chr(10) ||
          'end;' || chr(10) ||
          '/' || chr(10) || chr(10) ||
          'declare' || chr(10) ||
          '  tco clob;' || chr(10) ||
          'begin' || chr(10) ||
          '  dbms_sqldiag.export_sql_testcase(directory =>''DATA_PUMP_DIR'',' || chr(10) ||
          '    sql_text=> p1.sql1,' || chr(10) ||
          '    user_name=> ''USER'',' || chr(10) ||
          '    exportData => TRUE,' || chr(10) ||
          '    testcase => tco);' || chr(10) ||
          'end;' || chr(10) ||
          '/'|| chr(10) || chr(10) ||
          'set serveroutput on' || chr(10) ||
          'begin' || chr(10) ||
          '  dbms_sqldiag.import_sql_testcase(directory =>''DATA_PUMP_DIR'',' || chr(10) ||
          '    filename=> ''mail.xml'',' || chr(10) ||
          '    importdata => TRUE);' || chr(10) ||
          'end;' || chr(10) ||
          '/' as tcb_scripts
     from dual;
!
exit 0
fi

if [ "$1" = "p1" ]; then
  if [ "$2" = "" ]; then
    usage "p2 is missing"
  fi
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
var ACCEPTDIS VARCHAR2(32)
var BENAME VARCHAR2(32)
var EENAME VARCHAR2(32)
var IMPLTYP VARCHAR2(32)
var PROFILETYP VARCHAR2(32)
var SQLTYP NUMBER
var TID NUMBER

--SID: 258,16699
exec :ACCEPTDIS:='ACCEPTDISABLED';
exec :BENAME:='EXEC_42756';
exec :EENAME:='EXEC_43638';
exec :IMPLTYP:='IMPLEMENTATION';
exec :PROFILETYP:='SQL PROFILE';
exec :SQLTYP:=7
exec :TID:=29631

--SID: 1790,51175
var ACCEPTDIS VARCHAR2(32)
var BENAME VARCHAR2(32)
var EENAME VARCHAR2(32)
var IMPLTYP VARCHAR2(32)
var PROFILETYP VARCHAR2(32)
var SQLTYP NUMBER
var TID NUMBER

--SID: 1790,51175
exec :ACCEPTDIS:='ACCEPTDISABLED';
exec :BENAME:='EXEC_42756';
exec :EENAME:='EXEC_43638';
exec :IMPLTYP:='IMPLEMENTATION';
exec :PROFILETYP:='SQL PROFILE';
exec :SQLTYP:=7
exec :TID:=29631

SELECT /*+ leading(oe f r l) */
              /* STN_REPT_TOP_PROF */
              xmlelement(
                "top_profiles",
                 xmlagg(xmlelement("obj_id", object_id)))
       FROM    (SELECT task_id, exec_name, exec_id, exec_start, object_id, sql_id,
                  parsing_schema, phv, obj_attr8
           FROM   (SELECT /*+ cardinality(o 5999) leading(e o) */
                          e.task_id task_id,
                          e.execution_name exec_name,
                          e.execution_id exec_id,
                          e.execution_start exec_start,
                          o.id object_id,
                          o.attr1 sql_id,
                          o.attr3 parsing_schema,
                          to_number(nvl(o.attr5, '0'))  phv,
                          nvl(o.attr8,0) obj_attr8,
                          row_number() over
                            (partition by o.attr1
                             order by     bitand(o.attr7, 32) asc,
                                          e.execution_start desc)
                            rn
                   FROM    (SELECT e.task_id, e.name execution_name, e.id execution_id,
                e.exec_start execution_start, e.status status#
         FROM (SELECT  task_id,
                       min(execution_name) keep (dense_rank first order by
                         execution_start) bename,
                       max(execution_name) keep (dense_rank last order by
                         execution_start) eename,
                       min(execution_start) bestart,
                       max(execution_start) eestart
               FROM    (SELECT task_id, name execution_name,
                               exec_start execution_start
                        FROM   wri$_adv_executions
                        WHERE  task_id = :tid and
                               name in (:bename, :eename))
               GROUP BY task_id) r,
               wri$_adv_executions e


         WHERE e.task_id = r.task_id and
               e.exec_start >= bestart and
               e.exec_start <= eestart and
               e.status IN (3, 4) and
               (bename <> eename OR e.name = bename)) e  /* e */,
                          wri$_adv_objects o
                   WHERE  o.task_id = e.task_id AND
                          o.exec_name = e.execution_name AND
                          o.type = :sqltyp)
            WHERE rn = 1) oe  /* oe */,
              wri$_adv_findings f,
              wri$_adv_recommendations r,
              wri$_adv_rationale l
       WHERE  oe.task_id = f.task_id AND oe.exec_name = f.exec_name AND
              oe.object_id = f.obj_id AND f.task_id = r.task_id AND
              f.exec_name = r.exec_name AND f.id = r.finding_id AND
              l.task_id = r.task_id AND l.exec_name = r.exec_name AND
              l.rec_id = r.id AND
              r.type = :profiletyp AND l.type = :impltyp AND
              l.attr1 = :acceptdis AND
              NOT EXISTS (SELECT 1
                          FROM   dba_sql_profiles p
                          WHERE  p.task_id = r.task_id AND
                                 p.task_exec_name = r.exec_name AND
                                 p.task_obj_id = oe.object_id AND
                                 p.task_fnd_id = r.finding_id AND
                                 p.task_rec_id = r.id);
!
exit 0
fi

if [ "$1" = "bad_block" ]; then
  if [ "$2" = "" ]; then
    usage "ora bad_bock file# block#"
  fi
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 140
    col segment_name format A18
    col segment_type format A18
    col owner format A18
    select segment_name,segment_type,owner  from dba_extents
        where file_id = $2
        and $3 between block_id  and block_id + blocks - 1;;
!
exit 0
fi

if [ "$1" = "lots_redo" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 140
    SELECT s.sid, s.serial#, s.username, s.program,
          i.block_changes
          FROM v\$session s, v\$sess_io i
          WHERE s.sid = i.sid
          ORDER BY 5 desc, 1, 2, 3, 4;
!
exit 0
fi

if [ "$1" = "lots_undo" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 140
    SELECT s.sid, s.serial#, s.username, s.program,
           t.used_ublk, t.used_urec
           FROM v\$session s, v\$transaction t
           WHERE s.taddr = t.addr
           ORDER BY 5 desc, 6 desc, 1, 2, 3, 4;
!
exit 0
fi

if [ "$1" = "p1" ]; then
  if [ "$2" = "" ]; then
    usage "p2 is missing"
  fi
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
    set linesize 140
    select 'p1' P1, 'p2' P2 from dual;
!
exit 0
fi

if [ "$1" = "monitor_memory" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
    connect $DBUSER
                SET LINESIZE 200

                COLUMN username FORMAT A20
                COLUMN module FORMAT A20

                SELECT NVL(a.username,'(oracle)') AS username,
                       a.module,
                       a.program,
                       Trunc(b.value/1024) AS memory_kb
                FROM   v\$session a,
                       v\$sesstat b,
                       v\$statname c
                WHERE  a.sid = b.sid
                AND    b.statistic# = c.statistic#
                AND    c.name = 'session pga memory'
                AND    a.program IS NOT NULL
                ORDER BY b.value DESC;
!
        exit 0
fi

if [ "$1" = "perf" ]; then
        if [ "$2" = "high_cpu" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                connect $DBUSER
                set pagesize 6000
                set linesize 120
                col username format a20
                col module format a40
                SELECT s.sid, s.serial#, p.spid as "OS PID",s.username, s.module, st.value/100 as "CPU sec"
                        FROM v\$sesstat st, v\$statname sn, v\$session s, v\$process p
                 WHERE sn.name = 'CPU used by this session' -- CPU
                         AND st.statistic# = sn.statistic#
                         AND st.sid = s.sid
                         AND s.paddr = p.addr
                         AND s.last_call_et < 1800               -- active within last 1/2 hour
                         AND s.logon_time > (SYSDATE - 240/1440) -- sessions logged on within 4 hours
                ORDER BY st.value desc;
!
exit 0
        elif [ "$2" = "high_waits" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                connect $DBUSER
                set pagesize 6000
                set linesize 120
                col username format a20
                col module   format a40
                SELECT s.sid, s.serial#, p.spid as "OS PID", s.username, s.module, se.time_waited
                        FROM v\$session_event se, v\$session s, v\$process p
                WHERE se.event = 'db file sequential read'
                        AND s.last_call_et < 1800 -- active within last 1/2 hour
                        AND s.logon_time > (SYSDATE - 240/1440) -- sessions logged on within 4 hours
                        AND se.sid = s.sid
                        AND s.paddr = p.addr
                ORDER BY se.time_waited;
!
exit 0
        elif [ "$2" = "high_dbtime" ]; then
                sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                connect $DBUSER
                set pagesize 6000
                set linesize 120
                col sid      format 99999
                col serial#  format 99999
                col "OS PID" format 999999
                col username format a10
                col module   format a30
                SELECT s.sid, s.serial#, p.spid as "OS PID", s.username, s.module, st.value/100 as "DB Time (sec)", stcpu.value/100 as "CPU Time (sec)", round(stcpu.value / st.value * 100,2) as "% CPU"
                        FROM v\$sesstat st, v\$statname sn, v\$session s, v\$sesstat stcpu, v\$statname sncpu, v\$process p
                WHERE sn.name = 'DB time' -- CPU
                        AND st.statistic# = sn.statistic#
                        AND st.sid = s.sid
                        AND  sncpu.name = 'CPU used by this session' -- CPU
                        AND stcpu.statistic# = sncpu.statistic#
                        AND stcpu.sid = st.sid
                        AND s.paddr = p.addr
                        AND s.last_call_et < 1800 -- active within last 1/2 hour
                        AND s.logon_time > (SYSDATE - 240/1440) -- sessions logged on within 4 hours
                        AND st.value > 0;
!
exit 0
        else
                        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                        connect $DBUSER
                        set pagesize 6000
                        set linesize 120
                        select sysdate from dual;
!
exit 0
  fi
fi

if [ "$1" = "disable_autotask" ]; then
                        sqlplus -s /NOLOG << ! | egrep -v "no rows selected|Session altered|Connected|rows selected"
                        connect $DBUSER
                        set pagesize 6000
                        set linesize 120
      BEGIN
         dbms_auto_task_admin.disable(client_name => 'auto optimizer stats collection', operation => NULL, window_name => NULL);
         dbms_auto_task_admin.disable(client_name => 'auto space advisor', operation => NULL, window_name => NULL);
         dbms_auto_task_admin.disable(client_name => 'sql tuning advisor', operation => NULL, window_name => NULL);
         dbms_scheduler.disable('SYS.GATHER_STATS_JOB');
         --dbms_scheduler.enable('SYS.GATHER_STATS_JOB');
      END;
      /
!
exit 0
fi

#
# Run a shell command. Useful when combined with repeat...
#
if [ "$1" = "sh" ]; then

  shift 1
  sh -fc "$*"
  exit 0
fi

